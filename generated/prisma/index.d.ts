
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrganizationMember
 * 
 */
export type OrganizationMember = $Result.DefaultSelection<Prisma.$OrganizationMemberPayload>
/**
 * Model Startup
 * 
 */
export type Startup = $Result.DefaultSelection<Prisma.$StartupPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model Simulation
 * 
 */
export type Simulation = $Result.DefaultSelection<Prisma.$SimulationPayload>
/**
 * Model SimulationInvestment
 * 
 */
export type SimulationInvestment = $Result.DefaultSelection<Prisma.$SimulationInvestmentPayload>
/**
 * Model SimulationLeaderboard
 * 
 */
export type SimulationLeaderboard = $Result.DefaultSelection<Prisma.$SimulationLeaderboardPayload>
/**
 * Model DealMatching
 * 
 */
export type DealMatching = $Result.DefaultSelection<Prisma.$DealMatchingPayload>
/**
 * Model LearningModule
 * 
 */
export type LearningModule = $Result.DefaultSelection<Prisma.$LearningModulePayload>
/**
 * Model UserLearningModule
 * 
 */
export type UserLearningModule = $Result.DefaultSelection<Prisma.$UserLearningModulePayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model Investment
 * 
 */
export type Investment = $Result.DefaultSelection<Prisma.$InvestmentPayload>
/**
 * Model VestingSchedule
 * 
 */
export type VestingSchedule = $Result.DefaultSelection<Prisma.$VestingSchedulePayload>
/**
 * Model KYCRecord
 * 
 */
export type KYCRecord = $Result.DefaultSelection<Prisma.$KYCRecordPayload>
/**
 * Model DueDiligenceReport
 * 
 */
export type DueDiligenceReport = $Result.DefaultSelection<Prisma.$DueDiligenceReportPayload>
/**
 * Model AdminActivityLog
 * 
 */
export type AdminActivityLog = $Result.DefaultSelection<Prisma.$AdminActivityLogPayload>
/**
 * Model PaymentIntent
 * 
 */
export type PaymentIntent = $Result.DefaultSelection<Prisma.$PaymentIntentPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model CryptoTx
 * 
 */
export type CryptoTx = $Result.DefaultSelection<Prisma.$CryptoTxPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model EntityDocument
 * 
 */
export type EntityDocument = $Result.DefaultSelection<Prisma.$EntityDocumentPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FundingStage: {
  PRE_SEED: 'PRE_SEED',
  SEED: 'SEED',
  SERIES_A: 'SERIES_A',
  SERIES_B: 'SERIES_B',
  SERIES_C: 'SERIES_C',
  BRIDGE: 'BRIDGE',
  IPO: 'IPO',
  OTHER: 'OTHER'
};

export type FundingStage = (typeof FundingStage)[keyof typeof FundingStage]


export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const EntityType: {
  STARTUP: 'STARTUP',
  TOKEN: 'TOKEN',
  SIMULATION: 'SIMULATION'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const UserRole: {
  INVESTOR: 'INVESTOR',
  FOUNDER: 'FOUNDER',
  ADMIN: 'ADMIN',
  MENTOR: 'MENTOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const FounderStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  SUSPENDED: 'SUSPENDED'
};

export type FounderStatus = (typeof FounderStatus)[keyof typeof FounderStatus]


export const PaymentStatus: {
  INITIATED: 'INITIATED',
  PROCESSING: 'PROCESSING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const Chain: {
  ETHEREUM: 'ETHEREUM',
  POLYGON: 'POLYGON',
  BASE: 'BASE',
  ARBITRUM: 'ARBITRUM',
  OTHER: 'OTHER'
};

export type Chain = (typeof Chain)[keyof typeof Chain]


export const DocumentType: {
  PITCH_DECK: 'PITCH_DECK',
  SAFE: 'SAFE',
  SAFT: 'SAFT',
  KYC: 'KYC',
  FINANCIAL_STATEMENTS: 'FINANCIAL_STATEMENTS',
  LEGAL_DOCUMENTS: 'LEGAL_DOCUMENTS',
  SIMULATION_REPORT: 'SIMULATION_REPORT',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const SimulationStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  PAUSED: 'PAUSED',
  ARCHIVED: 'ARCHIVED'
};

export type SimulationStatus = (typeof SimulationStatus)[keyof typeof SimulationStatus]


export const SimulationType: {
  INDIVIDUAL: 'INDIVIDUAL',
  COLLABORATIVE: 'COLLABORATIVE',
  TOURNAMENT: 'TOURNAMENT',
  SCENARIO_BASED: 'SCENARIO_BASED'
};

export type SimulationType = (typeof SimulationType)[keyof typeof SimulationType]


export const AccreditationStatus: {
  PENDING: 'PENDING',
  ACCREDITED: 'ACCREDITED',
  NON_ACCREDITED: 'NON_ACCREDITED',
  PENDING_REVIEW: 'PENDING_REVIEW'
};

export type AccreditationStatus = (typeof AccreditationStatus)[keyof typeof AccreditationStatus]


export const DealAccessLevel: {
  SIMULATION_ONLY: 'SIMULATION_ONLY',
  BASIC_ACCESS: 'BASIC_ACCESS',
  FULL_ACCESS: 'FULL_ACCESS',
  PREMIUM_ACCESS: 'PREMIUM_ACCESS'
};

export type DealAccessLevel = (typeof DealAccessLevel)[keyof typeof DealAccessLevel]

}

export type FundingStage = $Enums.FundingStage

export const FundingStage: typeof $Enums.FundingStage

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type FounderStatus = $Enums.FounderStatus

export const FounderStatus: typeof $Enums.FounderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type Chain = $Enums.Chain

export const Chain: typeof $Enums.Chain

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type SimulationStatus = $Enums.SimulationStatus

export const SimulationStatus: typeof $Enums.SimulationStatus

export type SimulationType = $Enums.SimulationType

export const SimulationType: typeof $Enums.SimulationType

export type AccreditationStatus = $Enums.AccreditationStatus

export const AccreditationStatus: typeof $Enums.AccreditationStatus

export type DealAccessLevel = $Enums.DealAccessLevel

export const DealAccessLevel: typeof $Enums.DealAccessLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMember`: Exposes CRUD operations for the **OrganizationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMembers
    * const organizationMembers = await prisma.organizationMember.findMany()
    * ```
    */
  get organizationMember(): Prisma.OrganizationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.startup`: Exposes CRUD operations for the **Startup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Startups
    * const startups = await prisma.startup.findMany()
    * ```
    */
  get startup(): Prisma.StartupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulation`: Exposes CRUD operations for the **Simulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Simulations
    * const simulations = await prisma.simulation.findMany()
    * ```
    */
  get simulation(): Prisma.SimulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulationInvestment`: Exposes CRUD operations for the **SimulationInvestment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationInvestments
    * const simulationInvestments = await prisma.simulationInvestment.findMany()
    * ```
    */
  get simulationInvestment(): Prisma.SimulationInvestmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.simulationLeaderboard`: Exposes CRUD operations for the **SimulationLeaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SimulationLeaderboards
    * const simulationLeaderboards = await prisma.simulationLeaderboard.findMany()
    * ```
    */
  get simulationLeaderboard(): Prisma.SimulationLeaderboardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dealMatching`: Exposes CRUD operations for the **DealMatching** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DealMatchings
    * const dealMatchings = await prisma.dealMatching.findMany()
    * ```
    */
  get dealMatching(): Prisma.DealMatchingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningModule`: Exposes CRUD operations for the **LearningModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningModules
    * const learningModules = await prisma.learningModule.findMany()
    * ```
    */
  get learningModule(): Prisma.LearningModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLearningModule`: Exposes CRUD operations for the **UserLearningModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLearningModules
    * const userLearningModules = await prisma.userLearningModule.findMany()
    * ```
    */
  get userLearningModule(): Prisma.UserLearningModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investment`: Exposes CRUD operations for the **Investment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investments
    * const investments = await prisma.investment.findMany()
    * ```
    */
  get investment(): Prisma.InvestmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vestingSchedule`: Exposes CRUD operations for the **VestingSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VestingSchedules
    * const vestingSchedules = await prisma.vestingSchedule.findMany()
    * ```
    */
  get vestingSchedule(): Prisma.VestingScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYCRecord`: Exposes CRUD operations for the **KYCRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCRecords
    * const kYCRecords = await prisma.kYCRecord.findMany()
    * ```
    */
  get kYCRecord(): Prisma.KYCRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dueDiligenceReport`: Exposes CRUD operations for the **DueDiligenceReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DueDiligenceReports
    * const dueDiligenceReports = await prisma.dueDiligenceReport.findMany()
    * ```
    */
  get dueDiligenceReport(): Prisma.DueDiligenceReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminActivityLog`: Exposes CRUD operations for the **AdminActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActivityLogs
    * const adminActivityLogs = await prisma.adminActivityLog.findMany()
    * ```
    */
  get adminActivityLog(): Prisma.AdminActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentIntent`: Exposes CRUD operations for the **PaymentIntent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentIntents
    * const paymentIntents = await prisma.paymentIntent.findMany()
    * ```
    */
  get paymentIntent(): Prisma.PaymentIntentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptoTx`: Exposes CRUD operations for the **CryptoTx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoTxes
    * const cryptoTxes = await prisma.cryptoTx.findMany()
    * ```
    */
  get cryptoTx(): Prisma.CryptoTxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entityDocument`: Exposes CRUD operations for the **EntityDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityDocuments
    * const entityDocuments = await prisma.entityDocument.findMany()
    * ```
    */
  get entityDocument(): Prisma.EntityDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Organization: 'Organization',
    OrganizationMember: 'OrganizationMember',
    Startup: 'Startup',
    Token: 'Token',
    Simulation: 'Simulation',
    SimulationInvestment: 'SimulationInvestment',
    SimulationLeaderboard: 'SimulationLeaderboard',
    DealMatching: 'DealMatching',
    LearningModule: 'LearningModule',
    UserLearningModule: 'UserLearningModule',
    UserProgress: 'UserProgress',
    Investment: 'Investment',
    VestingSchedule: 'VestingSchedule',
    KYCRecord: 'KYCRecord',
    DueDiligenceReport: 'DueDiligenceReport',
    AdminActivityLog: 'AdminActivityLog',
    PaymentIntent: 'PaymentIntent',
    Wallet: 'Wallet',
    CryptoTx: 'CryptoTx',
    Document: 'Document',
    EntityDocument: 'EntityDocument',
    Notification: 'Notification',
    Comment: 'Comment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "organization" | "organizationMember" | "startup" | "token" | "simulation" | "simulationInvestment" | "simulationLeaderboard" | "dealMatching" | "learningModule" | "userLearningModule" | "userProgress" | "investment" | "vestingSchedule" | "kYCRecord" | "dueDiligenceReport" | "adminActivityLog" | "paymentIntent" | "wallet" | "cryptoTx" | "document" | "entityDocument" | "notification" | "comment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMember: {
        payload: Prisma.$OrganizationMemberPayload<ExtArgs>
        fields: Prisma.OrganizationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          update: {
            args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMember>
          }
          groupBy: {
            args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberCountAggregateOutputType> | number
          }
        }
      }
      Startup: {
        payload: Prisma.$StartupPayload<ExtArgs>
        fields: Prisma.StartupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StartupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StartupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>
          }
          findFirst: {
            args: Prisma.StartupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StartupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>
          }
          findMany: {
            args: Prisma.StartupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>[]
          }
          create: {
            args: Prisma.StartupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>
          }
          createMany: {
            args: Prisma.StartupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StartupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>[]
          }
          delete: {
            args: Prisma.StartupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>
          }
          update: {
            args: Prisma.StartupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>
          }
          deleteMany: {
            args: Prisma.StartupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StartupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StartupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>[]
          }
          upsert: {
            args: Prisma.StartupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StartupPayload>
          }
          aggregate: {
            args: Prisma.StartupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStartup>
          }
          groupBy: {
            args: Prisma.StartupGroupByArgs<ExtArgs>
            result: $Utils.Optional<StartupGroupByOutputType>[]
          }
          count: {
            args: Prisma.StartupCountArgs<ExtArgs>
            result: $Utils.Optional<StartupCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      Simulation: {
        payload: Prisma.$SimulationPayload<ExtArgs>
        fields: Prisma.SimulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          findFirst: {
            args: Prisma.SimulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          findMany: {
            args: Prisma.SimulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          create: {
            args: Prisma.SimulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          createMany: {
            args: Prisma.SimulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          delete: {
            args: Prisma.SimulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          update: {
            args: Prisma.SimulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          deleteMany: {
            args: Prisma.SimulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>[]
          }
          upsert: {
            args: Prisma.SimulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationPayload>
          }
          aggregate: {
            args: Prisma.SimulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulation>
          }
          groupBy: {
            args: Prisma.SimulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationCountAggregateOutputType> | number
          }
        }
      }
      SimulationInvestment: {
        payload: Prisma.$SimulationInvestmentPayload<ExtArgs>
        fields: Prisma.SimulationInvestmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationInvestmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationInvestmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>
          }
          findFirst: {
            args: Prisma.SimulationInvestmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationInvestmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>
          }
          findMany: {
            args: Prisma.SimulationInvestmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>[]
          }
          create: {
            args: Prisma.SimulationInvestmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>
          }
          createMany: {
            args: Prisma.SimulationInvestmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationInvestmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>[]
          }
          delete: {
            args: Prisma.SimulationInvestmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>
          }
          update: {
            args: Prisma.SimulationInvestmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>
          }
          deleteMany: {
            args: Prisma.SimulationInvestmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationInvestmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationInvestmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>[]
          }
          upsert: {
            args: Prisma.SimulationInvestmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationInvestmentPayload>
          }
          aggregate: {
            args: Prisma.SimulationInvestmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationInvestment>
          }
          groupBy: {
            args: Prisma.SimulationInvestmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationInvestmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationInvestmentCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationInvestmentCountAggregateOutputType> | number
          }
        }
      }
      SimulationLeaderboard: {
        payload: Prisma.$SimulationLeaderboardPayload<ExtArgs>
        fields: Prisma.SimulationLeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SimulationLeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SimulationLeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>
          }
          findFirst: {
            args: Prisma.SimulationLeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SimulationLeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>
          }
          findMany: {
            args: Prisma.SimulationLeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>[]
          }
          create: {
            args: Prisma.SimulationLeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>
          }
          createMany: {
            args: Prisma.SimulationLeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SimulationLeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>[]
          }
          delete: {
            args: Prisma.SimulationLeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>
          }
          update: {
            args: Prisma.SimulationLeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.SimulationLeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SimulationLeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SimulationLeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.SimulationLeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SimulationLeaderboardPayload>
          }
          aggregate: {
            args: Prisma.SimulationLeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSimulationLeaderboard>
          }
          groupBy: {
            args: Prisma.SimulationLeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<SimulationLeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.SimulationLeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<SimulationLeaderboardCountAggregateOutputType> | number
          }
        }
      }
      DealMatching: {
        payload: Prisma.$DealMatchingPayload<ExtArgs>
        fields: Prisma.DealMatchingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealMatchingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealMatchingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>
          }
          findFirst: {
            args: Prisma.DealMatchingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealMatchingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>
          }
          findMany: {
            args: Prisma.DealMatchingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>[]
          }
          create: {
            args: Prisma.DealMatchingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>
          }
          createMany: {
            args: Prisma.DealMatchingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealMatchingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>[]
          }
          delete: {
            args: Prisma.DealMatchingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>
          }
          update: {
            args: Prisma.DealMatchingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>
          }
          deleteMany: {
            args: Prisma.DealMatchingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealMatchingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DealMatchingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>[]
          }
          upsert: {
            args: Prisma.DealMatchingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealMatchingPayload>
          }
          aggregate: {
            args: Prisma.DealMatchingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealMatching>
          }
          groupBy: {
            args: Prisma.DealMatchingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealMatchingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealMatchingCountArgs<ExtArgs>
            result: $Utils.Optional<DealMatchingCountAggregateOutputType> | number
          }
        }
      }
      LearningModule: {
        payload: Prisma.$LearningModulePayload<ExtArgs>
        fields: Prisma.LearningModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>
          }
          findFirst: {
            args: Prisma.LearningModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>
          }
          findMany: {
            args: Prisma.LearningModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>[]
          }
          create: {
            args: Prisma.LearningModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>
          }
          createMany: {
            args: Prisma.LearningModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>[]
          }
          delete: {
            args: Prisma.LearningModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>
          }
          update: {
            args: Prisma.LearningModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>
          }
          deleteMany: {
            args: Prisma.LearningModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>[]
          }
          upsert: {
            args: Prisma.LearningModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningModulePayload>
          }
          aggregate: {
            args: Prisma.LearningModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningModule>
          }
          groupBy: {
            args: Prisma.LearningModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningModuleCountArgs<ExtArgs>
            result: $Utils.Optional<LearningModuleCountAggregateOutputType> | number
          }
        }
      }
      UserLearningModule: {
        payload: Prisma.$UserLearningModulePayload<ExtArgs>
        fields: Prisma.UserLearningModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLearningModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLearningModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>
          }
          findFirst: {
            args: Prisma.UserLearningModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLearningModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>
          }
          findMany: {
            args: Prisma.UserLearningModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>[]
          }
          create: {
            args: Prisma.UserLearningModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>
          }
          createMany: {
            args: Prisma.UserLearningModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLearningModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>[]
          }
          delete: {
            args: Prisma.UserLearningModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>
          }
          update: {
            args: Prisma.UserLearningModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>
          }
          deleteMany: {
            args: Prisma.UserLearningModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLearningModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLearningModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>[]
          }
          upsert: {
            args: Prisma.UserLearningModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningModulePayload>
          }
          aggregate: {
            args: Prisma.UserLearningModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLearningModule>
          }
          groupBy: {
            args: Prisma.UserLearningModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLearningModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLearningModuleCountArgs<ExtArgs>
            result: $Utils.Optional<UserLearningModuleCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      Investment: {
        payload: Prisma.$InvestmentPayload<ExtArgs>
        fields: Prisma.InvestmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>
          }
          findFirst: {
            args: Prisma.InvestmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>
          }
          findMany: {
            args: Prisma.InvestmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>[]
          }
          create: {
            args: Prisma.InvestmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>
          }
          createMany: {
            args: Prisma.InvestmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>[]
          }
          delete: {
            args: Prisma.InvestmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>
          }
          update: {
            args: Prisma.InvestmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>
          }
          deleteMany: {
            args: Prisma.InvestmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>[]
          }
          upsert: {
            args: Prisma.InvestmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestmentPayload>
          }
          aggregate: {
            args: Prisma.InvestmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestment>
          }
          groupBy: {
            args: Prisma.InvestmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestmentCountArgs<ExtArgs>
            result: $Utils.Optional<InvestmentCountAggregateOutputType> | number
          }
        }
      }
      VestingSchedule: {
        payload: Prisma.$VestingSchedulePayload<ExtArgs>
        fields: Prisma.VestingScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VestingScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VestingScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>
          }
          findFirst: {
            args: Prisma.VestingScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VestingScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>
          }
          findMany: {
            args: Prisma.VestingScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>[]
          }
          create: {
            args: Prisma.VestingScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>
          }
          createMany: {
            args: Prisma.VestingScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VestingScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>[]
          }
          delete: {
            args: Prisma.VestingScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>
          }
          update: {
            args: Prisma.VestingScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>
          }
          deleteMany: {
            args: Prisma.VestingScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VestingScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VestingScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>[]
          }
          upsert: {
            args: Prisma.VestingScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VestingSchedulePayload>
          }
          aggregate: {
            args: Prisma.VestingScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVestingSchedule>
          }
          groupBy: {
            args: Prisma.VestingScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VestingScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VestingScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<VestingScheduleCountAggregateOutputType> | number
          }
        }
      }
      KYCRecord: {
        payload: Prisma.$KYCRecordPayload<ExtArgs>
        fields: Prisma.KYCRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>
          }
          findFirst: {
            args: Prisma.KYCRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>
          }
          findMany: {
            args: Prisma.KYCRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>[]
          }
          create: {
            args: Prisma.KYCRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>
          }
          createMany: {
            args: Prisma.KYCRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>[]
          }
          delete: {
            args: Prisma.KYCRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>
          }
          update: {
            args: Prisma.KYCRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>
          }
          deleteMany: {
            args: Prisma.KYCRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>[]
          }
          upsert: {
            args: Prisma.KYCRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCRecordPayload>
          }
          aggregate: {
            args: Prisma.KYCRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYCRecord>
          }
          groupBy: {
            args: Prisma.KYCRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCRecordCountArgs<ExtArgs>
            result: $Utils.Optional<KYCRecordCountAggregateOutputType> | number
          }
        }
      }
      DueDiligenceReport: {
        payload: Prisma.$DueDiligenceReportPayload<ExtArgs>
        fields: Prisma.DueDiligenceReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DueDiligenceReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DueDiligenceReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>
          }
          findFirst: {
            args: Prisma.DueDiligenceReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DueDiligenceReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>
          }
          findMany: {
            args: Prisma.DueDiligenceReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>[]
          }
          create: {
            args: Prisma.DueDiligenceReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>
          }
          createMany: {
            args: Prisma.DueDiligenceReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DueDiligenceReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>[]
          }
          delete: {
            args: Prisma.DueDiligenceReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>
          }
          update: {
            args: Prisma.DueDiligenceReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>
          }
          deleteMany: {
            args: Prisma.DueDiligenceReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DueDiligenceReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DueDiligenceReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>[]
          }
          upsert: {
            args: Prisma.DueDiligenceReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DueDiligenceReportPayload>
          }
          aggregate: {
            args: Prisma.DueDiligenceReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDueDiligenceReport>
          }
          groupBy: {
            args: Prisma.DueDiligenceReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<DueDiligenceReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.DueDiligenceReportCountArgs<ExtArgs>
            result: $Utils.Optional<DueDiligenceReportCountAggregateOutputType> | number
          }
        }
      }
      AdminActivityLog: {
        payload: Prisma.$AdminActivityLogPayload<ExtArgs>
        fields: Prisma.AdminActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          findFirst: {
            args: Prisma.AdminActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          findMany: {
            args: Prisma.AdminActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>[]
          }
          create: {
            args: Prisma.AdminActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          createMany: {
            args: Prisma.AdminActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>[]
          }
          delete: {
            args: Prisma.AdminActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          update: {
            args: Prisma.AdminActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          aggregate: {
            args: Prisma.AdminActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminActivityLog>
          }
          groupBy: {
            args: Prisma.AdminActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminActivityLogCountAggregateOutputType> | number
          }
        }
      }
      PaymentIntent: {
        payload: Prisma.$PaymentIntentPayload<ExtArgs>
        fields: Prisma.PaymentIntentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentIntentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentIntentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          findFirst: {
            args: Prisma.PaymentIntentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentIntentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          findMany: {
            args: Prisma.PaymentIntentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
          }
          create: {
            args: Prisma.PaymentIntentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          createMany: {
            args: Prisma.PaymentIntentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentIntentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
          }
          delete: {
            args: Prisma.PaymentIntentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          update: {
            args: Prisma.PaymentIntentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentIntentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentIntentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentIntentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentIntentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentIntentPayload>
          }
          aggregate: {
            args: Prisma.PaymentIntentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentIntent>
          }
          groupBy: {
            args: Prisma.PaymentIntentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentIntentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentIntentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentIntentCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      CryptoTx: {
        payload: Prisma.$CryptoTxPayload<ExtArgs>
        fields: Prisma.CryptoTxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoTxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoTxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>
          }
          findFirst: {
            args: Prisma.CryptoTxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoTxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>
          }
          findMany: {
            args: Prisma.CryptoTxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>[]
          }
          create: {
            args: Prisma.CryptoTxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>
          }
          createMany: {
            args: Prisma.CryptoTxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoTxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>[]
          }
          delete: {
            args: Prisma.CryptoTxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>
          }
          update: {
            args: Prisma.CryptoTxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>
          }
          deleteMany: {
            args: Prisma.CryptoTxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoTxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CryptoTxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>[]
          }
          upsert: {
            args: Prisma.CryptoTxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoTxPayload>
          }
          aggregate: {
            args: Prisma.CryptoTxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoTx>
          }
          groupBy: {
            args: Prisma.CryptoTxGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoTxGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoTxCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoTxCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      EntityDocument: {
        payload: Prisma.$EntityDocumentPayload<ExtArgs>
        fields: Prisma.EntityDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>
          }
          findFirst: {
            args: Prisma.EntityDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>
          }
          findMany: {
            args: Prisma.EntityDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>[]
          }
          create: {
            args: Prisma.EntityDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>
          }
          createMany: {
            args: Prisma.EntityDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntityDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>[]
          }
          delete: {
            args: Prisma.EntityDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>
          }
          update: {
            args: Prisma.EntityDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>
          }
          deleteMany: {
            args: Prisma.EntityDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntityDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EntityDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>[]
          }
          upsert: {
            args: Prisma.EntityDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityDocumentPayload>
          }
          aggregate: {
            args: Prisma.EntityDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntityDocument>
          }
          groupBy: {
            args: Prisma.EntityDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntityDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<EntityDocumentCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    organization?: OrganizationOmit
    organizationMember?: OrganizationMemberOmit
    startup?: StartupOmit
    token?: TokenOmit
    simulation?: SimulationOmit
    simulationInvestment?: SimulationInvestmentOmit
    simulationLeaderboard?: SimulationLeaderboardOmit
    dealMatching?: DealMatchingOmit
    learningModule?: LearningModuleOmit
    userLearningModule?: UserLearningModuleOmit
    userProgress?: UserProgressOmit
    investment?: InvestmentOmit
    vestingSchedule?: VestingScheduleOmit
    kYCRecord?: KYCRecordOmit
    dueDiligenceReport?: DueDiligenceReportOmit
    adminActivityLog?: AdminActivityLogOmit
    paymentIntent?: PaymentIntentOmit
    wallet?: WalletOmit
    cryptoTx?: CryptoTxOmit
    document?: DocumentOmit
    entityDocument?: EntityDocumentOmit
    notification?: NotificationOmit
    comment?: CommentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    organizations: number
    investments: number
    simulationInvestments: number
    notifications: number
    startups: number
    tokens: number
    adminLogs: number
    paymentIntents: number
    wallets: number
    comments: number
    simulations: number
    ownedSimulations: number
    dealMatchings: number
    userProgress: number
    learningModules: number
    leaderboardEntries: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    organizations?: boolean | UserCountOutputTypeCountOrganizationsArgs
    investments?: boolean | UserCountOutputTypeCountInvestmentsArgs
    simulationInvestments?: boolean | UserCountOutputTypeCountSimulationInvestmentsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    startups?: boolean | UserCountOutputTypeCountStartupsArgs
    tokens?: boolean | UserCountOutputTypeCountTokensArgs
    adminLogs?: boolean | UserCountOutputTypeCountAdminLogsArgs
    paymentIntents?: boolean | UserCountOutputTypeCountPaymentIntentsArgs
    wallets?: boolean | UserCountOutputTypeCountWalletsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    simulations?: boolean | UserCountOutputTypeCountSimulationsArgs
    ownedSimulations?: boolean | UserCountOutputTypeCountOwnedSimulationsArgs
    dealMatchings?: boolean | UserCountOutputTypeCountDealMatchingsArgs
    userProgress?: boolean | UserCountOutputTypeCountUserProgressArgs
    learningModules?: boolean | UserCountOutputTypeCountLearningModulesArgs
    leaderboardEntries?: boolean | UserCountOutputTypeCountLeaderboardEntriesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSimulationInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationInvestmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStartupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StartupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentIntentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentIntentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDealMatchingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealMatchingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLearningModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLearningModuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationLeaderboardWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    startups: number
    tokens: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    startups?: boolean | OrganizationCountOutputTypeCountStartupsArgs
    tokens?: boolean | OrganizationCountOutputTypeCountTokensArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountStartupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StartupWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }


  /**
   * Count Type StartupCountOutputType
   */

  export type StartupCountOutputType = {
    investments: number
    simulationInvestments: number
    dueDiligenceReports: number
    documents: number
    comments: number
    dealMatchings: number
  }

  export type StartupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investments?: boolean | StartupCountOutputTypeCountInvestmentsArgs
    simulationInvestments?: boolean | StartupCountOutputTypeCountSimulationInvestmentsArgs
    dueDiligenceReports?: boolean | StartupCountOutputTypeCountDueDiligenceReportsArgs
    documents?: boolean | StartupCountOutputTypeCountDocumentsArgs
    comments?: boolean | StartupCountOutputTypeCountCommentsArgs
    dealMatchings?: boolean | StartupCountOutputTypeCountDealMatchingsArgs
  }

  // Custom InputTypes
  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StartupCountOutputType
     */
    select?: StartupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeCountInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestmentWhereInput
  }

  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeCountSimulationInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationInvestmentWhereInput
  }

  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeCountDueDiligenceReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceReportWhereInput
  }

  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * StartupCountOutputType without action
   */
  export type StartupCountOutputTypeCountDealMatchingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealMatchingWhereInput
  }


  /**
   * Count Type TokenCountOutputType
   */

  export type TokenCountOutputType = {
    investments: number
    simulationInvestments: number
    dueDiligenceReports: number
    documents: number
    comments: number
    dealMatchings: number
  }

  export type TokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investments?: boolean | TokenCountOutputTypeCountInvestmentsArgs
    simulationInvestments?: boolean | TokenCountOutputTypeCountSimulationInvestmentsArgs
    dueDiligenceReports?: boolean | TokenCountOutputTypeCountDueDiligenceReportsArgs
    documents?: boolean | TokenCountOutputTypeCountDocumentsArgs
    comments?: boolean | TokenCountOutputTypeCountCommentsArgs
    dealMatchings?: boolean | TokenCountOutputTypeCountDealMatchingsArgs
  }

  // Custom InputTypes
  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenCountOutputType
     */
    select?: TokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestmentWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountSimulationInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationInvestmentWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDueDiligenceReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceReportWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityDocumentWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountDealMatchingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealMatchingWhereInput
  }


  /**
   * Count Type SimulationCountOutputType
   */

  export type SimulationCountOutputType = {
    participants: number
    investments: number
    leaderboard: number
  }

  export type SimulationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | SimulationCountOutputTypeCountParticipantsArgs
    investments?: boolean | SimulationCountOutputTypeCountInvestmentsArgs
    leaderboard?: boolean | SimulationCountOutputTypeCountLeaderboardArgs
  }

  // Custom InputTypes
  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationCountOutputType
     */
    select?: SimulationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationInvestmentWhereInput
  }

  /**
   * SimulationCountOutputType without action
   */
  export type SimulationCountOutputTypeCountLeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationLeaderboardWhereInput
  }


  /**
   * Count Type LearningModuleCountOutputType
   */

  export type LearningModuleCountOutputType = {
    userLearningModules: number
  }

  export type LearningModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLearningModules?: boolean | LearningModuleCountOutputTypeCountUserLearningModulesArgs
  }

  // Custom InputTypes
  /**
   * LearningModuleCountOutputType without action
   */
  export type LearningModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModuleCountOutputType
     */
    select?: LearningModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningModuleCountOutputType without action
   */
  export type LearningModuleCountOutputTypeCountUserLearningModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLearningModuleWhereInput
  }


  /**
   * Count Type InvestmentCountOutputType
   */

  export type InvestmentCountOutputType = {
    vesting: number
  }

  export type InvestmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vesting?: boolean | InvestmentCountOutputTypeCountVestingArgs
  }

  // Custom InputTypes
  /**
   * InvestmentCountOutputType without action
   */
  export type InvestmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestmentCountOutputType
     */
    select?: InvestmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestmentCountOutputType without action
   */
  export type InvestmentCountOutputTypeCountVestingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VestingScheduleWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    txs: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    txs?: boolean | WalletCountOutputTypeCountTxsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTxsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoTxWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    entities: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | DocumentCountOutputTypeCountEntitiesArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityDocumentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalSimulationScore: number | null
    completedSimulations: number | null
    simulationLevel: number | null
  }

  export type UserSumAggregateOutputType = {
    totalSimulationScore: number | null
    completedSimulations: number | null
    simulationLevel: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    role: $Enums.UserRole | null
    founderStatus: $Enums.FounderStatus | null
    accreditationStatus: $Enums.AccreditationStatus | null
    dealAccessLevel: $Enums.DealAccessLevel | null
    totalSimulationScore: number | null
    completedSimulations: number | null
    simulationLevel: number | null
    bio: string | null
    profilePicture: string | null
    linkedinUrl: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    role: $Enums.UserRole | null
    founderStatus: $Enums.FounderStatus | null
    accreditationStatus: $Enums.AccreditationStatus | null
    dealAccessLevel: $Enums.DealAccessLevel | null
    totalSimulationScore: number | null
    completedSimulations: number | null
    simulationLevel: number | null
    bio: string | null
    profilePicture: string | null
    linkedinUrl: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    role: number
    founderStatus: number
    accreditationStatus: number
    dealAccessLevel: number
    totalSimulationScore: number
    completedSimulations: number
    simulationLevel: number
    bio: number
    profilePicture: number
    linkedinUrl: number
    location: number
    investmentPreferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalSimulationScore?: true
    completedSimulations?: true
    simulationLevel?: true
  }

  export type UserSumAggregateInputType = {
    totalSimulationScore?: true
    completedSimulations?: true
    simulationLevel?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    role?: true
    founderStatus?: true
    accreditationStatus?: true
    dealAccessLevel?: true
    totalSimulationScore?: true
    completedSimulations?: true
    simulationLevel?: true
    bio?: true
    profilePicture?: true
    linkedinUrl?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    role?: true
    founderStatus?: true
    accreditationStatus?: true
    dealAccessLevel?: true
    totalSimulationScore?: true
    completedSimulations?: true
    simulationLevel?: true
    bio?: true
    profilePicture?: true
    linkedinUrl?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    role?: true
    founderStatus?: true
    accreditationStatus?: true
    dealAccessLevel?: true
    totalSimulationScore?: true
    completedSimulations?: true
    simulationLevel?: true
    bio?: true
    profilePicture?: true
    linkedinUrl?: true
    location?: true
    investmentPreferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    role: $Enums.UserRole
    founderStatus: $Enums.FounderStatus | null
    accreditationStatus: $Enums.AccreditationStatus
    dealAccessLevel: $Enums.DealAccessLevel
    totalSimulationScore: number
    completedSimulations: number
    simulationLevel: number
    bio: string | null
    profilePicture: string | null
    linkedinUrl: string | null
    location: string | null
    investmentPreferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    role?: boolean
    founderStatus?: boolean
    accreditationStatus?: boolean
    dealAccessLevel?: boolean
    totalSimulationScore?: boolean
    completedSimulations?: boolean
    simulationLevel?: boolean
    bio?: boolean
    profilePicture?: boolean
    linkedinUrl?: boolean
    location?: boolean
    investmentPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    kycRecord?: boolean | User$kycRecordArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    investments?: boolean | User$investmentsArgs<ExtArgs>
    simulationInvestments?: boolean | User$simulationInvestmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    startups?: boolean | User$startupsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    adminLogs?: boolean | User$adminLogsArgs<ExtArgs>
    paymentIntents?: boolean | User$paymentIntentsArgs<ExtArgs>
    wallets?: boolean | User$walletsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    simulations?: boolean | User$simulationsArgs<ExtArgs>
    ownedSimulations?: boolean | User$ownedSimulationsArgs<ExtArgs>
    dealMatchings?: boolean | User$dealMatchingsArgs<ExtArgs>
    userProgress?: boolean | User$userProgressArgs<ExtArgs>
    learningModules?: boolean | User$learningModulesArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    role?: boolean
    founderStatus?: boolean
    accreditationStatus?: boolean
    dealAccessLevel?: boolean
    totalSimulationScore?: boolean
    completedSimulations?: boolean
    simulationLevel?: boolean
    bio?: boolean
    profilePicture?: boolean
    linkedinUrl?: boolean
    location?: boolean
    investmentPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    role?: boolean
    founderStatus?: boolean
    accreditationStatus?: boolean
    dealAccessLevel?: boolean
    totalSimulationScore?: boolean
    completedSimulations?: boolean
    simulationLevel?: boolean
    bio?: boolean
    profilePicture?: boolean
    linkedinUrl?: boolean
    location?: boolean
    investmentPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    role?: boolean
    founderStatus?: boolean
    accreditationStatus?: boolean
    dealAccessLevel?: boolean
    totalSimulationScore?: boolean
    completedSimulations?: boolean
    simulationLevel?: boolean
    bio?: boolean
    profilePicture?: boolean
    linkedinUrl?: boolean
    location?: boolean
    investmentPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "role" | "founderStatus" | "accreditationStatus" | "dealAccessLevel" | "totalSimulationScore" | "completedSimulations" | "simulationLevel" | "bio" | "profilePicture" | "linkedinUrl" | "location" | "investmentPreferences" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    kycRecord?: boolean | User$kycRecordArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    investments?: boolean | User$investmentsArgs<ExtArgs>
    simulationInvestments?: boolean | User$simulationInvestmentsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    startups?: boolean | User$startupsArgs<ExtArgs>
    tokens?: boolean | User$tokensArgs<ExtArgs>
    adminLogs?: boolean | User$adminLogsArgs<ExtArgs>
    paymentIntents?: boolean | User$paymentIntentsArgs<ExtArgs>
    wallets?: boolean | User$walletsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    simulations?: boolean | User$simulationsArgs<ExtArgs>
    ownedSimulations?: boolean | User$ownedSimulationsArgs<ExtArgs>
    dealMatchings?: boolean | User$dealMatchingsArgs<ExtArgs>
    userProgress?: boolean | User$userProgressArgs<ExtArgs>
    learningModules?: boolean | User$learningModulesArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      kycRecord: Prisma.$KYCRecordPayload<ExtArgs> | null
      organizations: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      investments: Prisma.$InvestmentPayload<ExtArgs>[]
      simulationInvestments: Prisma.$SimulationInvestmentPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      startups: Prisma.$StartupPayload<ExtArgs>[]
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      adminLogs: Prisma.$AdminActivityLogPayload<ExtArgs>[]
      paymentIntents: Prisma.$PaymentIntentPayload<ExtArgs>[]
      wallets: Prisma.$WalletPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      simulations: Prisma.$SimulationPayload<ExtArgs>[]
      ownedSimulations: Prisma.$SimulationPayload<ExtArgs>[]
      dealMatchings: Prisma.$DealMatchingPayload<ExtArgs>[]
      userProgress: Prisma.$UserProgressPayload<ExtArgs>[]
      learningModules: Prisma.$UserLearningModulePayload<ExtArgs>[]
      leaderboardEntries: Prisma.$SimulationLeaderboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      role: $Enums.UserRole
      founderStatus: $Enums.FounderStatus | null
      accreditationStatus: $Enums.AccreditationStatus
      dealAccessLevel: $Enums.DealAccessLevel
      totalSimulationScore: number
      completedSimulations: number
      simulationLevel: number
      bio: string | null
      profilePicture: string | null
      linkedinUrl: string | null
      location: string | null
      investmentPreferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kycRecord<T extends User$kycRecordArgs<ExtArgs> = {}>(args?: Subset<T, User$kycRecordArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organizations<T extends User$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investments<T extends User$investmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$investmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simulationInvestments<T extends User$simulationInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$simulationInvestmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    startups<T extends User$startupsArgs<ExtArgs> = {}>(args?: Subset<T, User$startupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens<T extends User$tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminLogs<T extends User$adminLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentIntents<T extends User$paymentIntentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentIntentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallets<T extends User$walletsArgs<ExtArgs> = {}>(args?: Subset<T, User$walletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simulations<T extends User$simulationsArgs<ExtArgs> = {}>(args?: Subset<T, User$simulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedSimulations<T extends User$ownedSimulationsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedSimulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dealMatchings<T extends User$dealMatchingsArgs<ExtArgs> = {}>(args?: Subset<T, User$dealMatchingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProgress<T extends User$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    learningModules<T extends User$learningModulesArgs<ExtArgs> = {}>(args?: Subset<T, User$learningModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboardEntries<T extends User$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly founderStatus: FieldRef<"User", 'FounderStatus'>
    readonly accreditationStatus: FieldRef<"User", 'AccreditationStatus'>
    readonly dealAccessLevel: FieldRef<"User", 'DealAccessLevel'>
    readonly totalSimulationScore: FieldRef<"User", 'Int'>
    readonly completedSimulations: FieldRef<"User", 'Int'>
    readonly simulationLevel: FieldRef<"User", 'Int'>
    readonly bio: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly linkedinUrl: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly investmentPreferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.kycRecord
   */
  export type User$kycRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    where?: KYCRecordWhereInput
  }

  /**
   * User.organizations
   */
  export type User$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * User.investments
   */
  export type User$investmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    where?: InvestmentWhereInput
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    cursor?: InvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestmentScalarFieldEnum | InvestmentScalarFieldEnum[]
  }

  /**
   * User.simulationInvestments
   */
  export type User$simulationInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    where?: SimulationInvestmentWhereInput
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    cursor?: SimulationInvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.startups
   */
  export type User$startupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
    orderBy?: StartupOrderByWithRelationInput | StartupOrderByWithRelationInput[]
    cursor?: StartupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StartupScalarFieldEnum | StartupScalarFieldEnum[]
  }

  /**
   * User.tokens
   */
  export type User$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.adminLogs
   */
  export type User$adminLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    where?: AdminActivityLogWhereInput
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    cursor?: AdminActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * User.paymentIntents
   */
  export type User$paymentIntentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    where?: PaymentIntentWhereInput
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    cursor?: PaymentIntentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * User.wallets
   */
  export type User$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    cursor?: WalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.simulations
   */
  export type User$simulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    where?: SimulationWhereInput
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    cursor?: SimulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * User.ownedSimulations
   */
  export type User$ownedSimulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    where?: SimulationWhereInput
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    cursor?: SimulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * User.dealMatchings
   */
  export type User$dealMatchingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    where?: DealMatchingWhereInput
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    cursor?: DealMatchingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealMatchingScalarFieldEnum | DealMatchingScalarFieldEnum[]
  }

  /**
   * User.userProgress
   */
  export type User$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * User.learningModules
   */
  export type User$learningModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    where?: UserLearningModuleWhereInput
    orderBy?: UserLearningModuleOrderByWithRelationInput | UserLearningModuleOrderByWithRelationInput[]
    cursor?: UserLearningModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLearningModuleScalarFieldEnum | UserLearningModuleScalarFieldEnum[]
  }

  /**
   * User.leaderboardEntries
   */
  export type User$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    where?: SimulationLeaderboardWhereInput
    orderBy?: SimulationLeaderboardOrderByWithRelationInput | SimulationLeaderboardOrderByWithRelationInput[]
    cursor?: SimulationLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationLeaderboardScalarFieldEnum | SimulationLeaderboardScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    ipAddress: string
    userAgent: string
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      ipAddress: string
      userAgent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    idToken: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    idToken?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    idToken: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    idToken?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "idToken" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      idToken: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    website: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    website: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    website: number
    logoUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    website: string | null
    logoUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    startups?: boolean | Organization$startupsArgs<ExtArgs>
    tokens?: boolean | Organization$tokensArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "website" | "logoUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    startups?: boolean | Organization$startupsArgs<ExtArgs>
    tokens?: boolean | Organization$tokensArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      startups: Prisma.$StartupPayload<ExtArgs>[]
      tokens: Prisma.$TokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      website: string | null
      logoUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    startups<T extends Organization$startupsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$startupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens<T extends Organization$tokensArgs<ExtArgs> = {}>(args?: Subset<T, Organization$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly description: FieldRef<"Organization", 'String'>
    readonly website: FieldRef<"Organization", 'String'>
    readonly logoUrl: FieldRef<"Organization", 'String'>
    readonly isActive: FieldRef<"Organization", 'Boolean'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * Organization.startups
   */
  export type Organization$startupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
    orderBy?: StartupOrderByWithRelationInput | StartupOrderByWithRelationInput[]
    cursor?: StartupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StartupScalarFieldEnum | StartupScalarFieldEnum[]
  }

  /**
   * Organization.tokens
   */
  export type Organization$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMember
   */

  export type AggregateOrganizationMember = {
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  export type OrganizationMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type OrganizationMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    organizationId: string | null
    role: string | null
    joinedAt: Date | null
  }

  export type OrganizationMemberCountAggregateOutputType = {
    id: number
    userId: number
    organizationId: number
    role: number
    joinedAt: number
    _all: number
  }


  export type OrganizationMemberMinAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
  }

  export type OrganizationMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
  }

  export type OrganizationMemberCountAggregateInputType = {
    id?: true
    userId?: true
    organizationId?: true
    role?: true
    joinedAt?: true
    _all?: true
  }

  export type OrganizationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMember to aggregate.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMembers
    **/
    _count?: true | OrganizationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type GetOrganizationMemberAggregateType<T extends OrganizationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMember[P]>
      : GetScalarType<T[P], AggregateOrganizationMember[P]>
  }




  export type OrganizationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithAggregationInput | OrganizationMemberOrderByWithAggregationInput[]
    by: OrganizationMemberScalarFieldEnum[] | OrganizationMemberScalarFieldEnum
    having?: OrganizationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMemberCountAggregateInputType | true
    _min?: OrganizationMemberMinAggregateInputType
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type OrganizationMemberGroupByOutputType = {
    id: string
    userId: string
    organizationId: string
    role: string
    joinedAt: Date
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  type GetOrganizationMemberGroupByPayload<T extends OrganizationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    organizationId?: boolean
    role?: boolean
    joinedAt?: boolean
  }

  export type OrganizationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "organizationId" | "role" | "joinedAt", ExtArgs["result"]["organizationMember"]>
  export type OrganizationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrganizationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      organizationId: string
      role: string
      joinedAt: Date
    }, ExtArgs["result"]["organizationMember"]>
    composites: {}
  }

  type OrganizationMemberGetPayload<S extends boolean | null | undefined | OrganizationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMemberPayload, S>

  type OrganizationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMemberCountAggregateInputType | true
    }

  export interface OrganizationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMember'], meta: { name: 'OrganizationMember' } }
    /**
     * Find zero or one OrganizationMember that matches the filter.
     * @param {OrganizationMemberFindUniqueArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMemberFindUniqueArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMemberFindFirstArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany()
     * 
     * // Get first 10 OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMemberFindManyArgs>(args?: SelectSubset<T, OrganizationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMember.
     * @param {OrganizationMemberCreateArgs} args - Arguments to create a OrganizationMember.
     * @example
     * // Create one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.create({
     *   data: {
     *     // ... data to create a OrganizationMember
     *   }
     * })
     * 
     */
    create<T extends OrganizationMemberCreateArgs>(args: SelectSubset<T, OrganizationMemberCreateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMembers.
     * @param {OrganizationMemberCreateManyArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMemberCreateManyArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMembers and returns the data saved in the database.
     * @param {OrganizationMemberCreateManyAndReturnArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMember.
     * @param {OrganizationMemberDeleteArgs} args - Arguments to delete one OrganizationMember.
     * @example
     * // Delete one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMemberDeleteArgs>(args: SelectSubset<T, OrganizationMemberDeleteArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMember.
     * @param {OrganizationMemberUpdateArgs} args - Arguments to update one OrganizationMember.
     * @example
     * // Update one OrganizationMember
     * const organizationMember = await prisma.organizationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMemberUpdateArgs>(args: SelectSubset<T, OrganizationMemberUpdateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMembers.
     * @param {OrganizationMemberDeleteManyArgs} args - Arguments to filter OrganizationMembers to delete.
     * @example
     * // Delete a few OrganizationMembers
     * const { count } = await prisma.organizationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganizationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMemberUpdateManyArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers and returns the data updated in the database.
     * @param {OrganizationMemberUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMembers.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMember.
     * @param {OrganizationMemberUpsertArgs} args - Arguments to update or create a OrganizationMember.
     * @example
     * // Update or create a OrganizationMember
     * const organizationMember = await prisma.organizationMember.upsert({
     *   create: {
     *     // ... data to create a OrganizationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMemberUpsertArgs>(args: SelectSubset<T, OrganizationMemberUpsertArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberCountArgs} args - Arguments to filter OrganizationMembers to count.
     * @example
     * // Count the number of OrganizationMembers
     * const count = await prisma.organizationMember.count({
     *   where: {
     *     // ... the filter for the OrganizationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMemberCountArgs>(
      args?: Subset<T, OrganizationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMemberAggregateArgs>(args: Subset<T, OrganizationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMemberAggregateType<T>>

    /**
     * Group by OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMember model
   */
  readonly fields: OrganizationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMember model
   */
  interface OrganizationMemberFieldRefs {
    readonly id: FieldRef<"OrganizationMember", 'String'>
    readonly userId: FieldRef<"OrganizationMember", 'String'>
    readonly organizationId: FieldRef<"OrganizationMember", 'String'>
    readonly role: FieldRef<"OrganizationMember", 'String'>
    readonly joinedAt: FieldRef<"OrganizationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMember findUnique
   */
  export type OrganizationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findUniqueOrThrow
   */
  export type OrganizationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findFirst
   */
  export type OrganizationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findFirstOrThrow
   */
  export type OrganizationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findMany
   */
  export type OrganizationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembers to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember create
   */
  export type OrganizationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMember.
     */
    data: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
  }

  /**
   * OrganizationMember createMany
   */
  export type OrganizationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMember createManyAndReturn
   */
  export type OrganizationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember update
   */
  export type OrganizationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMember.
     */
    data: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMember to update.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember updateMany
   */
  export type OrganizationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
  }

  /**
   * OrganizationMember updateManyAndReturn
   */
  export type OrganizationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember upsert
   */
  export type OrganizationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMember to update in case it exists.
     */
    where: OrganizationMemberWhereUniqueInput
    /**
     * In case the OrganizationMember found by the `where` argument doesn't exist, create a new OrganizationMember with this data.
     */
    create: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
    /**
     * In case the OrganizationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
  }

  /**
   * OrganizationMember delete
   */
  export type OrganizationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMember to delete.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember deleteMany
   */
  export type OrganizationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembers to delete
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMember without action
   */
  export type OrganizationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
  }


  /**
   * Model Startup
   */

  export type AggregateStartup = {
    _count: StartupCountAggregateOutputType | null
    _avg: StartupAvgAggregateOutputType | null
    _sum: StartupSumAggregateOutputType | null
    _min: StartupMinAggregateOutputType | null
    _max: StartupMaxAggregateOutputType | null
  }

  export type StartupAvgAggregateOutputType = {
    fundingGoal: Decimal | null
    amountRaised: Decimal | null
    valuation: Decimal | null
  }

  export type StartupSumAggregateOutputType = {
    fundingGoal: Decimal | null
    amountRaised: Decimal | null
    valuation: Decimal | null
  }

  export type StartupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    industry: string | null
    stage: $Enums.FundingStage | null
    website: string | null
    pitchDeck: string | null
    fundingGoal: Decimal | null
    amountRaised: Decimal | null
    valuation: Decimal | null
    isApproved: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    founderId: string | null
    organizationId: string | null
  }

  export type StartupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    industry: string | null
    stage: $Enums.FundingStage | null
    website: string | null
    pitchDeck: string | null
    fundingGoal: Decimal | null
    amountRaised: Decimal | null
    valuation: Decimal | null
    isApproved: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    founderId: string | null
    organizationId: string | null
  }

  export type StartupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    industry: number
    stage: number
    website: number
    pitchDeck: number
    fundingGoal: number
    amountRaised: number
    valuation: number
    isApproved: number
    isActive: number
    aiGeneratedMetrics: number
    simulationData: number
    createdAt: number
    updatedAt: number
    founderId: number
    organizationId: number
    _all: number
  }


  export type StartupAvgAggregateInputType = {
    fundingGoal?: true
    amountRaised?: true
    valuation?: true
  }

  export type StartupSumAggregateInputType = {
    fundingGoal?: true
    amountRaised?: true
    valuation?: true
  }

  export type StartupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    industry?: true
    stage?: true
    website?: true
    pitchDeck?: true
    fundingGoal?: true
    amountRaised?: true
    valuation?: true
    isApproved?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    founderId?: true
    organizationId?: true
  }

  export type StartupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    industry?: true
    stage?: true
    website?: true
    pitchDeck?: true
    fundingGoal?: true
    amountRaised?: true
    valuation?: true
    isApproved?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    founderId?: true
    organizationId?: true
  }

  export type StartupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    industry?: true
    stage?: true
    website?: true
    pitchDeck?: true
    fundingGoal?: true
    amountRaised?: true
    valuation?: true
    isApproved?: true
    isActive?: true
    aiGeneratedMetrics?: true
    simulationData?: true
    createdAt?: true
    updatedAt?: true
    founderId?: true
    organizationId?: true
    _all?: true
  }

  export type StartupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Startup to aggregate.
     */
    where?: StartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Startups to fetch.
     */
    orderBy?: StartupOrderByWithRelationInput | StartupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Startups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Startups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Startups
    **/
    _count?: true | StartupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StartupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StartupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StartupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StartupMaxAggregateInputType
  }

  export type GetStartupAggregateType<T extends StartupAggregateArgs> = {
        [P in keyof T & keyof AggregateStartup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStartup[P]>
      : GetScalarType<T[P], AggregateStartup[P]>
  }




  export type StartupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StartupWhereInput
    orderBy?: StartupOrderByWithAggregationInput | StartupOrderByWithAggregationInput[]
    by: StartupScalarFieldEnum[] | StartupScalarFieldEnum
    having?: StartupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StartupCountAggregateInputType | true
    _avg?: StartupAvgAggregateInputType
    _sum?: StartupSumAggregateInputType
    _min?: StartupMinAggregateInputType
    _max?: StartupMaxAggregateInputType
  }

  export type StartupGroupByOutputType = {
    id: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website: string | null
    pitchDeck: string | null
    fundingGoal: Decimal
    amountRaised: Decimal
    valuation: Decimal
    isApproved: boolean
    isActive: boolean
    aiGeneratedMetrics: JsonValue | null
    simulationData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    founderId: string
    organizationId: string | null
    _count: StartupCountAggregateOutputType | null
    _avg: StartupAvgAggregateOutputType | null
    _sum: StartupSumAggregateOutputType | null
    _min: StartupMinAggregateOutputType | null
    _max: StartupMaxAggregateOutputType | null
  }

  type GetStartupGroupByPayload<T extends StartupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StartupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StartupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StartupGroupByOutputType[P]>
            : GetScalarType<T[P], StartupGroupByOutputType[P]>
        }
      >
    >


  export type StartupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    stage?: boolean
    website?: boolean
    pitchDeck?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    valuation?: boolean
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: boolean
    simulationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founderId?: boolean
    organizationId?: boolean
    founder?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Startup$organizationArgs<ExtArgs>
    investments?: boolean | Startup$investmentsArgs<ExtArgs>
    simulationInvestments?: boolean | Startup$simulationInvestmentsArgs<ExtArgs>
    dueDiligenceReports?: boolean | Startup$dueDiligenceReportsArgs<ExtArgs>
    documents?: boolean | Startup$documentsArgs<ExtArgs>
    comments?: boolean | Startup$commentsArgs<ExtArgs>
    dealMatchings?: boolean | Startup$dealMatchingsArgs<ExtArgs>
    _count?: boolean | StartupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["startup"]>

  export type StartupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    stage?: boolean
    website?: boolean
    pitchDeck?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    valuation?: boolean
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: boolean
    simulationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founderId?: boolean
    organizationId?: boolean
    founder?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Startup$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["startup"]>

  export type StartupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    stage?: boolean
    website?: boolean
    pitchDeck?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    valuation?: boolean
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: boolean
    simulationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founderId?: boolean
    organizationId?: boolean
    founder?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Startup$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["startup"]>

  export type StartupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    industry?: boolean
    stage?: boolean
    website?: boolean
    pitchDeck?: boolean
    fundingGoal?: boolean
    amountRaised?: boolean
    valuation?: boolean
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: boolean
    simulationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    founderId?: boolean
    organizationId?: boolean
  }

  export type StartupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "industry" | "stage" | "website" | "pitchDeck" | "fundingGoal" | "amountRaised" | "valuation" | "isApproved" | "isActive" | "aiGeneratedMetrics" | "simulationData" | "createdAt" | "updatedAt" | "founderId" | "organizationId", ExtArgs["result"]["startup"]>
  export type StartupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Startup$organizationArgs<ExtArgs>
    investments?: boolean | Startup$investmentsArgs<ExtArgs>
    simulationInvestments?: boolean | Startup$simulationInvestmentsArgs<ExtArgs>
    dueDiligenceReports?: boolean | Startup$dueDiligenceReportsArgs<ExtArgs>
    documents?: boolean | Startup$documentsArgs<ExtArgs>
    comments?: boolean | Startup$commentsArgs<ExtArgs>
    dealMatchings?: boolean | Startup$dealMatchingsArgs<ExtArgs>
    _count?: boolean | StartupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StartupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Startup$organizationArgs<ExtArgs>
  }
  export type StartupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founder?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Startup$organizationArgs<ExtArgs>
  }

  export type $StartupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Startup"
    objects: {
      founder: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      investments: Prisma.$InvestmentPayload<ExtArgs>[]
      simulationInvestments: Prisma.$SimulationInvestmentPayload<ExtArgs>[]
      dueDiligenceReports: Prisma.$DueDiligenceReportPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      dealMatchings: Prisma.$DealMatchingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      industry: string
      stage: $Enums.FundingStage
      website: string | null
      pitchDeck: string | null
      fundingGoal: Prisma.Decimal
      amountRaised: Prisma.Decimal
      valuation: Prisma.Decimal
      isApproved: boolean
      isActive: boolean
      aiGeneratedMetrics: Prisma.JsonValue | null
      simulationData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      founderId: string
      organizationId: string | null
    }, ExtArgs["result"]["startup"]>
    composites: {}
  }

  type StartupGetPayload<S extends boolean | null | undefined | StartupDefaultArgs> = $Result.GetResult<Prisma.$StartupPayload, S>

  type StartupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StartupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StartupCountAggregateInputType | true
    }

  export interface StartupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Startup'], meta: { name: 'Startup' } }
    /**
     * Find zero or one Startup that matches the filter.
     * @param {StartupFindUniqueArgs} args - Arguments to find a Startup
     * @example
     * // Get one Startup
     * const startup = await prisma.startup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StartupFindUniqueArgs>(args: SelectSubset<T, StartupFindUniqueArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Startup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StartupFindUniqueOrThrowArgs} args - Arguments to find a Startup
     * @example
     * // Get one Startup
     * const startup = await prisma.startup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StartupFindUniqueOrThrowArgs>(args: SelectSubset<T, StartupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Startup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFindFirstArgs} args - Arguments to find a Startup
     * @example
     * // Get one Startup
     * const startup = await prisma.startup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StartupFindFirstArgs>(args?: SelectSubset<T, StartupFindFirstArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Startup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFindFirstOrThrowArgs} args - Arguments to find a Startup
     * @example
     * // Get one Startup
     * const startup = await prisma.startup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StartupFindFirstOrThrowArgs>(args?: SelectSubset<T, StartupFindFirstOrThrowArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Startups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Startups
     * const startups = await prisma.startup.findMany()
     * 
     * // Get first 10 Startups
     * const startups = await prisma.startup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const startupWithIdOnly = await prisma.startup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StartupFindManyArgs>(args?: SelectSubset<T, StartupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Startup.
     * @param {StartupCreateArgs} args - Arguments to create a Startup.
     * @example
     * // Create one Startup
     * const Startup = await prisma.startup.create({
     *   data: {
     *     // ... data to create a Startup
     *   }
     * })
     * 
     */
    create<T extends StartupCreateArgs>(args: SelectSubset<T, StartupCreateArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Startups.
     * @param {StartupCreateManyArgs} args - Arguments to create many Startups.
     * @example
     * // Create many Startups
     * const startup = await prisma.startup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StartupCreateManyArgs>(args?: SelectSubset<T, StartupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Startups and returns the data saved in the database.
     * @param {StartupCreateManyAndReturnArgs} args - Arguments to create many Startups.
     * @example
     * // Create many Startups
     * const startup = await prisma.startup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Startups and only return the `id`
     * const startupWithIdOnly = await prisma.startup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StartupCreateManyAndReturnArgs>(args?: SelectSubset<T, StartupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Startup.
     * @param {StartupDeleteArgs} args - Arguments to delete one Startup.
     * @example
     * // Delete one Startup
     * const Startup = await prisma.startup.delete({
     *   where: {
     *     // ... filter to delete one Startup
     *   }
     * })
     * 
     */
    delete<T extends StartupDeleteArgs>(args: SelectSubset<T, StartupDeleteArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Startup.
     * @param {StartupUpdateArgs} args - Arguments to update one Startup.
     * @example
     * // Update one Startup
     * const startup = await prisma.startup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StartupUpdateArgs>(args: SelectSubset<T, StartupUpdateArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Startups.
     * @param {StartupDeleteManyArgs} args - Arguments to filter Startups to delete.
     * @example
     * // Delete a few Startups
     * const { count } = await prisma.startup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StartupDeleteManyArgs>(args?: SelectSubset<T, StartupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Startups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Startups
     * const startup = await prisma.startup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StartupUpdateManyArgs>(args: SelectSubset<T, StartupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Startups and returns the data updated in the database.
     * @param {StartupUpdateManyAndReturnArgs} args - Arguments to update many Startups.
     * @example
     * // Update many Startups
     * const startup = await prisma.startup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Startups and only return the `id`
     * const startupWithIdOnly = await prisma.startup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StartupUpdateManyAndReturnArgs>(args: SelectSubset<T, StartupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Startup.
     * @param {StartupUpsertArgs} args - Arguments to update or create a Startup.
     * @example
     * // Update or create a Startup
     * const startup = await prisma.startup.upsert({
     *   create: {
     *     // ... data to create a Startup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Startup we want to update
     *   }
     * })
     */
    upsert<T extends StartupUpsertArgs>(args: SelectSubset<T, StartupUpsertArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Startups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupCountArgs} args - Arguments to filter Startups to count.
     * @example
     * // Count the number of Startups
     * const count = await prisma.startup.count({
     *   where: {
     *     // ... the filter for the Startups we want to count
     *   }
     * })
    **/
    count<T extends StartupCountArgs>(
      args?: Subset<T, StartupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StartupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Startup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StartupAggregateArgs>(args: Subset<T, StartupAggregateArgs>): Prisma.PrismaPromise<GetStartupAggregateType<T>>

    /**
     * Group by Startup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StartupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StartupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StartupGroupByArgs['orderBy'] }
        : { orderBy?: StartupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StartupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStartupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Startup model
   */
  readonly fields: StartupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Startup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StartupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    founder<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends Startup$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Startup$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    investments<T extends Startup$investmentsArgs<ExtArgs> = {}>(args?: Subset<T, Startup$investmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simulationInvestments<T extends Startup$simulationInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, Startup$simulationInvestmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dueDiligenceReports<T extends Startup$dueDiligenceReportsArgs<ExtArgs> = {}>(args?: Subset<T, Startup$dueDiligenceReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Startup$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Startup$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Startup$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Startup$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dealMatchings<T extends Startup$dealMatchingsArgs<ExtArgs> = {}>(args?: Subset<T, Startup$dealMatchingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Startup model
   */
  interface StartupFieldRefs {
    readonly id: FieldRef<"Startup", 'String'>
    readonly name: FieldRef<"Startup", 'String'>
    readonly description: FieldRef<"Startup", 'String'>
    readonly industry: FieldRef<"Startup", 'String'>
    readonly stage: FieldRef<"Startup", 'FundingStage'>
    readonly website: FieldRef<"Startup", 'String'>
    readonly pitchDeck: FieldRef<"Startup", 'String'>
    readonly fundingGoal: FieldRef<"Startup", 'Decimal'>
    readonly amountRaised: FieldRef<"Startup", 'Decimal'>
    readonly valuation: FieldRef<"Startup", 'Decimal'>
    readonly isApproved: FieldRef<"Startup", 'Boolean'>
    readonly isActive: FieldRef<"Startup", 'Boolean'>
    readonly aiGeneratedMetrics: FieldRef<"Startup", 'Json'>
    readonly simulationData: FieldRef<"Startup", 'Json'>
    readonly createdAt: FieldRef<"Startup", 'DateTime'>
    readonly updatedAt: FieldRef<"Startup", 'DateTime'>
    readonly founderId: FieldRef<"Startup", 'String'>
    readonly organizationId: FieldRef<"Startup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Startup findUnique
   */
  export type StartupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * Filter, which Startup to fetch.
     */
    where: StartupWhereUniqueInput
  }

  /**
   * Startup findUniqueOrThrow
   */
  export type StartupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * Filter, which Startup to fetch.
     */
    where: StartupWhereUniqueInput
  }

  /**
   * Startup findFirst
   */
  export type StartupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * Filter, which Startup to fetch.
     */
    where?: StartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Startups to fetch.
     */
    orderBy?: StartupOrderByWithRelationInput | StartupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Startups.
     */
    cursor?: StartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Startups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Startups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Startups.
     */
    distinct?: StartupScalarFieldEnum | StartupScalarFieldEnum[]
  }

  /**
   * Startup findFirstOrThrow
   */
  export type StartupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * Filter, which Startup to fetch.
     */
    where?: StartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Startups to fetch.
     */
    orderBy?: StartupOrderByWithRelationInput | StartupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Startups.
     */
    cursor?: StartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Startups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Startups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Startups.
     */
    distinct?: StartupScalarFieldEnum | StartupScalarFieldEnum[]
  }

  /**
   * Startup findMany
   */
  export type StartupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * Filter, which Startups to fetch.
     */
    where?: StartupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Startups to fetch.
     */
    orderBy?: StartupOrderByWithRelationInput | StartupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Startups.
     */
    cursor?: StartupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Startups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Startups.
     */
    skip?: number
    distinct?: StartupScalarFieldEnum | StartupScalarFieldEnum[]
  }

  /**
   * Startup create
   */
  export type StartupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * The data needed to create a Startup.
     */
    data: XOR<StartupCreateInput, StartupUncheckedCreateInput>
  }

  /**
   * Startup createMany
   */
  export type StartupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Startups.
     */
    data: StartupCreateManyInput | StartupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Startup createManyAndReturn
   */
  export type StartupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * The data used to create many Startups.
     */
    data: StartupCreateManyInput | StartupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Startup update
   */
  export type StartupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * The data needed to update a Startup.
     */
    data: XOR<StartupUpdateInput, StartupUncheckedUpdateInput>
    /**
     * Choose, which Startup to update.
     */
    where: StartupWhereUniqueInput
  }

  /**
   * Startup updateMany
   */
  export type StartupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Startups.
     */
    data: XOR<StartupUpdateManyMutationInput, StartupUncheckedUpdateManyInput>
    /**
     * Filter which Startups to update
     */
    where?: StartupWhereInput
    /**
     * Limit how many Startups to update.
     */
    limit?: number
  }

  /**
   * Startup updateManyAndReturn
   */
  export type StartupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * The data used to update Startups.
     */
    data: XOR<StartupUpdateManyMutationInput, StartupUncheckedUpdateManyInput>
    /**
     * Filter which Startups to update
     */
    where?: StartupWhereInput
    /**
     * Limit how many Startups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Startup upsert
   */
  export type StartupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * The filter to search for the Startup to update in case it exists.
     */
    where: StartupWhereUniqueInput
    /**
     * In case the Startup found by the `where` argument doesn't exist, create a new Startup with this data.
     */
    create: XOR<StartupCreateInput, StartupUncheckedCreateInput>
    /**
     * In case the Startup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StartupUpdateInput, StartupUncheckedUpdateInput>
  }

  /**
   * Startup delete
   */
  export type StartupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    /**
     * Filter which Startup to delete.
     */
    where: StartupWhereUniqueInput
  }

  /**
   * Startup deleteMany
   */
  export type StartupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Startups to delete
     */
    where?: StartupWhereInput
    /**
     * Limit how many Startups to delete.
     */
    limit?: number
  }

  /**
   * Startup.organization
   */
  export type Startup$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Startup.investments
   */
  export type Startup$investmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    where?: InvestmentWhereInput
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    cursor?: InvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestmentScalarFieldEnum | InvestmentScalarFieldEnum[]
  }

  /**
   * Startup.simulationInvestments
   */
  export type Startup$simulationInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    where?: SimulationInvestmentWhereInput
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    cursor?: SimulationInvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * Startup.dueDiligenceReports
   */
  export type Startup$dueDiligenceReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    where?: DueDiligenceReportWhereInput
    orderBy?: DueDiligenceReportOrderByWithRelationInput | DueDiligenceReportOrderByWithRelationInput[]
    cursor?: DueDiligenceReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DueDiligenceReportScalarFieldEnum | DueDiligenceReportScalarFieldEnum[]
  }

  /**
   * Startup.documents
   */
  export type Startup$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Startup.comments
   */
  export type Startup$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Startup.dealMatchings
   */
  export type Startup$dealMatchingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    where?: DealMatchingWhereInput
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    cursor?: DealMatchingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealMatchingScalarFieldEnum | DealMatchingScalarFieldEnum[]
  }

  /**
   * Startup without action
   */
  export type StartupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    totalSupply: Decimal | null
    fundingGoal: Decimal | null
    currentPrice: Decimal | null
  }

  export type TokenSumAggregateOutputType = {
    totalSupply: Decimal | null
    fundingGoal: Decimal | null
    currentPrice: Decimal | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    totalSupply: Decimal | null
    tokenomics: string | null
    whitepaperUrl: string | null
    fundingGoal: Decimal | null
    currentPrice: Decimal | null
    isApproved: boolean | null
    isActive: boolean | null
    contractAddress: string | null
    chain: $Enums.Chain | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    organizationId: string | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    description: string | null
    totalSupply: Decimal | null
    tokenomics: string | null
    whitepaperUrl: string | null
    fundingGoal: Decimal | null
    currentPrice: Decimal | null
    isApproved: boolean | null
    isActive: boolean | null
    contractAddress: string | null
    chain: $Enums.Chain | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    organizationId: string | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    description: number
    totalSupply: number
    tokenomics: number
    whitepaperUrl: number
    fundingGoal: number
    currentPrice: number
    isApproved: number
    isActive: number
    contractAddress: number
    chain: number
    createdAt: number
    updatedAt: number
    creatorId: number
    organizationId: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    totalSupply?: true
    fundingGoal?: true
    currentPrice?: true
  }

  export type TokenSumAggregateInputType = {
    totalSupply?: true
    fundingGoal?: true
    currentPrice?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    totalSupply?: true
    tokenomics?: true
    whitepaperUrl?: true
    fundingGoal?: true
    currentPrice?: true
    isApproved?: true
    isActive?: true
    contractAddress?: true
    chain?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    organizationId?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    totalSupply?: true
    tokenomics?: true
    whitepaperUrl?: true
    fundingGoal?: true
    currentPrice?: true
    isApproved?: true
    isActive?: true
    contractAddress?: true
    chain?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    organizationId?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    description?: true
    totalSupply?: true
    tokenomics?: true
    whitepaperUrl?: true
    fundingGoal?: true
    currentPrice?: true
    isApproved?: true
    isActive?: true
    contractAddress?: true
    chain?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    organizationId?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal
    tokenomics: string
    whitepaperUrl: string | null
    fundingGoal: Decimal
    currentPrice: Decimal
    isApproved: boolean
    isActive: boolean
    contractAddress: string | null
    chain: $Enums.Chain | null
    createdAt: Date
    updatedAt: Date
    creatorId: string
    organizationId: string | null
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    totalSupply?: boolean
    tokenomics?: boolean
    whitepaperUrl?: boolean
    fundingGoal?: boolean
    currentPrice?: boolean
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: boolean
    chain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    organizationId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Token$organizationArgs<ExtArgs>
    investments?: boolean | Token$investmentsArgs<ExtArgs>
    simulationInvestments?: boolean | Token$simulationInvestmentsArgs<ExtArgs>
    dueDiligenceReports?: boolean | Token$dueDiligenceReportsArgs<ExtArgs>
    documents?: boolean | Token$documentsArgs<ExtArgs>
    comments?: boolean | Token$commentsArgs<ExtArgs>
    dealMatchings?: boolean | Token$dealMatchingsArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    totalSupply?: boolean
    tokenomics?: boolean
    whitepaperUrl?: boolean
    fundingGoal?: boolean
    currentPrice?: boolean
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: boolean
    chain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    organizationId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Token$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    totalSupply?: boolean
    tokenomics?: boolean
    whitepaperUrl?: boolean
    fundingGoal?: boolean
    currentPrice?: boolean
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: boolean
    chain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    organizationId?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Token$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    totalSupply?: boolean
    tokenomics?: boolean
    whitepaperUrl?: boolean
    fundingGoal?: boolean
    currentPrice?: boolean
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: boolean
    chain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    organizationId?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "description" | "totalSupply" | "tokenomics" | "whitepaperUrl" | "fundingGoal" | "currentPrice" | "isApproved" | "isActive" | "contractAddress" | "chain" | "createdAt" | "updatedAt" | "creatorId" | "organizationId", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Token$organizationArgs<ExtArgs>
    investments?: boolean | Token$investmentsArgs<ExtArgs>
    simulationInvestments?: boolean | Token$simulationInvestmentsArgs<ExtArgs>
    dueDiligenceReports?: boolean | Token$dueDiligenceReportsArgs<ExtArgs>
    documents?: boolean | Token$documentsArgs<ExtArgs>
    comments?: boolean | Token$commentsArgs<ExtArgs>
    dealMatchings?: boolean | Token$dealMatchingsArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Token$organizationArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Token$organizationArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      investments: Prisma.$InvestmentPayload<ExtArgs>[]
      simulationInvestments: Prisma.$SimulationInvestmentPayload<ExtArgs>[]
      dueDiligenceReports: Prisma.$DueDiligenceReportPayload<ExtArgs>[]
      documents: Prisma.$EntityDocumentPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      dealMatchings: Prisma.$DealMatchingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string
      description: string
      totalSupply: Prisma.Decimal
      tokenomics: string
      whitepaperUrl: string | null
      fundingGoal: Prisma.Decimal
      currentPrice: Prisma.Decimal
      isApproved: boolean
      isActive: boolean
      contractAddress: string | null
      chain: $Enums.Chain | null
      createdAt: Date
      updatedAt: Date
      creatorId: string
      organizationId: string | null
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends Token$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Token$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    investments<T extends Token$investmentsArgs<ExtArgs> = {}>(args?: Subset<T, Token$investmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    simulationInvestments<T extends Token$simulationInvestmentsArgs<ExtArgs> = {}>(args?: Subset<T, Token$simulationInvestmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dueDiligenceReports<T extends Token$dueDiligenceReportsArgs<ExtArgs> = {}>(args?: Subset<T, Token$dueDiligenceReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Token$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Token$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Token$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Token$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dealMatchings<T extends Token$dealMatchingsArgs<ExtArgs> = {}>(args?: Subset<T, Token$dealMatchingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly name: FieldRef<"Token", 'String'>
    readonly symbol: FieldRef<"Token", 'String'>
    readonly description: FieldRef<"Token", 'String'>
    readonly totalSupply: FieldRef<"Token", 'Decimal'>
    readonly tokenomics: FieldRef<"Token", 'String'>
    readonly whitepaperUrl: FieldRef<"Token", 'String'>
    readonly fundingGoal: FieldRef<"Token", 'Decimal'>
    readonly currentPrice: FieldRef<"Token", 'Decimal'>
    readonly isApproved: FieldRef<"Token", 'Boolean'>
    readonly isActive: FieldRef<"Token", 'Boolean'>
    readonly contractAddress: FieldRef<"Token", 'String'>
    readonly chain: FieldRef<"Token", 'Chain'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly updatedAt: FieldRef<"Token", 'DateTime'>
    readonly creatorId: FieldRef<"Token", 'String'>
    readonly organizationId: FieldRef<"Token", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token.organization
   */
  export type Token$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Token.investments
   */
  export type Token$investmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    where?: InvestmentWhereInput
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    cursor?: InvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestmentScalarFieldEnum | InvestmentScalarFieldEnum[]
  }

  /**
   * Token.simulationInvestments
   */
  export type Token$simulationInvestmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    where?: SimulationInvestmentWhereInput
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    cursor?: SimulationInvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * Token.dueDiligenceReports
   */
  export type Token$dueDiligenceReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    where?: DueDiligenceReportWhereInput
    orderBy?: DueDiligenceReportOrderByWithRelationInput | DueDiligenceReportOrderByWithRelationInput[]
    cursor?: DueDiligenceReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DueDiligenceReportScalarFieldEnum | DueDiligenceReportScalarFieldEnum[]
  }

  /**
   * Token.documents
   */
  export type Token$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    where?: EntityDocumentWhereInput
    orderBy?: EntityDocumentOrderByWithRelationInput | EntityDocumentOrderByWithRelationInput[]
    cursor?: EntityDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityDocumentScalarFieldEnum | EntityDocumentScalarFieldEnum[]
  }

  /**
   * Token.comments
   */
  export type Token$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Token.dealMatchings
   */
  export type Token$dealMatchingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    where?: DealMatchingWhereInput
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    cursor?: DealMatchingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealMatchingScalarFieldEnum | DealMatchingScalarFieldEnum[]
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model Simulation
   */

  export type AggregateSimulation = {
    _count: SimulationCountAggregateOutputType | null
    _avg: SimulationAvgAggregateOutputType | null
    _sum: SimulationSumAggregateOutputType | null
    _min: SimulationMinAggregateOutputType | null
    _max: SimulationMaxAggregateOutputType | null
  }

  export type SimulationAvgAggregateOutputType = {
    maxParticipants: number | null
    initialBudget: Decimal | null
    difficultyLevel: number | null
  }

  export type SimulationSumAggregateOutputType = {
    maxParticipants: number | null
    initialBudget: Decimal | null
    difficultyLevel: number | null
  }

  export type SimulationMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.SimulationType | null
    status: $Enums.SimulationStatus | null
    maxParticipants: number | null
    startDate: Date | null
    endDate: Date | null
    initialBudget: Decimal | null
    difficultyLevel: number | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.SimulationType | null
    status: $Enums.SimulationStatus | null
    maxParticipants: number | null
    startDate: Date | null
    endDate: Date | null
    initialBudget: Decimal | null
    difficultyLevel: number | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    status: number
    maxParticipants: number
    startDate: number
    endDate: number
    initialBudget: number
    difficultyLevel: number
    scenarioData: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SimulationAvgAggregateInputType = {
    maxParticipants?: true
    initialBudget?: true
    difficultyLevel?: true
  }

  export type SimulationSumAggregateInputType = {
    maxParticipants?: true
    initialBudget?: true
    difficultyLevel?: true
  }

  export type SimulationMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    maxParticipants?: true
    startDate?: true
    endDate?: true
    initialBudget?: true
    difficultyLevel?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    maxParticipants?: true
    startDate?: true
    endDate?: true
    initialBudget?: true
    difficultyLevel?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    maxParticipants?: true
    startDate?: true
    endDate?: true
    initialBudget?: true
    difficultyLevel?: true
    scenarioData?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SimulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Simulation to aggregate.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Simulations
    **/
    _count?: true | SimulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationMaxAggregateInputType
  }

  export type GetSimulationAggregateType<T extends SimulationAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulation[P]>
      : GetScalarType<T[P], AggregateSimulation[P]>
  }




  export type SimulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationWhereInput
    orderBy?: SimulationOrderByWithAggregationInput | SimulationOrderByWithAggregationInput[]
    by: SimulationScalarFieldEnum[] | SimulationScalarFieldEnum
    having?: SimulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationCountAggregateInputType | true
    _avg?: SimulationAvgAggregateInputType
    _sum?: SimulationSumAggregateInputType
    _min?: SimulationMinAggregateInputType
    _max?: SimulationMaxAggregateInputType
  }

  export type SimulationGroupByOutputType = {
    id: string
    title: string
    description: string
    type: $Enums.SimulationType
    status: $Enums.SimulationStatus
    maxParticipants: number
    startDate: Date
    endDate: Date
    initialBudget: Decimal
    difficultyLevel: number
    scenarioData: JsonValue
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: SimulationCountAggregateOutputType | null
    _avg: SimulationAvgAggregateOutputType | null
    _sum: SimulationSumAggregateOutputType | null
    _min: SimulationMinAggregateOutputType | null
    _max: SimulationMaxAggregateOutputType | null
  }

  type GetSimulationGroupByPayload<T extends SimulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationGroupByOutputType[P]>
        }
      >
    >


  export type SimulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    maxParticipants?: boolean
    startDate?: boolean
    endDate?: boolean
    initialBudget?: boolean
    difficultyLevel?: boolean
    scenarioData?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | Simulation$participantsArgs<ExtArgs>
    investments?: boolean | Simulation$investmentsArgs<ExtArgs>
    leaderboard?: boolean | Simulation$leaderboardArgs<ExtArgs>
    _count?: boolean | SimulationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    maxParticipants?: boolean
    startDate?: boolean
    endDate?: boolean
    initialBudget?: boolean
    difficultyLevel?: boolean
    scenarioData?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    maxParticipants?: boolean
    startDate?: boolean
    endDate?: boolean
    initialBudget?: boolean
    difficultyLevel?: boolean
    scenarioData?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulation"]>

  export type SimulationSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    maxParticipants?: boolean
    startDate?: boolean
    endDate?: boolean
    initialBudget?: boolean
    difficultyLevel?: boolean
    scenarioData?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SimulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "status" | "maxParticipants" | "startDate" | "endDate" | "initialBudget" | "difficultyLevel" | "scenarioData" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["simulation"]>
  export type SimulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    participants?: boolean | Simulation$participantsArgs<ExtArgs>
    investments?: boolean | Simulation$investmentsArgs<ExtArgs>
    leaderboard?: boolean | Simulation$leaderboardArgs<ExtArgs>
    _count?: boolean | SimulationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SimulationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SimulationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SimulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Simulation"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      participants: Prisma.$UserPayload<ExtArgs>[]
      investments: Prisma.$SimulationInvestmentPayload<ExtArgs>[]
      leaderboard: Prisma.$SimulationLeaderboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: $Enums.SimulationType
      status: $Enums.SimulationStatus
      maxParticipants: number
      startDate: Date
      endDate: Date
      initialBudget: Prisma.Decimal
      difficultyLevel: number
      scenarioData: Prisma.JsonValue
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["simulation"]>
    composites: {}
  }

  type SimulationGetPayload<S extends boolean | null | undefined | SimulationDefaultArgs> = $Result.GetResult<Prisma.$SimulationPayload, S>

  type SimulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationCountAggregateInputType | true
    }

  export interface SimulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Simulation'], meta: { name: 'Simulation' } }
    /**
     * Find zero or one Simulation that matches the filter.
     * @param {SimulationFindUniqueArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationFindUniqueArgs>(args: SelectSubset<T, SimulationFindUniqueArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Simulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationFindUniqueOrThrowArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Simulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindFirstArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationFindFirstArgs>(args?: SelectSubset<T, SimulationFindFirstArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Simulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindFirstOrThrowArgs} args - Arguments to find a Simulation
     * @example
     * // Get one Simulation
     * const simulation = await prisma.simulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Simulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Simulations
     * const simulations = await prisma.simulation.findMany()
     * 
     * // Get first 10 Simulations
     * const simulations = await prisma.simulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationWithIdOnly = await prisma.simulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationFindManyArgs>(args?: SelectSubset<T, SimulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Simulation.
     * @param {SimulationCreateArgs} args - Arguments to create a Simulation.
     * @example
     * // Create one Simulation
     * const Simulation = await prisma.simulation.create({
     *   data: {
     *     // ... data to create a Simulation
     *   }
     * })
     * 
     */
    create<T extends SimulationCreateArgs>(args: SelectSubset<T, SimulationCreateArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Simulations.
     * @param {SimulationCreateManyArgs} args - Arguments to create many Simulations.
     * @example
     * // Create many Simulations
     * const simulation = await prisma.simulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationCreateManyArgs>(args?: SelectSubset<T, SimulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Simulations and returns the data saved in the database.
     * @param {SimulationCreateManyAndReturnArgs} args - Arguments to create many Simulations.
     * @example
     * // Create many Simulations
     * const simulation = await prisma.simulation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Simulations and only return the `id`
     * const simulationWithIdOnly = await prisma.simulation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Simulation.
     * @param {SimulationDeleteArgs} args - Arguments to delete one Simulation.
     * @example
     * // Delete one Simulation
     * const Simulation = await prisma.simulation.delete({
     *   where: {
     *     // ... filter to delete one Simulation
     *   }
     * })
     * 
     */
    delete<T extends SimulationDeleteArgs>(args: SelectSubset<T, SimulationDeleteArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Simulation.
     * @param {SimulationUpdateArgs} args - Arguments to update one Simulation.
     * @example
     * // Update one Simulation
     * const simulation = await prisma.simulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationUpdateArgs>(args: SelectSubset<T, SimulationUpdateArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Simulations.
     * @param {SimulationDeleteManyArgs} args - Arguments to filter Simulations to delete.
     * @example
     * // Delete a few Simulations
     * const { count } = await prisma.simulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationDeleteManyArgs>(args?: SelectSubset<T, SimulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Simulations
     * const simulation = await prisma.simulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationUpdateManyArgs>(args: SelectSubset<T, SimulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Simulations and returns the data updated in the database.
     * @param {SimulationUpdateManyAndReturnArgs} args - Arguments to update many Simulations.
     * @example
     * // Update many Simulations
     * const simulation = await prisma.simulation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Simulations and only return the `id`
     * const simulationWithIdOnly = await prisma.simulation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Simulation.
     * @param {SimulationUpsertArgs} args - Arguments to update or create a Simulation.
     * @example
     * // Update or create a Simulation
     * const simulation = await prisma.simulation.upsert({
     *   create: {
     *     // ... data to create a Simulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Simulation we want to update
     *   }
     * })
     */
    upsert<T extends SimulationUpsertArgs>(args: SelectSubset<T, SimulationUpsertArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Simulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationCountArgs} args - Arguments to filter Simulations to count.
     * @example
     * // Count the number of Simulations
     * const count = await prisma.simulation.count({
     *   where: {
     *     // ... the filter for the Simulations we want to count
     *   }
     * })
    **/
    count<T extends SimulationCountArgs>(
      args?: Subset<T, SimulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationAggregateArgs>(args: Subset<T, SimulationAggregateArgs>): Prisma.PrismaPromise<GetSimulationAggregateType<T>>

    /**
     * Group by Simulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationGroupByArgs['orderBy'] }
        : { orderBy?: SimulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Simulation model
   */
  readonly fields: SimulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Simulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Simulation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investments<T extends Simulation$investmentsArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$investmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboard<T extends Simulation$leaderboardArgs<ExtArgs> = {}>(args?: Subset<T, Simulation$leaderboardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Simulation model
   */
  interface SimulationFieldRefs {
    readonly id: FieldRef<"Simulation", 'String'>
    readonly title: FieldRef<"Simulation", 'String'>
    readonly description: FieldRef<"Simulation", 'String'>
    readonly type: FieldRef<"Simulation", 'SimulationType'>
    readonly status: FieldRef<"Simulation", 'SimulationStatus'>
    readonly maxParticipants: FieldRef<"Simulation", 'Int'>
    readonly startDate: FieldRef<"Simulation", 'DateTime'>
    readonly endDate: FieldRef<"Simulation", 'DateTime'>
    readonly initialBudget: FieldRef<"Simulation", 'Decimal'>
    readonly difficultyLevel: FieldRef<"Simulation", 'Int'>
    readonly scenarioData: FieldRef<"Simulation", 'Json'>
    readonly ownerId: FieldRef<"Simulation", 'String'>
    readonly createdAt: FieldRef<"Simulation", 'DateTime'>
    readonly updatedAt: FieldRef<"Simulation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Simulation findUnique
   */
  export type SimulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation findUniqueOrThrow
   */
  export type SimulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation findFirst
   */
  export type SimulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Simulations.
     */
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation findFirstOrThrow
   */
  export type SimulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulation to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Simulations.
     */
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation findMany
   */
  export type SimulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter, which Simulations to fetch.
     */
    where?: SimulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Simulations to fetch.
     */
    orderBy?: SimulationOrderByWithRelationInput | SimulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Simulations.
     */
    cursor?: SimulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Simulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Simulations.
     */
    skip?: number
    distinct?: SimulationScalarFieldEnum | SimulationScalarFieldEnum[]
  }

  /**
   * Simulation create
   */
  export type SimulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The data needed to create a Simulation.
     */
    data: XOR<SimulationCreateInput, SimulationUncheckedCreateInput>
  }

  /**
   * Simulation createMany
   */
  export type SimulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Simulations.
     */
    data: SimulationCreateManyInput | SimulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Simulation createManyAndReturn
   */
  export type SimulationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * The data used to create many Simulations.
     */
    data: SimulationCreateManyInput | SimulationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Simulation update
   */
  export type SimulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The data needed to update a Simulation.
     */
    data: XOR<SimulationUpdateInput, SimulationUncheckedUpdateInput>
    /**
     * Choose, which Simulation to update.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation updateMany
   */
  export type SimulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Simulations.
     */
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyInput>
    /**
     * Filter which Simulations to update
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to update.
     */
    limit?: number
  }

  /**
   * Simulation updateManyAndReturn
   */
  export type SimulationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * The data used to update Simulations.
     */
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyInput>
    /**
     * Filter which Simulations to update
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Simulation upsert
   */
  export type SimulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * The filter to search for the Simulation to update in case it exists.
     */
    where: SimulationWhereUniqueInput
    /**
     * In case the Simulation found by the `where` argument doesn't exist, create a new Simulation with this data.
     */
    create: XOR<SimulationCreateInput, SimulationUncheckedCreateInput>
    /**
     * In case the Simulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationUpdateInput, SimulationUncheckedUpdateInput>
  }

  /**
   * Simulation delete
   */
  export type SimulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
    /**
     * Filter which Simulation to delete.
     */
    where: SimulationWhereUniqueInput
  }

  /**
   * Simulation deleteMany
   */
  export type SimulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Simulations to delete
     */
    where?: SimulationWhereInput
    /**
     * Limit how many Simulations to delete.
     */
    limit?: number
  }

  /**
   * Simulation.participants
   */
  export type Simulation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Simulation.investments
   */
  export type Simulation$investmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    where?: SimulationInvestmentWhereInput
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    cursor?: SimulationInvestmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * Simulation.leaderboard
   */
  export type Simulation$leaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    where?: SimulationLeaderboardWhereInput
    orderBy?: SimulationLeaderboardOrderByWithRelationInput | SimulationLeaderboardOrderByWithRelationInput[]
    cursor?: SimulationLeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SimulationLeaderboardScalarFieldEnum | SimulationLeaderboardScalarFieldEnum[]
  }

  /**
   * Simulation without action
   */
  export type SimulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Simulation
     */
    select?: SimulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Simulation
     */
    omit?: SimulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInclude<ExtArgs> | null
  }


  /**
   * Model SimulationInvestment
   */

  export type AggregateSimulationInvestment = {
    _count: SimulationInvestmentCountAggregateOutputType | null
    _avg: SimulationInvestmentAvgAggregateOutputType | null
    _sum: SimulationInvestmentSumAggregateOutputType | null
    _min: SimulationInvestmentMinAggregateOutputType | null
    _max: SimulationInvestmentMaxAggregateOutputType | null
  }

  export type SimulationInvestmentAvgAggregateOutputType = {
    amount: Decimal | null
    ownership: Decimal | null
    currentValue: Decimal | null
    roi: Decimal | null
  }

  export type SimulationInvestmentSumAggregateOutputType = {
    amount: Decimal | null
    ownership: Decimal | null
    currentValue: Decimal | null
    roi: Decimal | null
  }

  export type SimulationInvestmentMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    userId: string | null
    startupId: string | null
    tokenId: string | null
    amount: Decimal | null
    ownership: Decimal | null
    currentValue: Decimal | null
    roi: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationInvestmentMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    userId: string | null
    startupId: string | null
    tokenId: string | null
    amount: Decimal | null
    ownership: Decimal | null
    currentValue: Decimal | null
    roi: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SimulationInvestmentCountAggregateOutputType = {
    id: number
    simulationId: number
    userId: number
    startupId: number
    tokenId: number
    amount: number
    ownership: number
    currentValue: number
    roi: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SimulationInvestmentAvgAggregateInputType = {
    amount?: true
    ownership?: true
    currentValue?: true
    roi?: true
  }

  export type SimulationInvestmentSumAggregateInputType = {
    amount?: true
    ownership?: true
    currentValue?: true
    roi?: true
  }

  export type SimulationInvestmentMinAggregateInputType = {
    id?: true
    simulationId?: true
    userId?: true
    startupId?: true
    tokenId?: true
    amount?: true
    ownership?: true
    currentValue?: true
    roi?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationInvestmentMaxAggregateInputType = {
    id?: true
    simulationId?: true
    userId?: true
    startupId?: true
    tokenId?: true
    amount?: true
    ownership?: true
    currentValue?: true
    roi?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SimulationInvestmentCountAggregateInputType = {
    id?: true
    simulationId?: true
    userId?: true
    startupId?: true
    tokenId?: true
    amount?: true
    ownership?: true
    currentValue?: true
    roi?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SimulationInvestmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationInvestment to aggregate.
     */
    where?: SimulationInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationInvestments to fetch.
     */
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationInvestments
    **/
    _count?: true | SimulationInvestmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimulationInvestmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimulationInvestmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationInvestmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationInvestmentMaxAggregateInputType
  }

  export type GetSimulationInvestmentAggregateType<T extends SimulationInvestmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationInvestment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationInvestment[P]>
      : GetScalarType<T[P], AggregateSimulationInvestment[P]>
  }




  export type SimulationInvestmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationInvestmentWhereInput
    orderBy?: SimulationInvestmentOrderByWithAggregationInput | SimulationInvestmentOrderByWithAggregationInput[]
    by: SimulationInvestmentScalarFieldEnum[] | SimulationInvestmentScalarFieldEnum
    having?: SimulationInvestmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationInvestmentCountAggregateInputType | true
    _avg?: SimulationInvestmentAvgAggregateInputType
    _sum?: SimulationInvestmentSumAggregateInputType
    _min?: SimulationInvestmentMinAggregateInputType
    _max?: SimulationInvestmentMaxAggregateInputType
  }

  export type SimulationInvestmentGroupByOutputType = {
    id: string
    simulationId: string
    userId: string
    startupId: string | null
    tokenId: string | null
    amount: Decimal
    ownership: Decimal
    currentValue: Decimal
    roi: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SimulationInvestmentCountAggregateOutputType | null
    _avg: SimulationInvestmentAvgAggregateOutputType | null
    _sum: SimulationInvestmentSumAggregateOutputType | null
    _min: SimulationInvestmentMinAggregateOutputType | null
    _max: SimulationInvestmentMaxAggregateOutputType | null
  }

  type GetSimulationInvestmentGroupByPayload<T extends SimulationInvestmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationInvestmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationInvestmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationInvestmentGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationInvestmentGroupByOutputType[P]>
        }
      >
    >


  export type SimulationInvestmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    currentValue?: boolean
    roi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | SimulationInvestment$startupArgs<ExtArgs>
    token?: boolean | SimulationInvestment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["simulationInvestment"]>

  export type SimulationInvestmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    currentValue?: boolean
    roi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | SimulationInvestment$startupArgs<ExtArgs>
    token?: boolean | SimulationInvestment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["simulationInvestment"]>

  export type SimulationInvestmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    currentValue?: boolean
    roi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | SimulationInvestment$startupArgs<ExtArgs>
    token?: boolean | SimulationInvestment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["simulationInvestment"]>

  export type SimulationInvestmentSelectScalar = {
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    currentValue?: boolean
    roi?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SimulationInvestmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "userId" | "startupId" | "tokenId" | "amount" | "ownership" | "currentValue" | "roi" | "createdAt" | "updatedAt", ExtArgs["result"]["simulationInvestment"]>
  export type SimulationInvestmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | SimulationInvestment$startupArgs<ExtArgs>
    token?: boolean | SimulationInvestment$tokenArgs<ExtArgs>
  }
  export type SimulationInvestmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | SimulationInvestment$startupArgs<ExtArgs>
    token?: boolean | SimulationInvestment$tokenArgs<ExtArgs>
  }
  export type SimulationInvestmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | SimulationInvestment$startupArgs<ExtArgs>
    token?: boolean | SimulationInvestment$tokenArgs<ExtArgs>
  }

  export type $SimulationInvestmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationInvestment"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      startup: Prisma.$StartupPayload<ExtArgs> | null
      token: Prisma.$TokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      userId: string
      startupId: string | null
      tokenId: string | null
      amount: Prisma.Decimal
      ownership: Prisma.Decimal
      currentValue: Prisma.Decimal
      roi: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["simulationInvestment"]>
    composites: {}
  }

  type SimulationInvestmentGetPayload<S extends boolean | null | undefined | SimulationInvestmentDefaultArgs> = $Result.GetResult<Prisma.$SimulationInvestmentPayload, S>

  type SimulationInvestmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationInvestmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationInvestmentCountAggregateInputType | true
    }

  export interface SimulationInvestmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationInvestment'], meta: { name: 'SimulationInvestment' } }
    /**
     * Find zero or one SimulationInvestment that matches the filter.
     * @param {SimulationInvestmentFindUniqueArgs} args - Arguments to find a SimulationInvestment
     * @example
     * // Get one SimulationInvestment
     * const simulationInvestment = await prisma.simulationInvestment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationInvestmentFindUniqueArgs>(args: SelectSubset<T, SimulationInvestmentFindUniqueArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SimulationInvestment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationInvestmentFindUniqueOrThrowArgs} args - Arguments to find a SimulationInvestment
     * @example
     * // Get one SimulationInvestment
     * const simulationInvestment = await prisma.simulationInvestment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationInvestmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationInvestmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationInvestment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentFindFirstArgs} args - Arguments to find a SimulationInvestment
     * @example
     * // Get one SimulationInvestment
     * const simulationInvestment = await prisma.simulationInvestment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationInvestmentFindFirstArgs>(args?: SelectSubset<T, SimulationInvestmentFindFirstArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationInvestment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentFindFirstOrThrowArgs} args - Arguments to find a SimulationInvestment
     * @example
     * // Get one SimulationInvestment
     * const simulationInvestment = await prisma.simulationInvestment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationInvestmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationInvestmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SimulationInvestments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationInvestments
     * const simulationInvestments = await prisma.simulationInvestment.findMany()
     * 
     * // Get first 10 SimulationInvestments
     * const simulationInvestments = await prisma.simulationInvestment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationInvestmentWithIdOnly = await prisma.simulationInvestment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationInvestmentFindManyArgs>(args?: SelectSubset<T, SimulationInvestmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SimulationInvestment.
     * @param {SimulationInvestmentCreateArgs} args - Arguments to create a SimulationInvestment.
     * @example
     * // Create one SimulationInvestment
     * const SimulationInvestment = await prisma.simulationInvestment.create({
     *   data: {
     *     // ... data to create a SimulationInvestment
     *   }
     * })
     * 
     */
    create<T extends SimulationInvestmentCreateArgs>(args: SelectSubset<T, SimulationInvestmentCreateArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SimulationInvestments.
     * @param {SimulationInvestmentCreateManyArgs} args - Arguments to create many SimulationInvestments.
     * @example
     * // Create many SimulationInvestments
     * const simulationInvestment = await prisma.simulationInvestment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationInvestmentCreateManyArgs>(args?: SelectSubset<T, SimulationInvestmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationInvestments and returns the data saved in the database.
     * @param {SimulationInvestmentCreateManyAndReturnArgs} args - Arguments to create many SimulationInvestments.
     * @example
     * // Create many SimulationInvestments
     * const simulationInvestment = await prisma.simulationInvestment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationInvestments and only return the `id`
     * const simulationInvestmentWithIdOnly = await prisma.simulationInvestment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationInvestmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationInvestmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SimulationInvestment.
     * @param {SimulationInvestmentDeleteArgs} args - Arguments to delete one SimulationInvestment.
     * @example
     * // Delete one SimulationInvestment
     * const SimulationInvestment = await prisma.simulationInvestment.delete({
     *   where: {
     *     // ... filter to delete one SimulationInvestment
     *   }
     * })
     * 
     */
    delete<T extends SimulationInvestmentDeleteArgs>(args: SelectSubset<T, SimulationInvestmentDeleteArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SimulationInvestment.
     * @param {SimulationInvestmentUpdateArgs} args - Arguments to update one SimulationInvestment.
     * @example
     * // Update one SimulationInvestment
     * const simulationInvestment = await prisma.simulationInvestment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationInvestmentUpdateArgs>(args: SelectSubset<T, SimulationInvestmentUpdateArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SimulationInvestments.
     * @param {SimulationInvestmentDeleteManyArgs} args - Arguments to filter SimulationInvestments to delete.
     * @example
     * // Delete a few SimulationInvestments
     * const { count } = await prisma.simulationInvestment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationInvestmentDeleteManyArgs>(args?: SelectSubset<T, SimulationInvestmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationInvestments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationInvestments
     * const simulationInvestment = await prisma.simulationInvestment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationInvestmentUpdateManyArgs>(args: SelectSubset<T, SimulationInvestmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationInvestments and returns the data updated in the database.
     * @param {SimulationInvestmentUpdateManyAndReturnArgs} args - Arguments to update many SimulationInvestments.
     * @example
     * // Update many SimulationInvestments
     * const simulationInvestment = await prisma.simulationInvestment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SimulationInvestments and only return the `id`
     * const simulationInvestmentWithIdOnly = await prisma.simulationInvestment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationInvestmentUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationInvestmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SimulationInvestment.
     * @param {SimulationInvestmentUpsertArgs} args - Arguments to update or create a SimulationInvestment.
     * @example
     * // Update or create a SimulationInvestment
     * const simulationInvestment = await prisma.simulationInvestment.upsert({
     *   create: {
     *     // ... data to create a SimulationInvestment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationInvestment we want to update
     *   }
     * })
     */
    upsert<T extends SimulationInvestmentUpsertArgs>(args: SelectSubset<T, SimulationInvestmentUpsertArgs<ExtArgs>>): Prisma__SimulationInvestmentClient<$Result.GetResult<Prisma.$SimulationInvestmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SimulationInvestments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentCountArgs} args - Arguments to filter SimulationInvestments to count.
     * @example
     * // Count the number of SimulationInvestments
     * const count = await prisma.simulationInvestment.count({
     *   where: {
     *     // ... the filter for the SimulationInvestments we want to count
     *   }
     * })
    **/
    count<T extends SimulationInvestmentCountArgs>(
      args?: Subset<T, SimulationInvestmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationInvestmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationInvestment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationInvestmentAggregateArgs>(args: Subset<T, SimulationInvestmentAggregateArgs>): Prisma.PrismaPromise<GetSimulationInvestmentAggregateType<T>>

    /**
     * Group by SimulationInvestment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationInvestmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationInvestmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationInvestmentGroupByArgs['orderBy'] }
        : { orderBy?: SimulationInvestmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationInvestmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationInvestmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationInvestment model
   */
  readonly fields: SimulationInvestmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationInvestment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationInvestmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    startup<T extends SimulationInvestment$startupArgs<ExtArgs> = {}>(args?: Subset<T, SimulationInvestment$startupArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    token<T extends SimulationInvestment$tokenArgs<ExtArgs> = {}>(args?: Subset<T, SimulationInvestment$tokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationInvestment model
   */
  interface SimulationInvestmentFieldRefs {
    readonly id: FieldRef<"SimulationInvestment", 'String'>
    readonly simulationId: FieldRef<"SimulationInvestment", 'String'>
    readonly userId: FieldRef<"SimulationInvestment", 'String'>
    readonly startupId: FieldRef<"SimulationInvestment", 'String'>
    readonly tokenId: FieldRef<"SimulationInvestment", 'String'>
    readonly amount: FieldRef<"SimulationInvestment", 'Decimal'>
    readonly ownership: FieldRef<"SimulationInvestment", 'Decimal'>
    readonly currentValue: FieldRef<"SimulationInvestment", 'Decimal'>
    readonly roi: FieldRef<"SimulationInvestment", 'Decimal'>
    readonly createdAt: FieldRef<"SimulationInvestment", 'DateTime'>
    readonly updatedAt: FieldRef<"SimulationInvestment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SimulationInvestment findUnique
   */
  export type SimulationInvestmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which SimulationInvestment to fetch.
     */
    where: SimulationInvestmentWhereUniqueInput
  }

  /**
   * SimulationInvestment findUniqueOrThrow
   */
  export type SimulationInvestmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which SimulationInvestment to fetch.
     */
    where: SimulationInvestmentWhereUniqueInput
  }

  /**
   * SimulationInvestment findFirst
   */
  export type SimulationInvestmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which SimulationInvestment to fetch.
     */
    where?: SimulationInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationInvestments to fetch.
     */
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationInvestments.
     */
    cursor?: SimulationInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationInvestments.
     */
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * SimulationInvestment findFirstOrThrow
   */
  export type SimulationInvestmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which SimulationInvestment to fetch.
     */
    where?: SimulationInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationInvestments to fetch.
     */
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationInvestments.
     */
    cursor?: SimulationInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationInvestments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationInvestments.
     */
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * SimulationInvestment findMany
   */
  export type SimulationInvestmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * Filter, which SimulationInvestments to fetch.
     */
    where?: SimulationInvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationInvestments to fetch.
     */
    orderBy?: SimulationInvestmentOrderByWithRelationInput | SimulationInvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationInvestments.
     */
    cursor?: SimulationInvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationInvestments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationInvestments.
     */
    skip?: number
    distinct?: SimulationInvestmentScalarFieldEnum | SimulationInvestmentScalarFieldEnum[]
  }

  /**
   * SimulationInvestment create
   */
  export type SimulationInvestmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * The data needed to create a SimulationInvestment.
     */
    data: XOR<SimulationInvestmentCreateInput, SimulationInvestmentUncheckedCreateInput>
  }

  /**
   * SimulationInvestment createMany
   */
  export type SimulationInvestmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationInvestments.
     */
    data: SimulationInvestmentCreateManyInput | SimulationInvestmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationInvestment createManyAndReturn
   */
  export type SimulationInvestmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * The data used to create many SimulationInvestments.
     */
    data: SimulationInvestmentCreateManyInput | SimulationInvestmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationInvestment update
   */
  export type SimulationInvestmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * The data needed to update a SimulationInvestment.
     */
    data: XOR<SimulationInvestmentUpdateInput, SimulationInvestmentUncheckedUpdateInput>
    /**
     * Choose, which SimulationInvestment to update.
     */
    where: SimulationInvestmentWhereUniqueInput
  }

  /**
   * SimulationInvestment updateMany
   */
  export type SimulationInvestmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationInvestments.
     */
    data: XOR<SimulationInvestmentUpdateManyMutationInput, SimulationInvestmentUncheckedUpdateManyInput>
    /**
     * Filter which SimulationInvestments to update
     */
    where?: SimulationInvestmentWhereInput
    /**
     * Limit how many SimulationInvestments to update.
     */
    limit?: number
  }

  /**
   * SimulationInvestment updateManyAndReturn
   */
  export type SimulationInvestmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * The data used to update SimulationInvestments.
     */
    data: XOR<SimulationInvestmentUpdateManyMutationInput, SimulationInvestmentUncheckedUpdateManyInput>
    /**
     * Filter which SimulationInvestments to update
     */
    where?: SimulationInvestmentWhereInput
    /**
     * Limit how many SimulationInvestments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationInvestment upsert
   */
  export type SimulationInvestmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * The filter to search for the SimulationInvestment to update in case it exists.
     */
    where: SimulationInvestmentWhereUniqueInput
    /**
     * In case the SimulationInvestment found by the `where` argument doesn't exist, create a new SimulationInvestment with this data.
     */
    create: XOR<SimulationInvestmentCreateInput, SimulationInvestmentUncheckedCreateInput>
    /**
     * In case the SimulationInvestment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationInvestmentUpdateInput, SimulationInvestmentUncheckedUpdateInput>
  }

  /**
   * SimulationInvestment delete
   */
  export type SimulationInvestmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
    /**
     * Filter which SimulationInvestment to delete.
     */
    where: SimulationInvestmentWhereUniqueInput
  }

  /**
   * SimulationInvestment deleteMany
   */
  export type SimulationInvestmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationInvestments to delete
     */
    where?: SimulationInvestmentWhereInput
    /**
     * Limit how many SimulationInvestments to delete.
     */
    limit?: number
  }

  /**
   * SimulationInvestment.startup
   */
  export type SimulationInvestment$startupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
  }

  /**
   * SimulationInvestment.token
   */
  export type SimulationInvestment$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * SimulationInvestment without action
   */
  export type SimulationInvestmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationInvestment
     */
    select?: SimulationInvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationInvestment
     */
    omit?: SimulationInvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationInvestmentInclude<ExtArgs> | null
  }


  /**
   * Model SimulationLeaderboard
   */

  export type AggregateSimulationLeaderboard = {
    _count: SimulationLeaderboardCountAggregateOutputType | null
    _avg: SimulationLeaderboardAvgAggregateOutputType | null
    _sum: SimulationLeaderboardSumAggregateOutputType | null
    _min: SimulationLeaderboardMinAggregateOutputType | null
    _max: SimulationLeaderboardMaxAggregateOutputType | null
  }

  export type SimulationLeaderboardAvgAggregateOutputType = {
    rank: number | null
    totalReturn: Decimal | null
    roiPercent: Decimal | null
  }

  export type SimulationLeaderboardSumAggregateOutputType = {
    rank: number | null
    totalReturn: Decimal | null
    roiPercent: Decimal | null
  }

  export type SimulationLeaderboardMinAggregateOutputType = {
    id: string | null
    simulationId: string | null
    userId: string | null
    rank: number | null
    totalReturn: Decimal | null
    roiPercent: Decimal | null
  }

  export type SimulationLeaderboardMaxAggregateOutputType = {
    id: string | null
    simulationId: string | null
    userId: string | null
    rank: number | null
    totalReturn: Decimal | null
    roiPercent: Decimal | null
  }

  export type SimulationLeaderboardCountAggregateOutputType = {
    id: number
    simulationId: number
    userId: number
    rank: number
    totalReturn: number
    roiPercent: number
    _all: number
  }


  export type SimulationLeaderboardAvgAggregateInputType = {
    rank?: true
    totalReturn?: true
    roiPercent?: true
  }

  export type SimulationLeaderboardSumAggregateInputType = {
    rank?: true
    totalReturn?: true
    roiPercent?: true
  }

  export type SimulationLeaderboardMinAggregateInputType = {
    id?: true
    simulationId?: true
    userId?: true
    rank?: true
    totalReturn?: true
    roiPercent?: true
  }

  export type SimulationLeaderboardMaxAggregateInputType = {
    id?: true
    simulationId?: true
    userId?: true
    rank?: true
    totalReturn?: true
    roiPercent?: true
  }

  export type SimulationLeaderboardCountAggregateInputType = {
    id?: true
    simulationId?: true
    userId?: true
    rank?: true
    totalReturn?: true
    roiPercent?: true
    _all?: true
  }

  export type SimulationLeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationLeaderboard to aggregate.
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationLeaderboards to fetch.
     */
    orderBy?: SimulationLeaderboardOrderByWithRelationInput | SimulationLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SimulationLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SimulationLeaderboards
    **/
    _count?: true | SimulationLeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SimulationLeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SimulationLeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SimulationLeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SimulationLeaderboardMaxAggregateInputType
  }

  export type GetSimulationLeaderboardAggregateType<T extends SimulationLeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateSimulationLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSimulationLeaderboard[P]>
      : GetScalarType<T[P], AggregateSimulationLeaderboard[P]>
  }




  export type SimulationLeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SimulationLeaderboardWhereInput
    orderBy?: SimulationLeaderboardOrderByWithAggregationInput | SimulationLeaderboardOrderByWithAggregationInput[]
    by: SimulationLeaderboardScalarFieldEnum[] | SimulationLeaderboardScalarFieldEnum
    having?: SimulationLeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SimulationLeaderboardCountAggregateInputType | true
    _avg?: SimulationLeaderboardAvgAggregateInputType
    _sum?: SimulationLeaderboardSumAggregateInputType
    _min?: SimulationLeaderboardMinAggregateInputType
    _max?: SimulationLeaderboardMaxAggregateInputType
  }

  export type SimulationLeaderboardGroupByOutputType = {
    id: string
    simulationId: string
    userId: string
    rank: number
    totalReturn: Decimal
    roiPercent: Decimal
    _count: SimulationLeaderboardCountAggregateOutputType | null
    _avg: SimulationLeaderboardAvgAggregateOutputType | null
    _sum: SimulationLeaderboardSumAggregateOutputType | null
    _min: SimulationLeaderboardMinAggregateOutputType | null
    _max: SimulationLeaderboardMaxAggregateOutputType | null
  }

  type GetSimulationLeaderboardGroupByPayload<T extends SimulationLeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SimulationLeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SimulationLeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SimulationLeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], SimulationLeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type SimulationLeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    rank?: boolean
    totalReturn?: boolean
    roiPercent?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationLeaderboard"]>

  export type SimulationLeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    rank?: boolean
    totalReturn?: boolean
    roiPercent?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationLeaderboard"]>

  export type SimulationLeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    rank?: boolean
    totalReturn?: boolean
    roiPercent?: boolean
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["simulationLeaderboard"]>

  export type SimulationLeaderboardSelectScalar = {
    id?: boolean
    simulationId?: boolean
    userId?: boolean
    rank?: boolean
    totalReturn?: boolean
    roiPercent?: boolean
  }

  export type SimulationLeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "simulationId" | "userId" | "rank" | "totalReturn" | "roiPercent", ExtArgs["result"]["simulationLeaderboard"]>
  export type SimulationLeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SimulationLeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SimulationLeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    simulation?: boolean | SimulationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SimulationLeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SimulationLeaderboard"
    objects: {
      simulation: Prisma.$SimulationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      simulationId: string
      userId: string
      rank: number
      totalReturn: Prisma.Decimal
      roiPercent: Prisma.Decimal
    }, ExtArgs["result"]["simulationLeaderboard"]>
    composites: {}
  }

  type SimulationLeaderboardGetPayload<S extends boolean | null | undefined | SimulationLeaderboardDefaultArgs> = $Result.GetResult<Prisma.$SimulationLeaderboardPayload, S>

  type SimulationLeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SimulationLeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SimulationLeaderboardCountAggregateInputType | true
    }

  export interface SimulationLeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SimulationLeaderboard'], meta: { name: 'SimulationLeaderboard' } }
    /**
     * Find zero or one SimulationLeaderboard that matches the filter.
     * @param {SimulationLeaderboardFindUniqueArgs} args - Arguments to find a SimulationLeaderboard
     * @example
     * // Get one SimulationLeaderboard
     * const simulationLeaderboard = await prisma.simulationLeaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SimulationLeaderboardFindUniqueArgs>(args: SelectSubset<T, SimulationLeaderboardFindUniqueArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SimulationLeaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SimulationLeaderboardFindUniqueOrThrowArgs} args - Arguments to find a SimulationLeaderboard
     * @example
     * // Get one SimulationLeaderboard
     * const simulationLeaderboard = await prisma.simulationLeaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SimulationLeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, SimulationLeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationLeaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardFindFirstArgs} args - Arguments to find a SimulationLeaderboard
     * @example
     * // Get one SimulationLeaderboard
     * const simulationLeaderboard = await prisma.simulationLeaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SimulationLeaderboardFindFirstArgs>(args?: SelectSubset<T, SimulationLeaderboardFindFirstArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SimulationLeaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardFindFirstOrThrowArgs} args - Arguments to find a SimulationLeaderboard
     * @example
     * // Get one SimulationLeaderboard
     * const simulationLeaderboard = await prisma.simulationLeaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SimulationLeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, SimulationLeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SimulationLeaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SimulationLeaderboards
     * const simulationLeaderboards = await prisma.simulationLeaderboard.findMany()
     * 
     * // Get first 10 SimulationLeaderboards
     * const simulationLeaderboards = await prisma.simulationLeaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const simulationLeaderboardWithIdOnly = await prisma.simulationLeaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SimulationLeaderboardFindManyArgs>(args?: SelectSubset<T, SimulationLeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SimulationLeaderboard.
     * @param {SimulationLeaderboardCreateArgs} args - Arguments to create a SimulationLeaderboard.
     * @example
     * // Create one SimulationLeaderboard
     * const SimulationLeaderboard = await prisma.simulationLeaderboard.create({
     *   data: {
     *     // ... data to create a SimulationLeaderboard
     *   }
     * })
     * 
     */
    create<T extends SimulationLeaderboardCreateArgs>(args: SelectSubset<T, SimulationLeaderboardCreateArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SimulationLeaderboards.
     * @param {SimulationLeaderboardCreateManyArgs} args - Arguments to create many SimulationLeaderboards.
     * @example
     * // Create many SimulationLeaderboards
     * const simulationLeaderboard = await prisma.simulationLeaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SimulationLeaderboardCreateManyArgs>(args?: SelectSubset<T, SimulationLeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SimulationLeaderboards and returns the data saved in the database.
     * @param {SimulationLeaderboardCreateManyAndReturnArgs} args - Arguments to create many SimulationLeaderboards.
     * @example
     * // Create many SimulationLeaderboards
     * const simulationLeaderboard = await prisma.simulationLeaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SimulationLeaderboards and only return the `id`
     * const simulationLeaderboardWithIdOnly = await prisma.simulationLeaderboard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SimulationLeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, SimulationLeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SimulationLeaderboard.
     * @param {SimulationLeaderboardDeleteArgs} args - Arguments to delete one SimulationLeaderboard.
     * @example
     * // Delete one SimulationLeaderboard
     * const SimulationLeaderboard = await prisma.simulationLeaderboard.delete({
     *   where: {
     *     // ... filter to delete one SimulationLeaderboard
     *   }
     * })
     * 
     */
    delete<T extends SimulationLeaderboardDeleteArgs>(args: SelectSubset<T, SimulationLeaderboardDeleteArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SimulationLeaderboard.
     * @param {SimulationLeaderboardUpdateArgs} args - Arguments to update one SimulationLeaderboard.
     * @example
     * // Update one SimulationLeaderboard
     * const simulationLeaderboard = await prisma.simulationLeaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SimulationLeaderboardUpdateArgs>(args: SelectSubset<T, SimulationLeaderboardUpdateArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SimulationLeaderboards.
     * @param {SimulationLeaderboardDeleteManyArgs} args - Arguments to filter SimulationLeaderboards to delete.
     * @example
     * // Delete a few SimulationLeaderboards
     * const { count } = await prisma.simulationLeaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SimulationLeaderboardDeleteManyArgs>(args?: SelectSubset<T, SimulationLeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SimulationLeaderboards
     * const simulationLeaderboard = await prisma.simulationLeaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SimulationLeaderboardUpdateManyArgs>(args: SelectSubset<T, SimulationLeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SimulationLeaderboards and returns the data updated in the database.
     * @param {SimulationLeaderboardUpdateManyAndReturnArgs} args - Arguments to update many SimulationLeaderboards.
     * @example
     * // Update many SimulationLeaderboards
     * const simulationLeaderboard = await prisma.simulationLeaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SimulationLeaderboards and only return the `id`
     * const simulationLeaderboardWithIdOnly = await prisma.simulationLeaderboard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SimulationLeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, SimulationLeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SimulationLeaderboard.
     * @param {SimulationLeaderboardUpsertArgs} args - Arguments to update or create a SimulationLeaderboard.
     * @example
     * // Update or create a SimulationLeaderboard
     * const simulationLeaderboard = await prisma.simulationLeaderboard.upsert({
     *   create: {
     *     // ... data to create a SimulationLeaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SimulationLeaderboard we want to update
     *   }
     * })
     */
    upsert<T extends SimulationLeaderboardUpsertArgs>(args: SelectSubset<T, SimulationLeaderboardUpsertArgs<ExtArgs>>): Prisma__SimulationLeaderboardClient<$Result.GetResult<Prisma.$SimulationLeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SimulationLeaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardCountArgs} args - Arguments to filter SimulationLeaderboards to count.
     * @example
     * // Count the number of SimulationLeaderboards
     * const count = await prisma.simulationLeaderboard.count({
     *   where: {
     *     // ... the filter for the SimulationLeaderboards we want to count
     *   }
     * })
    **/
    count<T extends SimulationLeaderboardCountArgs>(
      args?: Subset<T, SimulationLeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SimulationLeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SimulationLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SimulationLeaderboardAggregateArgs>(args: Subset<T, SimulationLeaderboardAggregateArgs>): Prisma.PrismaPromise<GetSimulationLeaderboardAggregateType<T>>

    /**
     * Group by SimulationLeaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SimulationLeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SimulationLeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SimulationLeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: SimulationLeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SimulationLeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSimulationLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SimulationLeaderboard model
   */
  readonly fields: SimulationLeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SimulationLeaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SimulationLeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    simulation<T extends SimulationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SimulationDefaultArgs<ExtArgs>>): Prisma__SimulationClient<$Result.GetResult<Prisma.$SimulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SimulationLeaderboard model
   */
  interface SimulationLeaderboardFieldRefs {
    readonly id: FieldRef<"SimulationLeaderboard", 'String'>
    readonly simulationId: FieldRef<"SimulationLeaderboard", 'String'>
    readonly userId: FieldRef<"SimulationLeaderboard", 'String'>
    readonly rank: FieldRef<"SimulationLeaderboard", 'Int'>
    readonly totalReturn: FieldRef<"SimulationLeaderboard", 'Decimal'>
    readonly roiPercent: FieldRef<"SimulationLeaderboard", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SimulationLeaderboard findUnique
   */
  export type SimulationLeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which SimulationLeaderboard to fetch.
     */
    where: SimulationLeaderboardWhereUniqueInput
  }

  /**
   * SimulationLeaderboard findUniqueOrThrow
   */
  export type SimulationLeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which SimulationLeaderboard to fetch.
     */
    where: SimulationLeaderboardWhereUniqueInput
  }

  /**
   * SimulationLeaderboard findFirst
   */
  export type SimulationLeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which SimulationLeaderboard to fetch.
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationLeaderboards to fetch.
     */
    orderBy?: SimulationLeaderboardOrderByWithRelationInput | SimulationLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationLeaderboards.
     */
    cursor?: SimulationLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationLeaderboards.
     */
    distinct?: SimulationLeaderboardScalarFieldEnum | SimulationLeaderboardScalarFieldEnum[]
  }

  /**
   * SimulationLeaderboard findFirstOrThrow
   */
  export type SimulationLeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which SimulationLeaderboard to fetch.
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationLeaderboards to fetch.
     */
    orderBy?: SimulationLeaderboardOrderByWithRelationInput | SimulationLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SimulationLeaderboards.
     */
    cursor?: SimulationLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationLeaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SimulationLeaderboards.
     */
    distinct?: SimulationLeaderboardScalarFieldEnum | SimulationLeaderboardScalarFieldEnum[]
  }

  /**
   * SimulationLeaderboard findMany
   */
  export type SimulationLeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which SimulationLeaderboards to fetch.
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SimulationLeaderboards to fetch.
     */
    orderBy?: SimulationLeaderboardOrderByWithRelationInput | SimulationLeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SimulationLeaderboards.
     */
    cursor?: SimulationLeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SimulationLeaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SimulationLeaderboards.
     */
    skip?: number
    distinct?: SimulationLeaderboardScalarFieldEnum | SimulationLeaderboardScalarFieldEnum[]
  }

  /**
   * SimulationLeaderboard create
   */
  export type SimulationLeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a SimulationLeaderboard.
     */
    data: XOR<SimulationLeaderboardCreateInput, SimulationLeaderboardUncheckedCreateInput>
  }

  /**
   * SimulationLeaderboard createMany
   */
  export type SimulationLeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SimulationLeaderboards.
     */
    data: SimulationLeaderboardCreateManyInput | SimulationLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SimulationLeaderboard createManyAndReturn
   */
  export type SimulationLeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many SimulationLeaderboards.
     */
    data: SimulationLeaderboardCreateManyInput | SimulationLeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationLeaderboard update
   */
  export type SimulationLeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a SimulationLeaderboard.
     */
    data: XOR<SimulationLeaderboardUpdateInput, SimulationLeaderboardUncheckedUpdateInput>
    /**
     * Choose, which SimulationLeaderboard to update.
     */
    where: SimulationLeaderboardWhereUniqueInput
  }

  /**
   * SimulationLeaderboard updateMany
   */
  export type SimulationLeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SimulationLeaderboards.
     */
    data: XOR<SimulationLeaderboardUpdateManyMutationInput, SimulationLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which SimulationLeaderboards to update
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * Limit how many SimulationLeaderboards to update.
     */
    limit?: number
  }

  /**
   * SimulationLeaderboard updateManyAndReturn
   */
  export type SimulationLeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update SimulationLeaderboards.
     */
    data: XOR<SimulationLeaderboardUpdateManyMutationInput, SimulationLeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which SimulationLeaderboards to update
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * Limit how many SimulationLeaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SimulationLeaderboard upsert
   */
  export type SimulationLeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the SimulationLeaderboard to update in case it exists.
     */
    where: SimulationLeaderboardWhereUniqueInput
    /**
     * In case the SimulationLeaderboard found by the `where` argument doesn't exist, create a new SimulationLeaderboard with this data.
     */
    create: XOR<SimulationLeaderboardCreateInput, SimulationLeaderboardUncheckedCreateInput>
    /**
     * In case the SimulationLeaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SimulationLeaderboardUpdateInput, SimulationLeaderboardUncheckedUpdateInput>
  }

  /**
   * SimulationLeaderboard delete
   */
  export type SimulationLeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
    /**
     * Filter which SimulationLeaderboard to delete.
     */
    where: SimulationLeaderboardWhereUniqueInput
  }

  /**
   * SimulationLeaderboard deleteMany
   */
  export type SimulationLeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SimulationLeaderboards to delete
     */
    where?: SimulationLeaderboardWhereInput
    /**
     * Limit how many SimulationLeaderboards to delete.
     */
    limit?: number
  }

  /**
   * SimulationLeaderboard without action
   */
  export type SimulationLeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SimulationLeaderboard
     */
    select?: SimulationLeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SimulationLeaderboard
     */
    omit?: SimulationLeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SimulationLeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model DealMatching
   */

  export type AggregateDealMatching = {
    _count: DealMatchingCountAggregateOutputType | null
    _avg: DealMatchingAvgAggregateOutputType | null
    _sum: DealMatchingSumAggregateOutputType | null
    _min: DealMatchingMinAggregateOutputType | null
    _max: DealMatchingMaxAggregateOutputType | null
  }

  export type DealMatchingAvgAggregateOutputType = {
    matchScore: Decimal | null
  }

  export type DealMatchingSumAggregateOutputType = {
    matchScore: Decimal | null
  }

  export type DealMatchingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startupId: string | null
    tokenId: string | null
    matchScore: Decimal | null
    reasoning: string | null
    isRecommended: boolean | null
    userFeedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMatchingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startupId: string | null
    tokenId: string | null
    matchScore: Decimal | null
    reasoning: string | null
    isRecommended: boolean | null
    userFeedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMatchingCountAggregateOutputType = {
    id: number
    userId: number
    startupId: number
    tokenId: number
    matchScore: number
    reasoning: number
    isRecommended: number
    userFeedback: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealMatchingAvgAggregateInputType = {
    matchScore?: true
  }

  export type DealMatchingSumAggregateInputType = {
    matchScore?: true
  }

  export type DealMatchingMinAggregateInputType = {
    id?: true
    userId?: true
    startupId?: true
    tokenId?: true
    matchScore?: true
    reasoning?: true
    isRecommended?: true
    userFeedback?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMatchingMaxAggregateInputType = {
    id?: true
    userId?: true
    startupId?: true
    tokenId?: true
    matchScore?: true
    reasoning?: true
    isRecommended?: true
    userFeedback?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMatchingCountAggregateInputType = {
    id?: true
    userId?: true
    startupId?: true
    tokenId?: true
    matchScore?: true
    reasoning?: true
    isRecommended?: true
    userFeedback?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealMatchingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealMatching to aggregate.
     */
    where?: DealMatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealMatchings to fetch.
     */
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealMatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealMatchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealMatchings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DealMatchings
    **/
    _count?: true | DealMatchingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealMatchingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealMatchingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMatchingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMatchingMaxAggregateInputType
  }

  export type GetDealMatchingAggregateType<T extends DealMatchingAggregateArgs> = {
        [P in keyof T & keyof AggregateDealMatching]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealMatching[P]>
      : GetScalarType<T[P], AggregateDealMatching[P]>
  }




  export type DealMatchingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealMatchingWhereInput
    orderBy?: DealMatchingOrderByWithAggregationInput | DealMatchingOrderByWithAggregationInput[]
    by: DealMatchingScalarFieldEnum[] | DealMatchingScalarFieldEnum
    having?: DealMatchingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealMatchingCountAggregateInputType | true
    _avg?: DealMatchingAvgAggregateInputType
    _sum?: DealMatchingSumAggregateInputType
    _min?: DealMatchingMinAggregateInputType
    _max?: DealMatchingMaxAggregateInputType
  }

  export type DealMatchingGroupByOutputType = {
    id: string
    userId: string
    startupId: string | null
    tokenId: string | null
    matchScore: Decimal
    reasoning: string
    isRecommended: boolean
    userFeedback: string | null
    createdAt: Date
    updatedAt: Date
    _count: DealMatchingCountAggregateOutputType | null
    _avg: DealMatchingAvgAggregateOutputType | null
    _sum: DealMatchingSumAggregateOutputType | null
    _min: DealMatchingMinAggregateOutputType | null
    _max: DealMatchingMaxAggregateOutputType | null
  }

  type GetDealMatchingGroupByPayload<T extends DealMatchingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealMatchingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealMatchingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealMatchingGroupByOutputType[P]>
            : GetScalarType<T[P], DealMatchingGroupByOutputType[P]>
        }
      >
    >


  export type DealMatchingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    matchScore?: boolean
    reasoning?: boolean
    isRecommended?: boolean
    userFeedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | DealMatching$startupArgs<ExtArgs>
    token?: boolean | DealMatching$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["dealMatching"]>

  export type DealMatchingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    matchScore?: boolean
    reasoning?: boolean
    isRecommended?: boolean
    userFeedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | DealMatching$startupArgs<ExtArgs>
    token?: boolean | DealMatching$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["dealMatching"]>

  export type DealMatchingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    matchScore?: boolean
    reasoning?: boolean
    isRecommended?: boolean
    userFeedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | DealMatching$startupArgs<ExtArgs>
    token?: boolean | DealMatching$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["dealMatching"]>

  export type DealMatchingSelectScalar = {
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    matchScore?: boolean
    reasoning?: boolean
    isRecommended?: boolean
    userFeedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealMatchingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startupId" | "tokenId" | "matchScore" | "reasoning" | "isRecommended" | "userFeedback" | "createdAt" | "updatedAt", ExtArgs["result"]["dealMatching"]>
  export type DealMatchingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | DealMatching$startupArgs<ExtArgs>
    token?: boolean | DealMatching$tokenArgs<ExtArgs>
  }
  export type DealMatchingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | DealMatching$startupArgs<ExtArgs>
    token?: boolean | DealMatching$tokenArgs<ExtArgs>
  }
  export type DealMatchingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | DealMatching$startupArgs<ExtArgs>
    token?: boolean | DealMatching$tokenArgs<ExtArgs>
  }

  export type $DealMatchingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DealMatching"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      startup: Prisma.$StartupPayload<ExtArgs> | null
      token: Prisma.$TokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startupId: string | null
      tokenId: string | null
      matchScore: Prisma.Decimal
      reasoning: string
      isRecommended: boolean
      userFeedback: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dealMatching"]>
    composites: {}
  }

  type DealMatchingGetPayload<S extends boolean | null | undefined | DealMatchingDefaultArgs> = $Result.GetResult<Prisma.$DealMatchingPayload, S>

  type DealMatchingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealMatchingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealMatchingCountAggregateInputType | true
    }

  export interface DealMatchingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DealMatching'], meta: { name: 'DealMatching' } }
    /**
     * Find zero or one DealMatching that matches the filter.
     * @param {DealMatchingFindUniqueArgs} args - Arguments to find a DealMatching
     * @example
     * // Get one DealMatching
     * const dealMatching = await prisma.dealMatching.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealMatchingFindUniqueArgs>(args: SelectSubset<T, DealMatchingFindUniqueArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DealMatching that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealMatchingFindUniqueOrThrowArgs} args - Arguments to find a DealMatching
     * @example
     * // Get one DealMatching
     * const dealMatching = await prisma.dealMatching.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealMatchingFindUniqueOrThrowArgs>(args: SelectSubset<T, DealMatchingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DealMatching that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingFindFirstArgs} args - Arguments to find a DealMatching
     * @example
     * // Get one DealMatching
     * const dealMatching = await prisma.dealMatching.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealMatchingFindFirstArgs>(args?: SelectSubset<T, DealMatchingFindFirstArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DealMatching that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingFindFirstOrThrowArgs} args - Arguments to find a DealMatching
     * @example
     * // Get one DealMatching
     * const dealMatching = await prisma.dealMatching.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealMatchingFindFirstOrThrowArgs>(args?: SelectSubset<T, DealMatchingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DealMatchings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DealMatchings
     * const dealMatchings = await prisma.dealMatching.findMany()
     * 
     * // Get first 10 DealMatchings
     * const dealMatchings = await prisma.dealMatching.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealMatchingWithIdOnly = await prisma.dealMatching.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealMatchingFindManyArgs>(args?: SelectSubset<T, DealMatchingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DealMatching.
     * @param {DealMatchingCreateArgs} args - Arguments to create a DealMatching.
     * @example
     * // Create one DealMatching
     * const DealMatching = await prisma.dealMatching.create({
     *   data: {
     *     // ... data to create a DealMatching
     *   }
     * })
     * 
     */
    create<T extends DealMatchingCreateArgs>(args: SelectSubset<T, DealMatchingCreateArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DealMatchings.
     * @param {DealMatchingCreateManyArgs} args - Arguments to create many DealMatchings.
     * @example
     * // Create many DealMatchings
     * const dealMatching = await prisma.dealMatching.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealMatchingCreateManyArgs>(args?: SelectSubset<T, DealMatchingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DealMatchings and returns the data saved in the database.
     * @param {DealMatchingCreateManyAndReturnArgs} args - Arguments to create many DealMatchings.
     * @example
     * // Create many DealMatchings
     * const dealMatching = await prisma.dealMatching.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DealMatchings and only return the `id`
     * const dealMatchingWithIdOnly = await prisma.dealMatching.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealMatchingCreateManyAndReturnArgs>(args?: SelectSubset<T, DealMatchingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DealMatching.
     * @param {DealMatchingDeleteArgs} args - Arguments to delete one DealMatching.
     * @example
     * // Delete one DealMatching
     * const DealMatching = await prisma.dealMatching.delete({
     *   where: {
     *     // ... filter to delete one DealMatching
     *   }
     * })
     * 
     */
    delete<T extends DealMatchingDeleteArgs>(args: SelectSubset<T, DealMatchingDeleteArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DealMatching.
     * @param {DealMatchingUpdateArgs} args - Arguments to update one DealMatching.
     * @example
     * // Update one DealMatching
     * const dealMatching = await prisma.dealMatching.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealMatchingUpdateArgs>(args: SelectSubset<T, DealMatchingUpdateArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DealMatchings.
     * @param {DealMatchingDeleteManyArgs} args - Arguments to filter DealMatchings to delete.
     * @example
     * // Delete a few DealMatchings
     * const { count } = await prisma.dealMatching.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealMatchingDeleteManyArgs>(args?: SelectSubset<T, DealMatchingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealMatchings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DealMatchings
     * const dealMatching = await prisma.dealMatching.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealMatchingUpdateManyArgs>(args: SelectSubset<T, DealMatchingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealMatchings and returns the data updated in the database.
     * @param {DealMatchingUpdateManyAndReturnArgs} args - Arguments to update many DealMatchings.
     * @example
     * // Update many DealMatchings
     * const dealMatching = await prisma.dealMatching.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DealMatchings and only return the `id`
     * const dealMatchingWithIdOnly = await prisma.dealMatching.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DealMatchingUpdateManyAndReturnArgs>(args: SelectSubset<T, DealMatchingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DealMatching.
     * @param {DealMatchingUpsertArgs} args - Arguments to update or create a DealMatching.
     * @example
     * // Update or create a DealMatching
     * const dealMatching = await prisma.dealMatching.upsert({
     *   create: {
     *     // ... data to create a DealMatching
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DealMatching we want to update
     *   }
     * })
     */
    upsert<T extends DealMatchingUpsertArgs>(args: SelectSubset<T, DealMatchingUpsertArgs<ExtArgs>>): Prisma__DealMatchingClient<$Result.GetResult<Prisma.$DealMatchingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DealMatchings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingCountArgs} args - Arguments to filter DealMatchings to count.
     * @example
     * // Count the number of DealMatchings
     * const count = await prisma.dealMatching.count({
     *   where: {
     *     // ... the filter for the DealMatchings we want to count
     *   }
     * })
    **/
    count<T extends DealMatchingCountArgs>(
      args?: Subset<T, DealMatchingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealMatchingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DealMatching.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealMatchingAggregateArgs>(args: Subset<T, DealMatchingAggregateArgs>): Prisma.PrismaPromise<GetDealMatchingAggregateType<T>>

    /**
     * Group by DealMatching.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealMatchingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealMatchingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealMatchingGroupByArgs['orderBy'] }
        : { orderBy?: DealMatchingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealMatchingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealMatchingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DealMatching model
   */
  readonly fields: DealMatchingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DealMatching.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealMatchingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    startup<T extends DealMatching$startupArgs<ExtArgs> = {}>(args?: Subset<T, DealMatching$startupArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    token<T extends DealMatching$tokenArgs<ExtArgs> = {}>(args?: Subset<T, DealMatching$tokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DealMatching model
   */
  interface DealMatchingFieldRefs {
    readonly id: FieldRef<"DealMatching", 'String'>
    readonly userId: FieldRef<"DealMatching", 'String'>
    readonly startupId: FieldRef<"DealMatching", 'String'>
    readonly tokenId: FieldRef<"DealMatching", 'String'>
    readonly matchScore: FieldRef<"DealMatching", 'Decimal'>
    readonly reasoning: FieldRef<"DealMatching", 'String'>
    readonly isRecommended: FieldRef<"DealMatching", 'Boolean'>
    readonly userFeedback: FieldRef<"DealMatching", 'String'>
    readonly createdAt: FieldRef<"DealMatching", 'DateTime'>
    readonly updatedAt: FieldRef<"DealMatching", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DealMatching findUnique
   */
  export type DealMatchingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * Filter, which DealMatching to fetch.
     */
    where: DealMatchingWhereUniqueInput
  }

  /**
   * DealMatching findUniqueOrThrow
   */
  export type DealMatchingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * Filter, which DealMatching to fetch.
     */
    where: DealMatchingWhereUniqueInput
  }

  /**
   * DealMatching findFirst
   */
  export type DealMatchingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * Filter, which DealMatching to fetch.
     */
    where?: DealMatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealMatchings to fetch.
     */
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealMatchings.
     */
    cursor?: DealMatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealMatchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealMatchings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealMatchings.
     */
    distinct?: DealMatchingScalarFieldEnum | DealMatchingScalarFieldEnum[]
  }

  /**
   * DealMatching findFirstOrThrow
   */
  export type DealMatchingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * Filter, which DealMatching to fetch.
     */
    where?: DealMatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealMatchings to fetch.
     */
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealMatchings.
     */
    cursor?: DealMatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealMatchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealMatchings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealMatchings.
     */
    distinct?: DealMatchingScalarFieldEnum | DealMatchingScalarFieldEnum[]
  }

  /**
   * DealMatching findMany
   */
  export type DealMatchingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * Filter, which DealMatchings to fetch.
     */
    where?: DealMatchingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealMatchings to fetch.
     */
    orderBy?: DealMatchingOrderByWithRelationInput | DealMatchingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DealMatchings.
     */
    cursor?: DealMatchingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealMatchings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealMatchings.
     */
    skip?: number
    distinct?: DealMatchingScalarFieldEnum | DealMatchingScalarFieldEnum[]
  }

  /**
   * DealMatching create
   */
  export type DealMatchingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * The data needed to create a DealMatching.
     */
    data: XOR<DealMatchingCreateInput, DealMatchingUncheckedCreateInput>
  }

  /**
   * DealMatching createMany
   */
  export type DealMatchingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DealMatchings.
     */
    data: DealMatchingCreateManyInput | DealMatchingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DealMatching createManyAndReturn
   */
  export type DealMatchingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * The data used to create many DealMatchings.
     */
    data: DealMatchingCreateManyInput | DealMatchingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DealMatching update
   */
  export type DealMatchingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * The data needed to update a DealMatching.
     */
    data: XOR<DealMatchingUpdateInput, DealMatchingUncheckedUpdateInput>
    /**
     * Choose, which DealMatching to update.
     */
    where: DealMatchingWhereUniqueInput
  }

  /**
   * DealMatching updateMany
   */
  export type DealMatchingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DealMatchings.
     */
    data: XOR<DealMatchingUpdateManyMutationInput, DealMatchingUncheckedUpdateManyInput>
    /**
     * Filter which DealMatchings to update
     */
    where?: DealMatchingWhereInput
    /**
     * Limit how many DealMatchings to update.
     */
    limit?: number
  }

  /**
   * DealMatching updateManyAndReturn
   */
  export type DealMatchingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * The data used to update DealMatchings.
     */
    data: XOR<DealMatchingUpdateManyMutationInput, DealMatchingUncheckedUpdateManyInput>
    /**
     * Filter which DealMatchings to update
     */
    where?: DealMatchingWhereInput
    /**
     * Limit how many DealMatchings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DealMatching upsert
   */
  export type DealMatchingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * The filter to search for the DealMatching to update in case it exists.
     */
    where: DealMatchingWhereUniqueInput
    /**
     * In case the DealMatching found by the `where` argument doesn't exist, create a new DealMatching with this data.
     */
    create: XOR<DealMatchingCreateInput, DealMatchingUncheckedCreateInput>
    /**
     * In case the DealMatching was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealMatchingUpdateInput, DealMatchingUncheckedUpdateInput>
  }

  /**
   * DealMatching delete
   */
  export type DealMatchingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
    /**
     * Filter which DealMatching to delete.
     */
    where: DealMatchingWhereUniqueInput
  }

  /**
   * DealMatching deleteMany
   */
  export type DealMatchingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealMatchings to delete
     */
    where?: DealMatchingWhereInput
    /**
     * Limit how many DealMatchings to delete.
     */
    limit?: number
  }

  /**
   * DealMatching.startup
   */
  export type DealMatching$startupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
  }

  /**
   * DealMatching.token
   */
  export type DealMatching$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * DealMatching without action
   */
  export type DealMatchingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealMatching
     */
    select?: DealMatchingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DealMatching
     */
    omit?: DealMatchingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealMatchingInclude<ExtArgs> | null
  }


  /**
   * Model LearningModule
   */

  export type AggregateLearningModule = {
    _count: LearningModuleCountAggregateOutputType | null
    _avg: LearningModuleAvgAggregateOutputType | null
    _sum: LearningModuleSumAggregateOutputType | null
    _min: LearningModuleMinAggregateOutputType | null
    _max: LearningModuleMaxAggregateOutputType | null
  }

  export type LearningModuleAvgAggregateOutputType = {
    difficulty: number | null
    order: number | null
  }

  export type LearningModuleSumAggregateOutputType = {
    difficulty: number | null
    order: number | null
  }

  export type LearningModuleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    category: string | null
    difficulty: number | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningModuleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    category: string | null
    difficulty: number | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningModuleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    category: number
    difficulty: number
    order: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LearningModuleAvgAggregateInputType = {
    difficulty?: true
    order?: true
  }

  export type LearningModuleSumAggregateInputType = {
    difficulty?: true
    order?: true
  }

  export type LearningModuleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    category?: true
    difficulty?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningModuleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    category?: true
    difficulty?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningModuleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    category?: true
    difficulty?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LearningModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningModule to aggregate.
     */
    where?: LearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningModules to fetch.
     */
    orderBy?: LearningModuleOrderByWithRelationInput | LearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningModules
    **/
    _count?: true | LearningModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningModuleMaxAggregateInputType
  }

  export type GetLearningModuleAggregateType<T extends LearningModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningModule[P]>
      : GetScalarType<T[P], AggregateLearningModule[P]>
  }




  export type LearningModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningModuleWhereInput
    orderBy?: LearningModuleOrderByWithAggregationInput | LearningModuleOrderByWithAggregationInput[]
    by: LearningModuleScalarFieldEnum[] | LearningModuleScalarFieldEnum
    having?: LearningModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningModuleCountAggregateInputType | true
    _avg?: LearningModuleAvgAggregateInputType
    _sum?: LearningModuleSumAggregateInputType
    _min?: LearningModuleMinAggregateInputType
    _max?: LearningModuleMaxAggregateInputType
  }

  export type LearningModuleGroupByOutputType = {
    id: string
    title: string
    description: string
    content: string
    category: string
    difficulty: number
    order: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LearningModuleCountAggregateOutputType | null
    _avg: LearningModuleAvgAggregateOutputType | null
    _sum: LearningModuleSumAggregateOutputType | null
    _min: LearningModuleMinAggregateOutputType | null
    _max: LearningModuleMaxAggregateOutputType | null
  }

  type GetLearningModuleGroupByPayload<T extends LearningModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningModuleGroupByOutputType[P]>
            : GetScalarType<T[P], LearningModuleGroupByOutputType[P]>
        }
      >
    >


  export type LearningModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    difficulty?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userLearningModules?: boolean | LearningModule$userLearningModulesArgs<ExtArgs>
    _count?: boolean | LearningModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningModule"]>

  export type LearningModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    difficulty?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["learningModule"]>

  export type LearningModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    difficulty?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["learningModule"]>

  export type LearningModuleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    difficulty?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LearningModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "category" | "difficulty" | "order" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["learningModule"]>
  export type LearningModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLearningModules?: boolean | LearningModule$userLearningModulesArgs<ExtArgs>
    _count?: boolean | LearningModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LearningModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LearningModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningModule"
    objects: {
      userLearningModules: Prisma.$UserLearningModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      content: string
      category: string
      difficulty: number
      order: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["learningModule"]>
    composites: {}
  }

  type LearningModuleGetPayload<S extends boolean | null | undefined | LearningModuleDefaultArgs> = $Result.GetResult<Prisma.$LearningModulePayload, S>

  type LearningModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningModuleCountAggregateInputType | true
    }

  export interface LearningModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningModule'], meta: { name: 'LearningModule' } }
    /**
     * Find zero or one LearningModule that matches the filter.
     * @param {LearningModuleFindUniqueArgs} args - Arguments to find a LearningModule
     * @example
     * // Get one LearningModule
     * const learningModule = await prisma.learningModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningModuleFindUniqueArgs>(args: SelectSubset<T, LearningModuleFindUniqueArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningModuleFindUniqueOrThrowArgs} args - Arguments to find a LearningModule
     * @example
     * // Get one LearningModule
     * const learningModule = await prisma.learningModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleFindFirstArgs} args - Arguments to find a LearningModule
     * @example
     * // Get one LearningModule
     * const learningModule = await prisma.learningModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningModuleFindFirstArgs>(args?: SelectSubset<T, LearningModuleFindFirstArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleFindFirstOrThrowArgs} args - Arguments to find a LearningModule
     * @example
     * // Get one LearningModule
     * const learningModule = await prisma.learningModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningModules
     * const learningModules = await prisma.learningModule.findMany()
     * 
     * // Get first 10 LearningModules
     * const learningModules = await prisma.learningModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningModuleWithIdOnly = await prisma.learningModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningModuleFindManyArgs>(args?: SelectSubset<T, LearningModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningModule.
     * @param {LearningModuleCreateArgs} args - Arguments to create a LearningModule.
     * @example
     * // Create one LearningModule
     * const LearningModule = await prisma.learningModule.create({
     *   data: {
     *     // ... data to create a LearningModule
     *   }
     * })
     * 
     */
    create<T extends LearningModuleCreateArgs>(args: SelectSubset<T, LearningModuleCreateArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningModules.
     * @param {LearningModuleCreateManyArgs} args - Arguments to create many LearningModules.
     * @example
     * // Create many LearningModules
     * const learningModule = await prisma.learningModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningModuleCreateManyArgs>(args?: SelectSubset<T, LearningModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningModules and returns the data saved in the database.
     * @param {LearningModuleCreateManyAndReturnArgs} args - Arguments to create many LearningModules.
     * @example
     * // Create many LearningModules
     * const learningModule = await prisma.learningModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningModules and only return the `id`
     * const learningModuleWithIdOnly = await prisma.learningModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningModule.
     * @param {LearningModuleDeleteArgs} args - Arguments to delete one LearningModule.
     * @example
     * // Delete one LearningModule
     * const LearningModule = await prisma.learningModule.delete({
     *   where: {
     *     // ... filter to delete one LearningModule
     *   }
     * })
     * 
     */
    delete<T extends LearningModuleDeleteArgs>(args: SelectSubset<T, LearningModuleDeleteArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningModule.
     * @param {LearningModuleUpdateArgs} args - Arguments to update one LearningModule.
     * @example
     * // Update one LearningModule
     * const learningModule = await prisma.learningModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningModuleUpdateArgs>(args: SelectSubset<T, LearningModuleUpdateArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningModules.
     * @param {LearningModuleDeleteManyArgs} args - Arguments to filter LearningModules to delete.
     * @example
     * // Delete a few LearningModules
     * const { count } = await prisma.learningModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningModuleDeleteManyArgs>(args?: SelectSubset<T, LearningModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningModules
     * const learningModule = await prisma.learningModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningModuleUpdateManyArgs>(args: SelectSubset<T, LearningModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningModules and returns the data updated in the database.
     * @param {LearningModuleUpdateManyAndReturnArgs} args - Arguments to update many LearningModules.
     * @example
     * // Update many LearningModules
     * const learningModule = await prisma.learningModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningModules and only return the `id`
     * const learningModuleWithIdOnly = await prisma.learningModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningModule.
     * @param {LearningModuleUpsertArgs} args - Arguments to update or create a LearningModule.
     * @example
     * // Update or create a LearningModule
     * const learningModule = await prisma.learningModule.upsert({
     *   create: {
     *     // ... data to create a LearningModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningModule we want to update
     *   }
     * })
     */
    upsert<T extends LearningModuleUpsertArgs>(args: SelectSubset<T, LearningModuleUpsertArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleCountArgs} args - Arguments to filter LearningModules to count.
     * @example
     * // Count the number of LearningModules
     * const count = await prisma.learningModule.count({
     *   where: {
     *     // ... the filter for the LearningModules we want to count
     *   }
     * })
    **/
    count<T extends LearningModuleCountArgs>(
      args?: Subset<T, LearningModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningModuleAggregateArgs>(args: Subset<T, LearningModuleAggregateArgs>): Prisma.PrismaPromise<GetLearningModuleAggregateType<T>>

    /**
     * Group by LearningModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningModuleGroupByArgs['orderBy'] }
        : { orderBy?: LearningModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningModule model
   */
  readonly fields: LearningModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userLearningModules<T extends LearningModule$userLearningModulesArgs<ExtArgs> = {}>(args?: Subset<T, LearningModule$userLearningModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningModule model
   */
  interface LearningModuleFieldRefs {
    readonly id: FieldRef<"LearningModule", 'String'>
    readonly title: FieldRef<"LearningModule", 'String'>
    readonly description: FieldRef<"LearningModule", 'String'>
    readonly content: FieldRef<"LearningModule", 'String'>
    readonly category: FieldRef<"LearningModule", 'String'>
    readonly difficulty: FieldRef<"LearningModule", 'Int'>
    readonly order: FieldRef<"LearningModule", 'Int'>
    readonly isActive: FieldRef<"LearningModule", 'Boolean'>
    readonly createdAt: FieldRef<"LearningModule", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningModule findUnique
   */
  export type LearningModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which LearningModule to fetch.
     */
    where: LearningModuleWhereUniqueInput
  }

  /**
   * LearningModule findUniqueOrThrow
   */
  export type LearningModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which LearningModule to fetch.
     */
    where: LearningModuleWhereUniqueInput
  }

  /**
   * LearningModule findFirst
   */
  export type LearningModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which LearningModule to fetch.
     */
    where?: LearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningModules to fetch.
     */
    orderBy?: LearningModuleOrderByWithRelationInput | LearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningModules.
     */
    cursor?: LearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningModules.
     */
    distinct?: LearningModuleScalarFieldEnum | LearningModuleScalarFieldEnum[]
  }

  /**
   * LearningModule findFirstOrThrow
   */
  export type LearningModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which LearningModule to fetch.
     */
    where?: LearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningModules to fetch.
     */
    orderBy?: LearningModuleOrderByWithRelationInput | LearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningModules.
     */
    cursor?: LearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningModules.
     */
    distinct?: LearningModuleScalarFieldEnum | LearningModuleScalarFieldEnum[]
  }

  /**
   * LearningModule findMany
   */
  export type LearningModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which LearningModules to fetch.
     */
    where?: LearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningModules to fetch.
     */
    orderBy?: LearningModuleOrderByWithRelationInput | LearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningModules.
     */
    cursor?: LearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningModules.
     */
    skip?: number
    distinct?: LearningModuleScalarFieldEnum | LearningModuleScalarFieldEnum[]
  }

  /**
   * LearningModule create
   */
  export type LearningModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningModule.
     */
    data: XOR<LearningModuleCreateInput, LearningModuleUncheckedCreateInput>
  }

  /**
   * LearningModule createMany
   */
  export type LearningModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningModules.
     */
    data: LearningModuleCreateManyInput | LearningModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningModule createManyAndReturn
   */
  export type LearningModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * The data used to create many LearningModules.
     */
    data: LearningModuleCreateManyInput | LearningModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningModule update
   */
  export type LearningModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningModule.
     */
    data: XOR<LearningModuleUpdateInput, LearningModuleUncheckedUpdateInput>
    /**
     * Choose, which LearningModule to update.
     */
    where: LearningModuleWhereUniqueInput
  }

  /**
   * LearningModule updateMany
   */
  export type LearningModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningModules.
     */
    data: XOR<LearningModuleUpdateManyMutationInput, LearningModuleUncheckedUpdateManyInput>
    /**
     * Filter which LearningModules to update
     */
    where?: LearningModuleWhereInput
    /**
     * Limit how many LearningModules to update.
     */
    limit?: number
  }

  /**
   * LearningModule updateManyAndReturn
   */
  export type LearningModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * The data used to update LearningModules.
     */
    data: XOR<LearningModuleUpdateManyMutationInput, LearningModuleUncheckedUpdateManyInput>
    /**
     * Filter which LearningModules to update
     */
    where?: LearningModuleWhereInput
    /**
     * Limit how many LearningModules to update.
     */
    limit?: number
  }

  /**
   * LearningModule upsert
   */
  export type LearningModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningModule to update in case it exists.
     */
    where: LearningModuleWhereUniqueInput
    /**
     * In case the LearningModule found by the `where` argument doesn't exist, create a new LearningModule with this data.
     */
    create: XOR<LearningModuleCreateInput, LearningModuleUncheckedCreateInput>
    /**
     * In case the LearningModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningModuleUpdateInput, LearningModuleUncheckedUpdateInput>
  }

  /**
   * LearningModule delete
   */
  export type LearningModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
    /**
     * Filter which LearningModule to delete.
     */
    where: LearningModuleWhereUniqueInput
  }

  /**
   * LearningModule deleteMany
   */
  export type LearningModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningModules to delete
     */
    where?: LearningModuleWhereInput
    /**
     * Limit how many LearningModules to delete.
     */
    limit?: number
  }

  /**
   * LearningModule.userLearningModules
   */
  export type LearningModule$userLearningModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    where?: UserLearningModuleWhereInput
    orderBy?: UserLearningModuleOrderByWithRelationInput | UserLearningModuleOrderByWithRelationInput[]
    cursor?: UserLearningModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLearningModuleScalarFieldEnum | UserLearningModuleScalarFieldEnum[]
  }

  /**
   * LearningModule without action
   */
  export type LearningModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningModule
     */
    select?: LearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningModule
     */
    omit?: LearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningModuleInclude<ExtArgs> | null
  }


  /**
   * Model UserLearningModule
   */

  export type AggregateUserLearningModule = {
    _count: UserLearningModuleCountAggregateOutputType | null
    _avg: UserLearningModuleAvgAggregateOutputType | null
    _sum: UserLearningModuleSumAggregateOutputType | null
    _min: UserLearningModuleMinAggregateOutputType | null
    _max: UserLearningModuleMaxAggregateOutputType | null
  }

  export type UserLearningModuleAvgAggregateOutputType = {
    score: number | null
  }

  export type UserLearningModuleSumAggregateOutputType = {
    score: number | null
  }

  export type UserLearningModuleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    learningModuleId: string | null
    completed: boolean | null
    score: number | null
    completedAt: Date | null
  }

  export type UserLearningModuleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    learningModuleId: string | null
    completed: boolean | null
    score: number | null
    completedAt: Date | null
  }

  export type UserLearningModuleCountAggregateOutputType = {
    id: number
    userId: number
    learningModuleId: number
    completed: number
    score: number
    completedAt: number
    _all: number
  }


  export type UserLearningModuleAvgAggregateInputType = {
    score?: true
  }

  export type UserLearningModuleSumAggregateInputType = {
    score?: true
  }

  export type UserLearningModuleMinAggregateInputType = {
    id?: true
    userId?: true
    learningModuleId?: true
    completed?: true
    score?: true
    completedAt?: true
  }

  export type UserLearningModuleMaxAggregateInputType = {
    id?: true
    userId?: true
    learningModuleId?: true
    completed?: true
    score?: true
    completedAt?: true
  }

  export type UserLearningModuleCountAggregateInputType = {
    id?: true
    userId?: true
    learningModuleId?: true
    completed?: true
    score?: true
    completedAt?: true
    _all?: true
  }

  export type UserLearningModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLearningModule to aggregate.
     */
    where?: UserLearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningModules to fetch.
     */
    orderBy?: UserLearningModuleOrderByWithRelationInput | UserLearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLearningModules
    **/
    _count?: true | UserLearningModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLearningModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLearningModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLearningModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLearningModuleMaxAggregateInputType
  }

  export type GetUserLearningModuleAggregateType<T extends UserLearningModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLearningModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLearningModule[P]>
      : GetScalarType<T[P], AggregateUserLearningModule[P]>
  }




  export type UserLearningModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLearningModuleWhereInput
    orderBy?: UserLearningModuleOrderByWithAggregationInput | UserLearningModuleOrderByWithAggregationInput[]
    by: UserLearningModuleScalarFieldEnum[] | UserLearningModuleScalarFieldEnum
    having?: UserLearningModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLearningModuleCountAggregateInputType | true
    _avg?: UserLearningModuleAvgAggregateInputType
    _sum?: UserLearningModuleSumAggregateInputType
    _min?: UserLearningModuleMinAggregateInputType
    _max?: UserLearningModuleMaxAggregateInputType
  }

  export type UserLearningModuleGroupByOutputType = {
    id: string
    userId: string
    learningModuleId: string
    completed: boolean
    score: number | null
    completedAt: Date | null
    _count: UserLearningModuleCountAggregateOutputType | null
    _avg: UserLearningModuleAvgAggregateOutputType | null
    _sum: UserLearningModuleSumAggregateOutputType | null
    _min: UserLearningModuleMinAggregateOutputType | null
    _max: UserLearningModuleMaxAggregateOutputType | null
  }

  type GetUserLearningModuleGroupByPayload<T extends UserLearningModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLearningModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLearningModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLearningModuleGroupByOutputType[P]>
            : GetScalarType<T[P], UserLearningModuleGroupByOutputType[P]>
        }
      >
    >


  export type UserLearningModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningModuleId?: boolean
    completed?: boolean
    score?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningModule?: boolean | LearningModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLearningModule"]>

  export type UserLearningModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningModuleId?: boolean
    completed?: boolean
    score?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningModule?: boolean | LearningModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLearningModule"]>

  export type UserLearningModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningModuleId?: boolean
    completed?: boolean
    score?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningModule?: boolean | LearningModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLearningModule"]>

  export type UserLearningModuleSelectScalar = {
    id?: boolean
    userId?: boolean
    learningModuleId?: boolean
    completed?: boolean
    score?: boolean
    completedAt?: boolean
  }

  export type UserLearningModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "learningModuleId" | "completed" | "score" | "completedAt", ExtArgs["result"]["userLearningModule"]>
  export type UserLearningModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningModule?: boolean | LearningModuleDefaultArgs<ExtArgs>
  }
  export type UserLearningModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningModule?: boolean | LearningModuleDefaultArgs<ExtArgs>
  }
  export type UserLearningModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    learningModule?: boolean | LearningModuleDefaultArgs<ExtArgs>
  }

  export type $UserLearningModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLearningModule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      learningModule: Prisma.$LearningModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      learningModuleId: string
      completed: boolean
      score: number | null
      completedAt: Date | null
    }, ExtArgs["result"]["userLearningModule"]>
    composites: {}
  }

  type UserLearningModuleGetPayload<S extends boolean | null | undefined | UserLearningModuleDefaultArgs> = $Result.GetResult<Prisma.$UserLearningModulePayload, S>

  type UserLearningModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLearningModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLearningModuleCountAggregateInputType | true
    }

  export interface UserLearningModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLearningModule'], meta: { name: 'UserLearningModule' } }
    /**
     * Find zero or one UserLearningModule that matches the filter.
     * @param {UserLearningModuleFindUniqueArgs} args - Arguments to find a UserLearningModule
     * @example
     * // Get one UserLearningModule
     * const userLearningModule = await prisma.userLearningModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLearningModuleFindUniqueArgs>(args: SelectSubset<T, UserLearningModuleFindUniqueArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLearningModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLearningModuleFindUniqueOrThrowArgs} args - Arguments to find a UserLearningModule
     * @example
     * // Get one UserLearningModule
     * const userLearningModule = await prisma.userLearningModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLearningModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLearningModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLearningModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleFindFirstArgs} args - Arguments to find a UserLearningModule
     * @example
     * // Get one UserLearningModule
     * const userLearningModule = await prisma.userLearningModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLearningModuleFindFirstArgs>(args?: SelectSubset<T, UserLearningModuleFindFirstArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLearningModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleFindFirstOrThrowArgs} args - Arguments to find a UserLearningModule
     * @example
     * // Get one UserLearningModule
     * const userLearningModule = await prisma.userLearningModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLearningModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLearningModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLearningModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLearningModules
     * const userLearningModules = await prisma.userLearningModule.findMany()
     * 
     * // Get first 10 UserLearningModules
     * const userLearningModules = await prisma.userLearningModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLearningModuleWithIdOnly = await prisma.userLearningModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLearningModuleFindManyArgs>(args?: SelectSubset<T, UserLearningModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLearningModule.
     * @param {UserLearningModuleCreateArgs} args - Arguments to create a UserLearningModule.
     * @example
     * // Create one UserLearningModule
     * const UserLearningModule = await prisma.userLearningModule.create({
     *   data: {
     *     // ... data to create a UserLearningModule
     *   }
     * })
     * 
     */
    create<T extends UserLearningModuleCreateArgs>(args: SelectSubset<T, UserLearningModuleCreateArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLearningModules.
     * @param {UserLearningModuleCreateManyArgs} args - Arguments to create many UserLearningModules.
     * @example
     * // Create many UserLearningModules
     * const userLearningModule = await prisma.userLearningModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLearningModuleCreateManyArgs>(args?: SelectSubset<T, UserLearningModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLearningModules and returns the data saved in the database.
     * @param {UserLearningModuleCreateManyAndReturnArgs} args - Arguments to create many UserLearningModules.
     * @example
     * // Create many UserLearningModules
     * const userLearningModule = await prisma.userLearningModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLearningModules and only return the `id`
     * const userLearningModuleWithIdOnly = await prisma.userLearningModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLearningModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLearningModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLearningModule.
     * @param {UserLearningModuleDeleteArgs} args - Arguments to delete one UserLearningModule.
     * @example
     * // Delete one UserLearningModule
     * const UserLearningModule = await prisma.userLearningModule.delete({
     *   where: {
     *     // ... filter to delete one UserLearningModule
     *   }
     * })
     * 
     */
    delete<T extends UserLearningModuleDeleteArgs>(args: SelectSubset<T, UserLearningModuleDeleteArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLearningModule.
     * @param {UserLearningModuleUpdateArgs} args - Arguments to update one UserLearningModule.
     * @example
     * // Update one UserLearningModule
     * const userLearningModule = await prisma.userLearningModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLearningModuleUpdateArgs>(args: SelectSubset<T, UserLearningModuleUpdateArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLearningModules.
     * @param {UserLearningModuleDeleteManyArgs} args - Arguments to filter UserLearningModules to delete.
     * @example
     * // Delete a few UserLearningModules
     * const { count } = await prisma.userLearningModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLearningModuleDeleteManyArgs>(args?: SelectSubset<T, UserLearningModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLearningModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLearningModules
     * const userLearningModule = await prisma.userLearningModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLearningModuleUpdateManyArgs>(args: SelectSubset<T, UserLearningModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLearningModules and returns the data updated in the database.
     * @param {UserLearningModuleUpdateManyAndReturnArgs} args - Arguments to update many UserLearningModules.
     * @example
     * // Update many UserLearningModules
     * const userLearningModule = await prisma.userLearningModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLearningModules and only return the `id`
     * const userLearningModuleWithIdOnly = await prisma.userLearningModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLearningModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLearningModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLearningModule.
     * @param {UserLearningModuleUpsertArgs} args - Arguments to update or create a UserLearningModule.
     * @example
     * // Update or create a UserLearningModule
     * const userLearningModule = await prisma.userLearningModule.upsert({
     *   create: {
     *     // ... data to create a UserLearningModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLearningModule we want to update
     *   }
     * })
     */
    upsert<T extends UserLearningModuleUpsertArgs>(args: SelectSubset<T, UserLearningModuleUpsertArgs<ExtArgs>>): Prisma__UserLearningModuleClient<$Result.GetResult<Prisma.$UserLearningModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLearningModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleCountArgs} args - Arguments to filter UserLearningModules to count.
     * @example
     * // Count the number of UserLearningModules
     * const count = await prisma.userLearningModule.count({
     *   where: {
     *     // ... the filter for the UserLearningModules we want to count
     *   }
     * })
    **/
    count<T extends UserLearningModuleCountArgs>(
      args?: Subset<T, UserLearningModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLearningModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLearningModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLearningModuleAggregateArgs>(args: Subset<T, UserLearningModuleAggregateArgs>): Prisma.PrismaPromise<GetUserLearningModuleAggregateType<T>>

    /**
     * Group by UserLearningModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLearningModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLearningModuleGroupByArgs['orderBy'] }
        : { orderBy?: UserLearningModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLearningModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLearningModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLearningModule model
   */
  readonly fields: UserLearningModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLearningModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLearningModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    learningModule<T extends LearningModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningModuleDefaultArgs<ExtArgs>>): Prisma__LearningModuleClient<$Result.GetResult<Prisma.$LearningModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLearningModule model
   */
  interface UserLearningModuleFieldRefs {
    readonly id: FieldRef<"UserLearningModule", 'String'>
    readonly userId: FieldRef<"UserLearningModule", 'String'>
    readonly learningModuleId: FieldRef<"UserLearningModule", 'String'>
    readonly completed: FieldRef<"UserLearningModule", 'Boolean'>
    readonly score: FieldRef<"UserLearningModule", 'Int'>
    readonly completedAt: FieldRef<"UserLearningModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLearningModule findUnique
   */
  export type UserLearningModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserLearningModule to fetch.
     */
    where: UserLearningModuleWhereUniqueInput
  }

  /**
   * UserLearningModule findUniqueOrThrow
   */
  export type UserLearningModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserLearningModule to fetch.
     */
    where: UserLearningModuleWhereUniqueInput
  }

  /**
   * UserLearningModule findFirst
   */
  export type UserLearningModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserLearningModule to fetch.
     */
    where?: UserLearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningModules to fetch.
     */
    orderBy?: UserLearningModuleOrderByWithRelationInput | UserLearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLearningModules.
     */
    cursor?: UserLearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLearningModules.
     */
    distinct?: UserLearningModuleScalarFieldEnum | UserLearningModuleScalarFieldEnum[]
  }

  /**
   * UserLearningModule findFirstOrThrow
   */
  export type UserLearningModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserLearningModule to fetch.
     */
    where?: UserLearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningModules to fetch.
     */
    orderBy?: UserLearningModuleOrderByWithRelationInput | UserLearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLearningModules.
     */
    cursor?: UserLearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLearningModules.
     */
    distinct?: UserLearningModuleScalarFieldEnum | UserLearningModuleScalarFieldEnum[]
  }

  /**
   * UserLearningModule findMany
   */
  export type UserLearningModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserLearningModules to fetch.
     */
    where?: UserLearningModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningModules to fetch.
     */
    orderBy?: UserLearningModuleOrderByWithRelationInput | UserLearningModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLearningModules.
     */
    cursor?: UserLearningModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningModules.
     */
    skip?: number
    distinct?: UserLearningModuleScalarFieldEnum | UserLearningModuleScalarFieldEnum[]
  }

  /**
   * UserLearningModule create
   */
  export type UserLearningModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLearningModule.
     */
    data: XOR<UserLearningModuleCreateInput, UserLearningModuleUncheckedCreateInput>
  }

  /**
   * UserLearningModule createMany
   */
  export type UserLearningModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLearningModules.
     */
    data: UserLearningModuleCreateManyInput | UserLearningModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLearningModule createManyAndReturn
   */
  export type UserLearningModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * The data used to create many UserLearningModules.
     */
    data: UserLearningModuleCreateManyInput | UserLearningModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLearningModule update
   */
  export type UserLearningModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLearningModule.
     */
    data: XOR<UserLearningModuleUpdateInput, UserLearningModuleUncheckedUpdateInput>
    /**
     * Choose, which UserLearningModule to update.
     */
    where: UserLearningModuleWhereUniqueInput
  }

  /**
   * UserLearningModule updateMany
   */
  export type UserLearningModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLearningModules.
     */
    data: XOR<UserLearningModuleUpdateManyMutationInput, UserLearningModuleUncheckedUpdateManyInput>
    /**
     * Filter which UserLearningModules to update
     */
    where?: UserLearningModuleWhereInput
    /**
     * Limit how many UserLearningModules to update.
     */
    limit?: number
  }

  /**
   * UserLearningModule updateManyAndReturn
   */
  export type UserLearningModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * The data used to update UserLearningModules.
     */
    data: XOR<UserLearningModuleUpdateManyMutationInput, UserLearningModuleUncheckedUpdateManyInput>
    /**
     * Filter which UserLearningModules to update
     */
    where?: UserLearningModuleWhereInput
    /**
     * Limit how many UserLearningModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLearningModule upsert
   */
  export type UserLearningModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLearningModule to update in case it exists.
     */
    where: UserLearningModuleWhereUniqueInput
    /**
     * In case the UserLearningModule found by the `where` argument doesn't exist, create a new UserLearningModule with this data.
     */
    create: XOR<UserLearningModuleCreateInput, UserLearningModuleUncheckedCreateInput>
    /**
     * In case the UserLearningModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLearningModuleUpdateInput, UserLearningModuleUncheckedUpdateInput>
  }

  /**
   * UserLearningModule delete
   */
  export type UserLearningModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
    /**
     * Filter which UserLearningModule to delete.
     */
    where: UserLearningModuleWhereUniqueInput
  }

  /**
   * UserLearningModule deleteMany
   */
  export type UserLearningModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLearningModules to delete
     */
    where?: UserLearningModuleWhereInput
    /**
     * Limit how many UserLearningModules to delete.
     */
    limit?: number
  }

  /**
   * UserLearningModule without action
   */
  export type UserLearningModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningModule
     */
    select?: UserLearningModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLearningModule
     */
    omit?: UserLearningModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLearningModuleInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    totalScore: number | null
    currentLevel: number | null
    completedSimulations: number | null
    successfulInvestments: number | null
    averageROI: Decimal | null
    valuationSkill: number | null
    dueDiligenceSkill: number | null
    riskAssessmentSkill: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    totalScore: number | null
    currentLevel: number | null
    completedSimulations: number | null
    successfulInvestments: number | null
    averageROI: Decimal | null
    valuationSkill: number | null
    dueDiligenceSkill: number | null
    riskAssessmentSkill: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalScore: number | null
    currentLevel: number | null
    completedSimulations: number | null
    successfulInvestments: number | null
    averageROI: Decimal | null
    valuationSkill: number | null
    dueDiligenceSkill: number | null
    riskAssessmentSkill: number | null
    lastActivityAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalScore: number | null
    currentLevel: number | null
    completedSimulations: number | null
    successfulInvestments: number | null
    averageROI: Decimal | null
    valuationSkill: number | null
    dueDiligenceSkill: number | null
    riskAssessmentSkill: number | null
    lastActivityAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    totalScore: number
    currentLevel: number
    completedSimulations: number
    successfulInvestments: number
    averageROI: number
    valuationSkill: number
    dueDiligenceSkill: number
    riskAssessmentSkill: number
    lastActivityAt: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    totalScore?: true
    currentLevel?: true
    completedSimulations?: true
    successfulInvestments?: true
    averageROI?: true
    valuationSkill?: true
    dueDiligenceSkill?: true
    riskAssessmentSkill?: true
  }

  export type UserProgressSumAggregateInputType = {
    totalScore?: true
    currentLevel?: true
    completedSimulations?: true
    successfulInvestments?: true
    averageROI?: true
    valuationSkill?: true
    dueDiligenceSkill?: true
    riskAssessmentSkill?: true
  }

  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    totalScore?: true
    currentLevel?: true
    completedSimulations?: true
    successfulInvestments?: true
    averageROI?: true
    valuationSkill?: true
    dueDiligenceSkill?: true
    riskAssessmentSkill?: true
    lastActivityAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    totalScore?: true
    currentLevel?: true
    completedSimulations?: true
    successfulInvestments?: true
    averageROI?: true
    valuationSkill?: true
    dueDiligenceSkill?: true
    riskAssessmentSkill?: true
    lastActivityAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    totalScore?: true
    currentLevel?: true
    completedSimulations?: true
    successfulInvestments?: true
    averageROI?: true
    valuationSkill?: true
    dueDiligenceSkill?: true
    riskAssessmentSkill?: true
    lastActivityAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    totalScore: number
    currentLevel: number
    completedSimulations: number
    successfulInvestments: number
    averageROI: Decimal
    valuationSkill: number
    dueDiligenceSkill: number
    riskAssessmentSkill: number
    lastActivityAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalScore?: boolean
    currentLevel?: boolean
    completedSimulations?: boolean
    successfulInvestments?: boolean
    averageROI?: boolean
    valuationSkill?: boolean
    dueDiligenceSkill?: boolean
    riskAssessmentSkill?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalScore?: boolean
    currentLevel?: boolean
    completedSimulations?: boolean
    successfulInvestments?: boolean
    averageROI?: boolean
    valuationSkill?: boolean
    dueDiligenceSkill?: boolean
    riskAssessmentSkill?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalScore?: boolean
    currentLevel?: boolean
    completedSimulations?: boolean
    successfulInvestments?: boolean
    averageROI?: boolean
    valuationSkill?: boolean
    dueDiligenceSkill?: boolean
    riskAssessmentSkill?: boolean
    lastActivityAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    totalScore?: boolean
    currentLevel?: boolean
    completedSimulations?: boolean
    successfulInvestments?: boolean
    averageROI?: boolean
    valuationSkill?: boolean
    dueDiligenceSkill?: boolean
    riskAssessmentSkill?: boolean
    lastActivityAt?: boolean
  }

  export type UserProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalScore" | "currentLevel" | "completedSimulations" | "successfulInvestments" | "averageROI" | "valuationSkill" | "dueDiligenceSkill" | "riskAssessmentSkill" | "lastActivityAt", ExtArgs["result"]["userProgress"]>
  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalScore: number
      currentLevel: number
      completedSimulations: number
      successfulInvestments: number
      averageROI: Prisma.Decimal
      valuationSkill: number
      dueDiligenceSkill: number
      riskAssessmentSkill: number
      lastActivityAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses and returns the data updated in the database.
     * @param {UserProgressUpdateManyAndReturnArgs} args - Arguments to update many UserProgresses.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly totalScore: FieldRef<"UserProgress", 'Int'>
    readonly currentLevel: FieldRef<"UserProgress", 'Int'>
    readonly completedSimulations: FieldRef<"UserProgress", 'Int'>
    readonly successfulInvestments: FieldRef<"UserProgress", 'Int'>
    readonly averageROI: FieldRef<"UserProgress", 'Decimal'>
    readonly valuationSkill: FieldRef<"UserProgress", 'Int'>
    readonly dueDiligenceSkill: FieldRef<"UserProgress", 'Int'>
    readonly riskAssessmentSkill: FieldRef<"UserProgress", 'Int'>
    readonly lastActivityAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
  }

  /**
   * UserProgress updateManyAndReturn
   */
  export type UserProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model Investment
   */

  export type AggregateInvestment = {
    _count: InvestmentCountAggregateOutputType | null
    _avg: InvestmentAvgAggregateOutputType | null
    _sum: InvestmentSumAggregateOutputType | null
    _min: InvestmentMinAggregateOutputType | null
    _max: InvestmentMaxAggregateOutputType | null
  }

  export type InvestmentAvgAggregateOutputType = {
    amount: Decimal | null
    ownership: Decimal | null
    valuation: Decimal | null
  }

  export type InvestmentSumAggregateOutputType = {
    amount: Decimal | null
    ownership: Decimal | null
    valuation: Decimal | null
  }

  export type InvestmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startupId: string | null
    tokenId: string | null
    amount: Decimal | null
    ownership: Decimal | null
    valuation: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startupId: string | null
    tokenId: string | null
    amount: Decimal | null
    ownership: Decimal | null
    valuation: Decimal | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestmentCountAggregateOutputType = {
    id: number
    userId: number
    startupId: number
    tokenId: number
    amount: number
    ownership: number
    valuation: number
    terms: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestmentAvgAggregateInputType = {
    amount?: true
    ownership?: true
    valuation?: true
  }

  export type InvestmentSumAggregateInputType = {
    amount?: true
    ownership?: true
    valuation?: true
  }

  export type InvestmentMinAggregateInputType = {
    id?: true
    userId?: true
    startupId?: true
    tokenId?: true
    amount?: true
    ownership?: true
    valuation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestmentMaxAggregateInputType = {
    id?: true
    userId?: true
    startupId?: true
    tokenId?: true
    amount?: true
    ownership?: true
    valuation?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestmentCountAggregateInputType = {
    id?: true
    userId?: true
    startupId?: true
    tokenId?: true
    amount?: true
    ownership?: true
    valuation?: true
    terms?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investment to aggregate.
     */
    where?: InvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investments to fetch.
     */
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investments
    **/
    _count?: true | InvestmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestmentMaxAggregateInputType
  }

  export type GetInvestmentAggregateType<T extends InvestmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestment[P]>
      : GetScalarType<T[P], AggregateInvestment[P]>
  }




  export type InvestmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestmentWhereInput
    orderBy?: InvestmentOrderByWithAggregationInput | InvestmentOrderByWithAggregationInput[]
    by: InvestmentScalarFieldEnum[] | InvestmentScalarFieldEnum
    having?: InvestmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestmentCountAggregateInputType | true
    _avg?: InvestmentAvgAggregateInputType
    _sum?: InvestmentSumAggregateInputType
    _min?: InvestmentMinAggregateInputType
    _max?: InvestmentMaxAggregateInputType
  }

  export type InvestmentGroupByOutputType = {
    id: string
    userId: string
    startupId: string | null
    tokenId: string | null
    amount: Decimal
    ownership: Decimal
    valuation: Decimal | null
    terms: JsonValue | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InvestmentCountAggregateOutputType | null
    _avg: InvestmentAvgAggregateOutputType | null
    _sum: InvestmentSumAggregateOutputType | null
    _min: InvestmentMinAggregateOutputType | null
    _max: InvestmentMaxAggregateOutputType | null
  }

  type GetInvestmentGroupByPayload<T extends InvestmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestmentGroupByOutputType[P]>
            : GetScalarType<T[P], InvestmentGroupByOutputType[P]>
        }
      >
    >


  export type InvestmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    valuation?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Investment$startupArgs<ExtArgs>
    token?: boolean | Investment$tokenArgs<ExtArgs>
    vesting?: boolean | Investment$vestingArgs<ExtArgs>
    _count?: boolean | InvestmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investment"]>

  export type InvestmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    valuation?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Investment$startupArgs<ExtArgs>
    token?: boolean | Investment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["investment"]>

  export type InvestmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    valuation?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Investment$startupArgs<ExtArgs>
    token?: boolean | Investment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["investment"]>

  export type InvestmentSelectScalar = {
    id?: boolean
    userId?: boolean
    startupId?: boolean
    tokenId?: boolean
    amount?: boolean
    ownership?: boolean
    valuation?: boolean
    terms?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startupId" | "tokenId" | "amount" | "ownership" | "valuation" | "terms" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["investment"]>
  export type InvestmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Investment$startupArgs<ExtArgs>
    token?: boolean | Investment$tokenArgs<ExtArgs>
    vesting?: boolean | Investment$vestingArgs<ExtArgs>
    _count?: boolean | InvestmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvestmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Investment$startupArgs<ExtArgs>
    token?: boolean | Investment$tokenArgs<ExtArgs>
  }
  export type InvestmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Investment$startupArgs<ExtArgs>
    token?: boolean | Investment$tokenArgs<ExtArgs>
  }

  export type $InvestmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      startup: Prisma.$StartupPayload<ExtArgs> | null
      token: Prisma.$TokenPayload<ExtArgs> | null
      vesting: Prisma.$VestingSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startupId: string | null
      tokenId: string | null
      amount: Prisma.Decimal
      ownership: Prisma.Decimal
      valuation: Prisma.Decimal | null
      terms: Prisma.JsonValue | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investment"]>
    composites: {}
  }

  type InvestmentGetPayload<S extends boolean | null | undefined | InvestmentDefaultArgs> = $Result.GetResult<Prisma.$InvestmentPayload, S>

  type InvestmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestmentCountAggregateInputType | true
    }

  export interface InvestmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investment'], meta: { name: 'Investment' } }
    /**
     * Find zero or one Investment that matches the filter.
     * @param {InvestmentFindUniqueArgs} args - Arguments to find a Investment
     * @example
     * // Get one Investment
     * const investment = await prisma.investment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestmentFindUniqueArgs>(args: SelectSubset<T, InvestmentFindUniqueArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestmentFindUniqueOrThrowArgs} args - Arguments to find a Investment
     * @example
     * // Get one Investment
     * const investment = await prisma.investment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentFindFirstArgs} args - Arguments to find a Investment
     * @example
     * // Get one Investment
     * const investment = await prisma.investment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestmentFindFirstArgs>(args?: SelectSubset<T, InvestmentFindFirstArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentFindFirstOrThrowArgs} args - Arguments to find a Investment
     * @example
     * // Get one Investment
     * const investment = await prisma.investment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investments
     * const investments = await prisma.investment.findMany()
     * 
     * // Get first 10 Investments
     * const investments = await prisma.investment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investmentWithIdOnly = await prisma.investment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestmentFindManyArgs>(args?: SelectSubset<T, InvestmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investment.
     * @param {InvestmentCreateArgs} args - Arguments to create a Investment.
     * @example
     * // Create one Investment
     * const Investment = await prisma.investment.create({
     *   data: {
     *     // ... data to create a Investment
     *   }
     * })
     * 
     */
    create<T extends InvestmentCreateArgs>(args: SelectSubset<T, InvestmentCreateArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investments.
     * @param {InvestmentCreateManyArgs} args - Arguments to create many Investments.
     * @example
     * // Create many Investments
     * const investment = await prisma.investment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestmentCreateManyArgs>(args?: SelectSubset<T, InvestmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Investments and returns the data saved in the database.
     * @param {InvestmentCreateManyAndReturnArgs} args - Arguments to create many Investments.
     * @example
     * // Create many Investments
     * const investment = await prisma.investment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Investments and only return the `id`
     * const investmentWithIdOnly = await prisma.investment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Investment.
     * @param {InvestmentDeleteArgs} args - Arguments to delete one Investment.
     * @example
     * // Delete one Investment
     * const Investment = await prisma.investment.delete({
     *   where: {
     *     // ... filter to delete one Investment
     *   }
     * })
     * 
     */
    delete<T extends InvestmentDeleteArgs>(args: SelectSubset<T, InvestmentDeleteArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investment.
     * @param {InvestmentUpdateArgs} args - Arguments to update one Investment.
     * @example
     * // Update one Investment
     * const investment = await prisma.investment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestmentUpdateArgs>(args: SelectSubset<T, InvestmentUpdateArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investments.
     * @param {InvestmentDeleteManyArgs} args - Arguments to filter Investments to delete.
     * @example
     * // Delete a few Investments
     * const { count } = await prisma.investment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestmentDeleteManyArgs>(args?: SelectSubset<T, InvestmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investments
     * const investment = await prisma.investment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestmentUpdateManyArgs>(args: SelectSubset<T, InvestmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investments and returns the data updated in the database.
     * @param {InvestmentUpdateManyAndReturnArgs} args - Arguments to update many Investments.
     * @example
     * // Update many Investments
     * const investment = await prisma.investment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Investments and only return the `id`
     * const investmentWithIdOnly = await prisma.investment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestmentUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Investment.
     * @param {InvestmentUpsertArgs} args - Arguments to update or create a Investment.
     * @example
     * // Update or create a Investment
     * const investment = await prisma.investment.upsert({
     *   create: {
     *     // ... data to create a Investment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investment we want to update
     *   }
     * })
     */
    upsert<T extends InvestmentUpsertArgs>(args: SelectSubset<T, InvestmentUpsertArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Investments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentCountArgs} args - Arguments to filter Investments to count.
     * @example
     * // Count the number of Investments
     * const count = await prisma.investment.count({
     *   where: {
     *     // ... the filter for the Investments we want to count
     *   }
     * })
    **/
    count<T extends InvestmentCountArgs>(
      args?: Subset<T, InvestmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestmentAggregateArgs>(args: Subset<T, InvestmentAggregateArgs>): Prisma.PrismaPromise<GetInvestmentAggregateType<T>>

    /**
     * Group by Investment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestmentGroupByArgs['orderBy'] }
        : { orderBy?: InvestmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investment model
   */
  readonly fields: InvestmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    startup<T extends Investment$startupArgs<ExtArgs> = {}>(args?: Subset<T, Investment$startupArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    token<T extends Investment$tokenArgs<ExtArgs> = {}>(args?: Subset<T, Investment$tokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vesting<T extends Investment$vestingArgs<ExtArgs> = {}>(args?: Subset<T, Investment$vestingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investment model
   */
  interface InvestmentFieldRefs {
    readonly id: FieldRef<"Investment", 'String'>
    readonly userId: FieldRef<"Investment", 'String'>
    readonly startupId: FieldRef<"Investment", 'String'>
    readonly tokenId: FieldRef<"Investment", 'String'>
    readonly amount: FieldRef<"Investment", 'Decimal'>
    readonly ownership: FieldRef<"Investment", 'Decimal'>
    readonly valuation: FieldRef<"Investment", 'Decimal'>
    readonly terms: FieldRef<"Investment", 'Json'>
    readonly status: FieldRef<"Investment", 'String'>
    readonly createdAt: FieldRef<"Investment", 'DateTime'>
    readonly updatedAt: FieldRef<"Investment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investment findUnique
   */
  export type InvestmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * Filter, which Investment to fetch.
     */
    where: InvestmentWhereUniqueInput
  }

  /**
   * Investment findUniqueOrThrow
   */
  export type InvestmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * Filter, which Investment to fetch.
     */
    where: InvestmentWhereUniqueInput
  }

  /**
   * Investment findFirst
   */
  export type InvestmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * Filter, which Investment to fetch.
     */
    where?: InvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investments to fetch.
     */
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investments.
     */
    cursor?: InvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investments.
     */
    distinct?: InvestmentScalarFieldEnum | InvestmentScalarFieldEnum[]
  }

  /**
   * Investment findFirstOrThrow
   */
  export type InvestmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * Filter, which Investment to fetch.
     */
    where?: InvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investments to fetch.
     */
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investments.
     */
    cursor?: InvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investments.
     */
    distinct?: InvestmentScalarFieldEnum | InvestmentScalarFieldEnum[]
  }

  /**
   * Investment findMany
   */
  export type InvestmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * Filter, which Investments to fetch.
     */
    where?: InvestmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investments to fetch.
     */
    orderBy?: InvestmentOrderByWithRelationInput | InvestmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investments.
     */
    cursor?: InvestmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investments.
     */
    skip?: number
    distinct?: InvestmentScalarFieldEnum | InvestmentScalarFieldEnum[]
  }

  /**
   * Investment create
   */
  export type InvestmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Investment.
     */
    data: XOR<InvestmentCreateInput, InvestmentUncheckedCreateInput>
  }

  /**
   * Investment createMany
   */
  export type InvestmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investments.
     */
    data: InvestmentCreateManyInput | InvestmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Investment createManyAndReturn
   */
  export type InvestmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * The data used to create many Investments.
     */
    data: InvestmentCreateManyInput | InvestmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investment update
   */
  export type InvestmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Investment.
     */
    data: XOR<InvestmentUpdateInput, InvestmentUncheckedUpdateInput>
    /**
     * Choose, which Investment to update.
     */
    where: InvestmentWhereUniqueInput
  }

  /**
   * Investment updateMany
   */
  export type InvestmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investments.
     */
    data: XOR<InvestmentUpdateManyMutationInput, InvestmentUncheckedUpdateManyInput>
    /**
     * Filter which Investments to update
     */
    where?: InvestmentWhereInput
    /**
     * Limit how many Investments to update.
     */
    limit?: number
  }

  /**
   * Investment updateManyAndReturn
   */
  export type InvestmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * The data used to update Investments.
     */
    data: XOR<InvestmentUpdateManyMutationInput, InvestmentUncheckedUpdateManyInput>
    /**
     * Filter which Investments to update
     */
    where?: InvestmentWhereInput
    /**
     * Limit how many Investments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investment upsert
   */
  export type InvestmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Investment to update in case it exists.
     */
    where: InvestmentWhereUniqueInput
    /**
     * In case the Investment found by the `where` argument doesn't exist, create a new Investment with this data.
     */
    create: XOR<InvestmentCreateInput, InvestmentUncheckedCreateInput>
    /**
     * In case the Investment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestmentUpdateInput, InvestmentUncheckedUpdateInput>
  }

  /**
   * Investment delete
   */
  export type InvestmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
    /**
     * Filter which Investment to delete.
     */
    where: InvestmentWhereUniqueInput
  }

  /**
   * Investment deleteMany
   */
  export type InvestmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investments to delete
     */
    where?: InvestmentWhereInput
    /**
     * Limit how many Investments to delete.
     */
    limit?: number
  }

  /**
   * Investment.startup
   */
  export type Investment$startupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
  }

  /**
   * Investment.token
   */
  export type Investment$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * Investment.vesting
   */
  export type Investment$vestingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    where?: VestingScheduleWhereInput
    orderBy?: VestingScheduleOrderByWithRelationInput | VestingScheduleOrderByWithRelationInput[]
    cursor?: VestingScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VestingScheduleScalarFieldEnum | VestingScheduleScalarFieldEnum[]
  }

  /**
   * Investment without action
   */
  export type InvestmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investment
     */
    select?: InvestmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investment
     */
    omit?: InvestmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestmentInclude<ExtArgs> | null
  }


  /**
   * Model VestingSchedule
   */

  export type AggregateVestingSchedule = {
    _count: VestingScheduleCountAggregateOutputType | null
    _avg: VestingScheduleAvgAggregateOutputType | null
    _sum: VestingScheduleSumAggregateOutputType | null
    _min: VestingScheduleMinAggregateOutputType | null
    _max: VestingScheduleMaxAggregateOutputType | null
  }

  export type VestingScheduleAvgAggregateOutputType = {
    percentage: Decimal | null
  }

  export type VestingScheduleSumAggregateOutputType = {
    percentage: Decimal | null
  }

  export type VestingScheduleMinAggregateOutputType = {
    id: string | null
    investmentId: string | null
    cliffDate: Date | null
    unlockDate: Date | null
    percentage: Decimal | null
    isUnlocked: boolean | null
    createdAt: Date | null
  }

  export type VestingScheduleMaxAggregateOutputType = {
    id: string | null
    investmentId: string | null
    cliffDate: Date | null
    unlockDate: Date | null
    percentage: Decimal | null
    isUnlocked: boolean | null
    createdAt: Date | null
  }

  export type VestingScheduleCountAggregateOutputType = {
    id: number
    investmentId: number
    cliffDate: number
    unlockDate: number
    percentage: number
    isUnlocked: number
    createdAt: number
    _all: number
  }


  export type VestingScheduleAvgAggregateInputType = {
    percentage?: true
  }

  export type VestingScheduleSumAggregateInputType = {
    percentage?: true
  }

  export type VestingScheduleMinAggregateInputType = {
    id?: true
    investmentId?: true
    cliffDate?: true
    unlockDate?: true
    percentage?: true
    isUnlocked?: true
    createdAt?: true
  }

  export type VestingScheduleMaxAggregateInputType = {
    id?: true
    investmentId?: true
    cliffDate?: true
    unlockDate?: true
    percentage?: true
    isUnlocked?: true
    createdAt?: true
  }

  export type VestingScheduleCountAggregateInputType = {
    id?: true
    investmentId?: true
    cliffDate?: true
    unlockDate?: true
    percentage?: true
    isUnlocked?: true
    createdAt?: true
    _all?: true
  }

  export type VestingScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VestingSchedule to aggregate.
     */
    where?: VestingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VestingSchedules to fetch.
     */
    orderBy?: VestingScheduleOrderByWithRelationInput | VestingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VestingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VestingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VestingSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VestingSchedules
    **/
    _count?: true | VestingScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VestingScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VestingScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VestingScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VestingScheduleMaxAggregateInputType
  }

  export type GetVestingScheduleAggregateType<T extends VestingScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateVestingSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVestingSchedule[P]>
      : GetScalarType<T[P], AggregateVestingSchedule[P]>
  }




  export type VestingScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VestingScheduleWhereInput
    orderBy?: VestingScheduleOrderByWithAggregationInput | VestingScheduleOrderByWithAggregationInput[]
    by: VestingScheduleScalarFieldEnum[] | VestingScheduleScalarFieldEnum
    having?: VestingScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VestingScheduleCountAggregateInputType | true
    _avg?: VestingScheduleAvgAggregateInputType
    _sum?: VestingScheduleSumAggregateInputType
    _min?: VestingScheduleMinAggregateInputType
    _max?: VestingScheduleMaxAggregateInputType
  }

  export type VestingScheduleGroupByOutputType = {
    id: string
    investmentId: string
    cliffDate: Date
    unlockDate: Date
    percentage: Decimal
    isUnlocked: boolean
    createdAt: Date
    _count: VestingScheduleCountAggregateOutputType | null
    _avg: VestingScheduleAvgAggregateOutputType | null
    _sum: VestingScheduleSumAggregateOutputType | null
    _min: VestingScheduleMinAggregateOutputType | null
    _max: VestingScheduleMaxAggregateOutputType | null
  }

  type GetVestingScheduleGroupByPayload<T extends VestingScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VestingScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VestingScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VestingScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], VestingScheduleGroupByOutputType[P]>
        }
      >
    >


  export type VestingScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investmentId?: boolean
    cliffDate?: boolean
    unlockDate?: boolean
    percentage?: boolean
    isUnlocked?: boolean
    createdAt?: boolean
    investment?: boolean | InvestmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vestingSchedule"]>

  export type VestingScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investmentId?: boolean
    cliffDate?: boolean
    unlockDate?: boolean
    percentage?: boolean
    isUnlocked?: boolean
    createdAt?: boolean
    investment?: boolean | InvestmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vestingSchedule"]>

  export type VestingScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investmentId?: boolean
    cliffDate?: boolean
    unlockDate?: boolean
    percentage?: boolean
    isUnlocked?: boolean
    createdAt?: boolean
    investment?: boolean | InvestmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vestingSchedule"]>

  export type VestingScheduleSelectScalar = {
    id?: boolean
    investmentId?: boolean
    cliffDate?: boolean
    unlockDate?: boolean
    percentage?: boolean
    isUnlocked?: boolean
    createdAt?: boolean
  }

  export type VestingScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "investmentId" | "cliffDate" | "unlockDate" | "percentage" | "isUnlocked" | "createdAt", ExtArgs["result"]["vestingSchedule"]>
  export type VestingScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investment?: boolean | InvestmentDefaultArgs<ExtArgs>
  }
  export type VestingScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investment?: boolean | InvestmentDefaultArgs<ExtArgs>
  }
  export type VestingScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investment?: boolean | InvestmentDefaultArgs<ExtArgs>
  }

  export type $VestingSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VestingSchedule"
    objects: {
      investment: Prisma.$InvestmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investmentId: string
      cliffDate: Date
      unlockDate: Date
      percentage: Prisma.Decimal
      isUnlocked: boolean
      createdAt: Date
    }, ExtArgs["result"]["vestingSchedule"]>
    composites: {}
  }

  type VestingScheduleGetPayload<S extends boolean | null | undefined | VestingScheduleDefaultArgs> = $Result.GetResult<Prisma.$VestingSchedulePayload, S>

  type VestingScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VestingScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VestingScheduleCountAggregateInputType | true
    }

  export interface VestingScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VestingSchedule'], meta: { name: 'VestingSchedule' } }
    /**
     * Find zero or one VestingSchedule that matches the filter.
     * @param {VestingScheduleFindUniqueArgs} args - Arguments to find a VestingSchedule
     * @example
     * // Get one VestingSchedule
     * const vestingSchedule = await prisma.vestingSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VestingScheduleFindUniqueArgs>(args: SelectSubset<T, VestingScheduleFindUniqueArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VestingSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VestingScheduleFindUniqueOrThrowArgs} args - Arguments to find a VestingSchedule
     * @example
     * // Get one VestingSchedule
     * const vestingSchedule = await prisma.vestingSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VestingScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, VestingScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VestingSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleFindFirstArgs} args - Arguments to find a VestingSchedule
     * @example
     * // Get one VestingSchedule
     * const vestingSchedule = await prisma.vestingSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VestingScheduleFindFirstArgs>(args?: SelectSubset<T, VestingScheduleFindFirstArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VestingSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleFindFirstOrThrowArgs} args - Arguments to find a VestingSchedule
     * @example
     * // Get one VestingSchedule
     * const vestingSchedule = await prisma.vestingSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VestingScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, VestingScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VestingSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VestingSchedules
     * const vestingSchedules = await prisma.vestingSchedule.findMany()
     * 
     * // Get first 10 VestingSchedules
     * const vestingSchedules = await prisma.vestingSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vestingScheduleWithIdOnly = await prisma.vestingSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VestingScheduleFindManyArgs>(args?: SelectSubset<T, VestingScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VestingSchedule.
     * @param {VestingScheduleCreateArgs} args - Arguments to create a VestingSchedule.
     * @example
     * // Create one VestingSchedule
     * const VestingSchedule = await prisma.vestingSchedule.create({
     *   data: {
     *     // ... data to create a VestingSchedule
     *   }
     * })
     * 
     */
    create<T extends VestingScheduleCreateArgs>(args: SelectSubset<T, VestingScheduleCreateArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VestingSchedules.
     * @param {VestingScheduleCreateManyArgs} args - Arguments to create many VestingSchedules.
     * @example
     * // Create many VestingSchedules
     * const vestingSchedule = await prisma.vestingSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VestingScheduleCreateManyArgs>(args?: SelectSubset<T, VestingScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VestingSchedules and returns the data saved in the database.
     * @param {VestingScheduleCreateManyAndReturnArgs} args - Arguments to create many VestingSchedules.
     * @example
     * // Create many VestingSchedules
     * const vestingSchedule = await prisma.vestingSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VestingSchedules and only return the `id`
     * const vestingScheduleWithIdOnly = await prisma.vestingSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VestingScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, VestingScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VestingSchedule.
     * @param {VestingScheduleDeleteArgs} args - Arguments to delete one VestingSchedule.
     * @example
     * // Delete one VestingSchedule
     * const VestingSchedule = await prisma.vestingSchedule.delete({
     *   where: {
     *     // ... filter to delete one VestingSchedule
     *   }
     * })
     * 
     */
    delete<T extends VestingScheduleDeleteArgs>(args: SelectSubset<T, VestingScheduleDeleteArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VestingSchedule.
     * @param {VestingScheduleUpdateArgs} args - Arguments to update one VestingSchedule.
     * @example
     * // Update one VestingSchedule
     * const vestingSchedule = await prisma.vestingSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VestingScheduleUpdateArgs>(args: SelectSubset<T, VestingScheduleUpdateArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VestingSchedules.
     * @param {VestingScheduleDeleteManyArgs} args - Arguments to filter VestingSchedules to delete.
     * @example
     * // Delete a few VestingSchedules
     * const { count } = await prisma.vestingSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VestingScheduleDeleteManyArgs>(args?: SelectSubset<T, VestingScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VestingSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VestingSchedules
     * const vestingSchedule = await prisma.vestingSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VestingScheduleUpdateManyArgs>(args: SelectSubset<T, VestingScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VestingSchedules and returns the data updated in the database.
     * @param {VestingScheduleUpdateManyAndReturnArgs} args - Arguments to update many VestingSchedules.
     * @example
     * // Update many VestingSchedules
     * const vestingSchedule = await prisma.vestingSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VestingSchedules and only return the `id`
     * const vestingScheduleWithIdOnly = await prisma.vestingSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VestingScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, VestingScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VestingSchedule.
     * @param {VestingScheduleUpsertArgs} args - Arguments to update or create a VestingSchedule.
     * @example
     * // Update or create a VestingSchedule
     * const vestingSchedule = await prisma.vestingSchedule.upsert({
     *   create: {
     *     // ... data to create a VestingSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VestingSchedule we want to update
     *   }
     * })
     */
    upsert<T extends VestingScheduleUpsertArgs>(args: SelectSubset<T, VestingScheduleUpsertArgs<ExtArgs>>): Prisma__VestingScheduleClient<$Result.GetResult<Prisma.$VestingSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VestingSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleCountArgs} args - Arguments to filter VestingSchedules to count.
     * @example
     * // Count the number of VestingSchedules
     * const count = await prisma.vestingSchedule.count({
     *   where: {
     *     // ... the filter for the VestingSchedules we want to count
     *   }
     * })
    **/
    count<T extends VestingScheduleCountArgs>(
      args?: Subset<T, VestingScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VestingScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VestingSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VestingScheduleAggregateArgs>(args: Subset<T, VestingScheduleAggregateArgs>): Prisma.PrismaPromise<GetVestingScheduleAggregateType<T>>

    /**
     * Group by VestingSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VestingScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VestingScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VestingScheduleGroupByArgs['orderBy'] }
        : { orderBy?: VestingScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VestingScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVestingScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VestingSchedule model
   */
  readonly fields: VestingScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VestingSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VestingScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investment<T extends InvestmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestmentDefaultArgs<ExtArgs>>): Prisma__InvestmentClient<$Result.GetResult<Prisma.$InvestmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VestingSchedule model
   */
  interface VestingScheduleFieldRefs {
    readonly id: FieldRef<"VestingSchedule", 'String'>
    readonly investmentId: FieldRef<"VestingSchedule", 'String'>
    readonly cliffDate: FieldRef<"VestingSchedule", 'DateTime'>
    readonly unlockDate: FieldRef<"VestingSchedule", 'DateTime'>
    readonly percentage: FieldRef<"VestingSchedule", 'Decimal'>
    readonly isUnlocked: FieldRef<"VestingSchedule", 'Boolean'>
    readonly createdAt: FieldRef<"VestingSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VestingSchedule findUnique
   */
  export type VestingScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which VestingSchedule to fetch.
     */
    where: VestingScheduleWhereUniqueInput
  }

  /**
   * VestingSchedule findUniqueOrThrow
   */
  export type VestingScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which VestingSchedule to fetch.
     */
    where: VestingScheduleWhereUniqueInput
  }

  /**
   * VestingSchedule findFirst
   */
  export type VestingScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which VestingSchedule to fetch.
     */
    where?: VestingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VestingSchedules to fetch.
     */
    orderBy?: VestingScheduleOrderByWithRelationInput | VestingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VestingSchedules.
     */
    cursor?: VestingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VestingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VestingSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VestingSchedules.
     */
    distinct?: VestingScheduleScalarFieldEnum | VestingScheduleScalarFieldEnum[]
  }

  /**
   * VestingSchedule findFirstOrThrow
   */
  export type VestingScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which VestingSchedule to fetch.
     */
    where?: VestingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VestingSchedules to fetch.
     */
    orderBy?: VestingScheduleOrderByWithRelationInput | VestingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VestingSchedules.
     */
    cursor?: VestingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VestingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VestingSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VestingSchedules.
     */
    distinct?: VestingScheduleScalarFieldEnum | VestingScheduleScalarFieldEnum[]
  }

  /**
   * VestingSchedule findMany
   */
  export type VestingScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * Filter, which VestingSchedules to fetch.
     */
    where?: VestingScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VestingSchedules to fetch.
     */
    orderBy?: VestingScheduleOrderByWithRelationInput | VestingScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VestingSchedules.
     */
    cursor?: VestingScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VestingSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VestingSchedules.
     */
    skip?: number
    distinct?: VestingScheduleScalarFieldEnum | VestingScheduleScalarFieldEnum[]
  }

  /**
   * VestingSchedule create
   */
  export type VestingScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a VestingSchedule.
     */
    data: XOR<VestingScheduleCreateInput, VestingScheduleUncheckedCreateInput>
  }

  /**
   * VestingSchedule createMany
   */
  export type VestingScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VestingSchedules.
     */
    data: VestingScheduleCreateManyInput | VestingScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VestingSchedule createManyAndReturn
   */
  export type VestingScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many VestingSchedules.
     */
    data: VestingScheduleCreateManyInput | VestingScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VestingSchedule update
   */
  export type VestingScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a VestingSchedule.
     */
    data: XOR<VestingScheduleUpdateInput, VestingScheduleUncheckedUpdateInput>
    /**
     * Choose, which VestingSchedule to update.
     */
    where: VestingScheduleWhereUniqueInput
  }

  /**
   * VestingSchedule updateMany
   */
  export type VestingScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VestingSchedules.
     */
    data: XOR<VestingScheduleUpdateManyMutationInput, VestingScheduleUncheckedUpdateManyInput>
    /**
     * Filter which VestingSchedules to update
     */
    where?: VestingScheduleWhereInput
    /**
     * Limit how many VestingSchedules to update.
     */
    limit?: number
  }

  /**
   * VestingSchedule updateManyAndReturn
   */
  export type VestingScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * The data used to update VestingSchedules.
     */
    data: XOR<VestingScheduleUpdateManyMutationInput, VestingScheduleUncheckedUpdateManyInput>
    /**
     * Filter which VestingSchedules to update
     */
    where?: VestingScheduleWhereInput
    /**
     * Limit how many VestingSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VestingSchedule upsert
   */
  export type VestingScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the VestingSchedule to update in case it exists.
     */
    where: VestingScheduleWhereUniqueInput
    /**
     * In case the VestingSchedule found by the `where` argument doesn't exist, create a new VestingSchedule with this data.
     */
    create: XOR<VestingScheduleCreateInput, VestingScheduleUncheckedCreateInput>
    /**
     * In case the VestingSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VestingScheduleUpdateInput, VestingScheduleUncheckedUpdateInput>
  }

  /**
   * VestingSchedule delete
   */
  export type VestingScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
    /**
     * Filter which VestingSchedule to delete.
     */
    where: VestingScheduleWhereUniqueInput
  }

  /**
   * VestingSchedule deleteMany
   */
  export type VestingScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VestingSchedules to delete
     */
    where?: VestingScheduleWhereInput
    /**
     * Limit how many VestingSchedules to delete.
     */
    limit?: number
  }

  /**
   * VestingSchedule without action
   */
  export type VestingScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VestingSchedule
     */
    select?: VestingScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VestingSchedule
     */
    omit?: VestingScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VestingScheduleInclude<ExtArgs> | null
  }


  /**
   * Model KYCRecord
   */

  export type AggregateKYCRecord = {
    _count: KYCRecordCountAggregateOutputType | null
    _min: KYCRecordMinAggregateOutputType | null
    _max: KYCRecordMaxAggregateOutputType | null
  }

  export type KYCRecordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.KYCStatus | null
    accreditationStatus: $Enums.AccreditationStatus | null
    reason: string | null
    documentUrls: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KYCRecordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.KYCStatus | null
    accreditationStatus: $Enums.AccreditationStatus | null
    reason: string | null
    documentUrls: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KYCRecordCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    accreditationStatus: number
    reason: number
    documentUrls: number
    verificationData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KYCRecordMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    accreditationStatus?: true
    reason?: true
    documentUrls?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KYCRecordMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    accreditationStatus?: true
    reason?: true
    documentUrls?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KYCRecordCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    accreditationStatus?: true
    reason?: true
    documentUrls?: true
    verificationData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KYCRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCRecord to aggregate.
     */
    where?: KYCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCRecords to fetch.
     */
    orderBy?: KYCRecordOrderByWithRelationInput | KYCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCRecords
    **/
    _count?: true | KYCRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCRecordMaxAggregateInputType
  }

  export type GetKYCRecordAggregateType<T extends KYCRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateKYCRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYCRecord[P]>
      : GetScalarType<T[P], AggregateKYCRecord[P]>
  }




  export type KYCRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCRecordWhereInput
    orderBy?: KYCRecordOrderByWithAggregationInput | KYCRecordOrderByWithAggregationInput[]
    by: KYCRecordScalarFieldEnum[] | KYCRecordScalarFieldEnum
    having?: KYCRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCRecordCountAggregateInputType | true
    _min?: KYCRecordMinAggregateInputType
    _max?: KYCRecordMaxAggregateInputType
  }

  export type KYCRecordGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.KYCStatus
    accreditationStatus: $Enums.AccreditationStatus
    reason: string | null
    documentUrls: string | null
    verificationData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: KYCRecordCountAggregateOutputType | null
    _min: KYCRecordMinAggregateOutputType | null
    _max: KYCRecordMaxAggregateOutputType | null
  }

  type GetKYCRecordGroupByPayload<T extends KYCRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCRecordGroupByOutputType[P]>
            : GetScalarType<T[P], KYCRecordGroupByOutputType[P]>
        }
      >
    >


  export type KYCRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    accreditationStatus?: boolean
    reason?: boolean
    documentUrls?: boolean
    verificationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCRecord"]>

  export type KYCRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    accreditationStatus?: boolean
    reason?: boolean
    documentUrls?: boolean
    verificationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCRecord"]>

  export type KYCRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    accreditationStatus?: boolean
    reason?: boolean
    documentUrls?: boolean
    verificationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCRecord"]>

  export type KYCRecordSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    accreditationStatus?: boolean
    reason?: boolean
    documentUrls?: boolean
    verificationData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KYCRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "accreditationStatus" | "reason" | "documentUrls" | "verificationData" | "createdAt" | "updatedAt", ExtArgs["result"]["kYCRecord"]>
  export type KYCRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KYCRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KYCRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYCRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.KYCStatus
      accreditationStatus: $Enums.AccreditationStatus
      reason: string | null
      documentUrls: string | null
      verificationData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kYCRecord"]>
    composites: {}
  }

  type KYCRecordGetPayload<S extends boolean | null | undefined | KYCRecordDefaultArgs> = $Result.GetResult<Prisma.$KYCRecordPayload, S>

  type KYCRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCRecordCountAggregateInputType | true
    }

  export interface KYCRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYCRecord'], meta: { name: 'KYCRecord' } }
    /**
     * Find zero or one KYCRecord that matches the filter.
     * @param {KYCRecordFindUniqueArgs} args - Arguments to find a KYCRecord
     * @example
     * // Get one KYCRecord
     * const kYCRecord = await prisma.kYCRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCRecordFindUniqueArgs>(args: SelectSubset<T, KYCRecordFindUniqueArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYCRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCRecordFindUniqueOrThrowArgs} args - Arguments to find a KYCRecord
     * @example
     * // Get one KYCRecord
     * const kYCRecord = await prisma.kYCRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordFindFirstArgs} args - Arguments to find a KYCRecord
     * @example
     * // Get one KYCRecord
     * const kYCRecord = await prisma.kYCRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCRecordFindFirstArgs>(args?: SelectSubset<T, KYCRecordFindFirstArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordFindFirstOrThrowArgs} args - Arguments to find a KYCRecord
     * @example
     * // Get one KYCRecord
     * const kYCRecord = await prisma.kYCRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCRecords
     * const kYCRecords = await prisma.kYCRecord.findMany()
     * 
     * // Get first 10 KYCRecords
     * const kYCRecords = await prisma.kYCRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCRecordWithIdOnly = await prisma.kYCRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCRecordFindManyArgs>(args?: SelectSubset<T, KYCRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYCRecord.
     * @param {KYCRecordCreateArgs} args - Arguments to create a KYCRecord.
     * @example
     * // Create one KYCRecord
     * const KYCRecord = await prisma.kYCRecord.create({
     *   data: {
     *     // ... data to create a KYCRecord
     *   }
     * })
     * 
     */
    create<T extends KYCRecordCreateArgs>(args: SelectSubset<T, KYCRecordCreateArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCRecords.
     * @param {KYCRecordCreateManyArgs} args - Arguments to create many KYCRecords.
     * @example
     * // Create many KYCRecords
     * const kYCRecord = await prisma.kYCRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCRecordCreateManyArgs>(args?: SelectSubset<T, KYCRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCRecords and returns the data saved in the database.
     * @param {KYCRecordCreateManyAndReturnArgs} args - Arguments to create many KYCRecords.
     * @example
     * // Create many KYCRecords
     * const kYCRecord = await prisma.kYCRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCRecords and only return the `id`
     * const kYCRecordWithIdOnly = await prisma.kYCRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYCRecord.
     * @param {KYCRecordDeleteArgs} args - Arguments to delete one KYCRecord.
     * @example
     * // Delete one KYCRecord
     * const KYCRecord = await prisma.kYCRecord.delete({
     *   where: {
     *     // ... filter to delete one KYCRecord
     *   }
     * })
     * 
     */
    delete<T extends KYCRecordDeleteArgs>(args: SelectSubset<T, KYCRecordDeleteArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYCRecord.
     * @param {KYCRecordUpdateArgs} args - Arguments to update one KYCRecord.
     * @example
     * // Update one KYCRecord
     * const kYCRecord = await prisma.kYCRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCRecordUpdateArgs>(args: SelectSubset<T, KYCRecordUpdateArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCRecords.
     * @param {KYCRecordDeleteManyArgs} args - Arguments to filter KYCRecords to delete.
     * @example
     * // Delete a few KYCRecords
     * const { count } = await prisma.kYCRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCRecordDeleteManyArgs>(args?: SelectSubset<T, KYCRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCRecords
     * const kYCRecord = await prisma.kYCRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCRecordUpdateManyArgs>(args: SelectSubset<T, KYCRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCRecords and returns the data updated in the database.
     * @param {KYCRecordUpdateManyAndReturnArgs} args - Arguments to update many KYCRecords.
     * @example
     * // Update many KYCRecords
     * const kYCRecord = await prisma.kYCRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCRecords and only return the `id`
     * const kYCRecordWithIdOnly = await prisma.kYCRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYCRecord.
     * @param {KYCRecordUpsertArgs} args - Arguments to update or create a KYCRecord.
     * @example
     * // Update or create a KYCRecord
     * const kYCRecord = await prisma.kYCRecord.upsert({
     *   create: {
     *     // ... data to create a KYCRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYCRecord we want to update
     *   }
     * })
     */
    upsert<T extends KYCRecordUpsertArgs>(args: SelectSubset<T, KYCRecordUpsertArgs<ExtArgs>>): Prisma__KYCRecordClient<$Result.GetResult<Prisma.$KYCRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordCountArgs} args - Arguments to filter KYCRecords to count.
     * @example
     * // Count the number of KYCRecords
     * const count = await prisma.kYCRecord.count({
     *   where: {
     *     // ... the filter for the KYCRecords we want to count
     *   }
     * })
    **/
    count<T extends KYCRecordCountArgs>(
      args?: Subset<T, KYCRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYCRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCRecordAggregateArgs>(args: Subset<T, KYCRecordAggregateArgs>): Prisma.PrismaPromise<GetKYCRecordAggregateType<T>>

    /**
     * Group by KYCRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCRecordGroupByArgs['orderBy'] }
        : { orderBy?: KYCRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYCRecord model
   */
  readonly fields: KYCRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYCRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYCRecord model
   */
  interface KYCRecordFieldRefs {
    readonly id: FieldRef<"KYCRecord", 'String'>
    readonly userId: FieldRef<"KYCRecord", 'String'>
    readonly status: FieldRef<"KYCRecord", 'KYCStatus'>
    readonly accreditationStatus: FieldRef<"KYCRecord", 'AccreditationStatus'>
    readonly reason: FieldRef<"KYCRecord", 'String'>
    readonly documentUrls: FieldRef<"KYCRecord", 'String'>
    readonly verificationData: FieldRef<"KYCRecord", 'Json'>
    readonly createdAt: FieldRef<"KYCRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"KYCRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KYCRecord findUnique
   */
  export type KYCRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * Filter, which KYCRecord to fetch.
     */
    where: KYCRecordWhereUniqueInput
  }

  /**
   * KYCRecord findUniqueOrThrow
   */
  export type KYCRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * Filter, which KYCRecord to fetch.
     */
    where: KYCRecordWhereUniqueInput
  }

  /**
   * KYCRecord findFirst
   */
  export type KYCRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * Filter, which KYCRecord to fetch.
     */
    where?: KYCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCRecords to fetch.
     */
    orderBy?: KYCRecordOrderByWithRelationInput | KYCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCRecords.
     */
    cursor?: KYCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCRecords.
     */
    distinct?: KYCRecordScalarFieldEnum | KYCRecordScalarFieldEnum[]
  }

  /**
   * KYCRecord findFirstOrThrow
   */
  export type KYCRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * Filter, which KYCRecord to fetch.
     */
    where?: KYCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCRecords to fetch.
     */
    orderBy?: KYCRecordOrderByWithRelationInput | KYCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCRecords.
     */
    cursor?: KYCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCRecords.
     */
    distinct?: KYCRecordScalarFieldEnum | KYCRecordScalarFieldEnum[]
  }

  /**
   * KYCRecord findMany
   */
  export type KYCRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * Filter, which KYCRecords to fetch.
     */
    where?: KYCRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCRecords to fetch.
     */
    orderBy?: KYCRecordOrderByWithRelationInput | KYCRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCRecords.
     */
    cursor?: KYCRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCRecords.
     */
    skip?: number
    distinct?: KYCRecordScalarFieldEnum | KYCRecordScalarFieldEnum[]
  }

  /**
   * KYCRecord create
   */
  export type KYCRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a KYCRecord.
     */
    data: XOR<KYCRecordCreateInput, KYCRecordUncheckedCreateInput>
  }

  /**
   * KYCRecord createMany
   */
  export type KYCRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCRecords.
     */
    data: KYCRecordCreateManyInput | KYCRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYCRecord createManyAndReturn
   */
  export type KYCRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * The data used to create many KYCRecords.
     */
    data: KYCRecordCreateManyInput | KYCRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCRecord update
   */
  export type KYCRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a KYCRecord.
     */
    data: XOR<KYCRecordUpdateInput, KYCRecordUncheckedUpdateInput>
    /**
     * Choose, which KYCRecord to update.
     */
    where: KYCRecordWhereUniqueInput
  }

  /**
   * KYCRecord updateMany
   */
  export type KYCRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCRecords.
     */
    data: XOR<KYCRecordUpdateManyMutationInput, KYCRecordUncheckedUpdateManyInput>
    /**
     * Filter which KYCRecords to update
     */
    where?: KYCRecordWhereInput
    /**
     * Limit how many KYCRecords to update.
     */
    limit?: number
  }

  /**
   * KYCRecord updateManyAndReturn
   */
  export type KYCRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * The data used to update KYCRecords.
     */
    data: XOR<KYCRecordUpdateManyMutationInput, KYCRecordUncheckedUpdateManyInput>
    /**
     * Filter which KYCRecords to update
     */
    where?: KYCRecordWhereInput
    /**
     * Limit how many KYCRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCRecord upsert
   */
  export type KYCRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the KYCRecord to update in case it exists.
     */
    where: KYCRecordWhereUniqueInput
    /**
     * In case the KYCRecord found by the `where` argument doesn't exist, create a new KYCRecord with this data.
     */
    create: XOR<KYCRecordCreateInput, KYCRecordUncheckedCreateInput>
    /**
     * In case the KYCRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCRecordUpdateInput, KYCRecordUncheckedUpdateInput>
  }

  /**
   * KYCRecord delete
   */
  export type KYCRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
    /**
     * Filter which KYCRecord to delete.
     */
    where: KYCRecordWhereUniqueInput
  }

  /**
   * KYCRecord deleteMany
   */
  export type KYCRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCRecords to delete
     */
    where?: KYCRecordWhereInput
    /**
     * Limit how many KYCRecords to delete.
     */
    limit?: number
  }

  /**
   * KYCRecord without action
   */
  export type KYCRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCRecord
     */
    select?: KYCRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCRecord
     */
    omit?: KYCRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCRecordInclude<ExtArgs> | null
  }


  /**
   * Model DueDiligenceReport
   */

  export type AggregateDueDiligenceReport = {
    _count: DueDiligenceReportCountAggregateOutputType | null
    _avg: DueDiligenceReportAvgAggregateOutputType | null
    _sum: DueDiligenceReportSumAggregateOutputType | null
    _min: DueDiligenceReportMinAggregateOutputType | null
    _max: DueDiligenceReportMaxAggregateOutputType | null
  }

  export type DueDiligenceReportAvgAggregateOutputType = {
    riskScore: number | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    technologyScore: number | null
  }

  export type DueDiligenceReportSumAggregateOutputType = {
    riskScore: number | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    technologyScore: number | null
  }

  export type DueDiligenceReportMinAggregateOutputType = {
    id: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    summary: string | null
    riskScore: number | null
    sentiment: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    technologyScore: number | null
    aiGenerated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    startupId: string | null
    tokenId: string | null
  }

  export type DueDiligenceReportMaxAggregateOutputType = {
    id: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    summary: string | null
    riskScore: number | null
    sentiment: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    technologyScore: number | null
    aiGenerated: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    startupId: string | null
    tokenId: string | null
  }

  export type DueDiligenceReportCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    summary: number
    riskScore: number
    sentiment: number
    financialScore: number
    teamScore: number
    marketScore: number
    technologyScore: number
    aiGenerated: number
    createdAt: number
    updatedAt: number
    startupId: number
    tokenId: number
    _all: number
  }


  export type DueDiligenceReportAvgAggregateInputType = {
    riskScore?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    technologyScore?: true
  }

  export type DueDiligenceReportSumAggregateInputType = {
    riskScore?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    technologyScore?: true
  }

  export type DueDiligenceReportMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    summary?: true
    riskScore?: true
    sentiment?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    technologyScore?: true
    aiGenerated?: true
    createdAt?: true
    updatedAt?: true
    startupId?: true
    tokenId?: true
  }

  export type DueDiligenceReportMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    summary?: true
    riskScore?: true
    sentiment?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    technologyScore?: true
    aiGenerated?: true
    createdAt?: true
    updatedAt?: true
    startupId?: true
    tokenId?: true
  }

  export type DueDiligenceReportCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    summary?: true
    riskScore?: true
    sentiment?: true
    financialScore?: true
    teamScore?: true
    marketScore?: true
    technologyScore?: true
    aiGenerated?: true
    createdAt?: true
    updatedAt?: true
    startupId?: true
    tokenId?: true
    _all?: true
  }

  export type DueDiligenceReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DueDiligenceReport to aggregate.
     */
    where?: DueDiligenceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligenceReports to fetch.
     */
    orderBy?: DueDiligenceReportOrderByWithRelationInput | DueDiligenceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DueDiligenceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligenceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligenceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DueDiligenceReports
    **/
    _count?: true | DueDiligenceReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DueDiligenceReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DueDiligenceReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DueDiligenceReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DueDiligenceReportMaxAggregateInputType
  }

  export type GetDueDiligenceReportAggregateType<T extends DueDiligenceReportAggregateArgs> = {
        [P in keyof T & keyof AggregateDueDiligenceReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDueDiligenceReport[P]>
      : GetScalarType<T[P], AggregateDueDiligenceReport[P]>
  }




  export type DueDiligenceReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DueDiligenceReportWhereInput
    orderBy?: DueDiligenceReportOrderByWithAggregationInput | DueDiligenceReportOrderByWithAggregationInput[]
    by: DueDiligenceReportScalarFieldEnum[] | DueDiligenceReportScalarFieldEnum
    having?: DueDiligenceReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DueDiligenceReportCountAggregateInputType | true
    _avg?: DueDiligenceReportAvgAggregateInputType
    _sum?: DueDiligenceReportSumAggregateInputType
    _min?: DueDiligenceReportMinAggregateInputType
    _max?: DueDiligenceReportMaxAggregateInputType
  }

  export type DueDiligenceReportGroupByOutputType = {
    id: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment: string | null
    financialScore: number | null
    teamScore: number | null
    marketScore: number | null
    technologyScore: number | null
    aiGenerated: boolean
    createdAt: Date
    updatedAt: Date
    startupId: string | null
    tokenId: string | null
    _count: DueDiligenceReportCountAggregateOutputType | null
    _avg: DueDiligenceReportAvgAggregateOutputType | null
    _sum: DueDiligenceReportSumAggregateOutputType | null
    _min: DueDiligenceReportMinAggregateOutputType | null
    _max: DueDiligenceReportMaxAggregateOutputType | null
  }

  type GetDueDiligenceReportGroupByPayload<T extends DueDiligenceReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DueDiligenceReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DueDiligenceReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DueDiligenceReportGroupByOutputType[P]>
            : GetScalarType<T[P], DueDiligenceReportGroupByOutputType[P]>
        }
      >
    >


  export type DueDiligenceReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    summary?: boolean
    riskScore?: boolean
    sentiment?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    technologyScore?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
    Startup?: boolean | DueDiligenceReport$StartupArgs<ExtArgs>
    Token?: boolean | DueDiligenceReport$TokenArgs<ExtArgs>
  }, ExtArgs["result"]["dueDiligenceReport"]>

  export type DueDiligenceReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    summary?: boolean
    riskScore?: boolean
    sentiment?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    technologyScore?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
    Startup?: boolean | DueDiligenceReport$StartupArgs<ExtArgs>
    Token?: boolean | DueDiligenceReport$TokenArgs<ExtArgs>
  }, ExtArgs["result"]["dueDiligenceReport"]>

  export type DueDiligenceReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    summary?: boolean
    riskScore?: boolean
    sentiment?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    technologyScore?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
    Startup?: boolean | DueDiligenceReport$StartupArgs<ExtArgs>
    Token?: boolean | DueDiligenceReport$TokenArgs<ExtArgs>
  }, ExtArgs["result"]["dueDiligenceReport"]>

  export type DueDiligenceReportSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    summary?: boolean
    riskScore?: boolean
    sentiment?: boolean
    financialScore?: boolean
    teamScore?: boolean
    marketScore?: boolean
    technologyScore?: boolean
    aiGenerated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
  }

  export type DueDiligenceReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "summary" | "riskScore" | "sentiment" | "financialScore" | "teamScore" | "marketScore" | "technologyScore" | "aiGenerated" | "createdAt" | "updatedAt" | "startupId" | "tokenId", ExtArgs["result"]["dueDiligenceReport"]>
  export type DueDiligenceReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Startup?: boolean | DueDiligenceReport$StartupArgs<ExtArgs>
    Token?: boolean | DueDiligenceReport$TokenArgs<ExtArgs>
  }
  export type DueDiligenceReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Startup?: boolean | DueDiligenceReport$StartupArgs<ExtArgs>
    Token?: boolean | DueDiligenceReport$TokenArgs<ExtArgs>
  }
  export type DueDiligenceReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Startup?: boolean | DueDiligenceReport$StartupArgs<ExtArgs>
    Token?: boolean | DueDiligenceReport$TokenArgs<ExtArgs>
  }

  export type $DueDiligenceReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DueDiligenceReport"
    objects: {
      Startup: Prisma.$StartupPayload<ExtArgs> | null
      Token: Prisma.$TokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: $Enums.EntityType
      entityId: string
      summary: string
      riskScore: number
      sentiment: string | null
      financialScore: number | null
      teamScore: number | null
      marketScore: number | null
      technologyScore: number | null
      aiGenerated: boolean
      createdAt: Date
      updatedAt: Date
      startupId: string | null
      tokenId: string | null
    }, ExtArgs["result"]["dueDiligenceReport"]>
    composites: {}
  }

  type DueDiligenceReportGetPayload<S extends boolean | null | undefined | DueDiligenceReportDefaultArgs> = $Result.GetResult<Prisma.$DueDiligenceReportPayload, S>

  type DueDiligenceReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DueDiligenceReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DueDiligenceReportCountAggregateInputType | true
    }

  export interface DueDiligenceReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DueDiligenceReport'], meta: { name: 'DueDiligenceReport' } }
    /**
     * Find zero or one DueDiligenceReport that matches the filter.
     * @param {DueDiligenceReportFindUniqueArgs} args - Arguments to find a DueDiligenceReport
     * @example
     * // Get one DueDiligenceReport
     * const dueDiligenceReport = await prisma.dueDiligenceReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DueDiligenceReportFindUniqueArgs>(args: SelectSubset<T, DueDiligenceReportFindUniqueArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DueDiligenceReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DueDiligenceReportFindUniqueOrThrowArgs} args - Arguments to find a DueDiligenceReport
     * @example
     * // Get one DueDiligenceReport
     * const dueDiligenceReport = await prisma.dueDiligenceReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DueDiligenceReportFindUniqueOrThrowArgs>(args: SelectSubset<T, DueDiligenceReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DueDiligenceReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportFindFirstArgs} args - Arguments to find a DueDiligenceReport
     * @example
     * // Get one DueDiligenceReport
     * const dueDiligenceReport = await prisma.dueDiligenceReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DueDiligenceReportFindFirstArgs>(args?: SelectSubset<T, DueDiligenceReportFindFirstArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DueDiligenceReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportFindFirstOrThrowArgs} args - Arguments to find a DueDiligenceReport
     * @example
     * // Get one DueDiligenceReport
     * const dueDiligenceReport = await prisma.dueDiligenceReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DueDiligenceReportFindFirstOrThrowArgs>(args?: SelectSubset<T, DueDiligenceReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DueDiligenceReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DueDiligenceReports
     * const dueDiligenceReports = await prisma.dueDiligenceReport.findMany()
     * 
     * // Get first 10 DueDiligenceReports
     * const dueDiligenceReports = await prisma.dueDiligenceReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dueDiligenceReportWithIdOnly = await prisma.dueDiligenceReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DueDiligenceReportFindManyArgs>(args?: SelectSubset<T, DueDiligenceReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DueDiligenceReport.
     * @param {DueDiligenceReportCreateArgs} args - Arguments to create a DueDiligenceReport.
     * @example
     * // Create one DueDiligenceReport
     * const DueDiligenceReport = await prisma.dueDiligenceReport.create({
     *   data: {
     *     // ... data to create a DueDiligenceReport
     *   }
     * })
     * 
     */
    create<T extends DueDiligenceReportCreateArgs>(args: SelectSubset<T, DueDiligenceReportCreateArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DueDiligenceReports.
     * @param {DueDiligenceReportCreateManyArgs} args - Arguments to create many DueDiligenceReports.
     * @example
     * // Create many DueDiligenceReports
     * const dueDiligenceReport = await prisma.dueDiligenceReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DueDiligenceReportCreateManyArgs>(args?: SelectSubset<T, DueDiligenceReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DueDiligenceReports and returns the data saved in the database.
     * @param {DueDiligenceReportCreateManyAndReturnArgs} args - Arguments to create many DueDiligenceReports.
     * @example
     * // Create many DueDiligenceReports
     * const dueDiligenceReport = await prisma.dueDiligenceReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DueDiligenceReports and only return the `id`
     * const dueDiligenceReportWithIdOnly = await prisma.dueDiligenceReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DueDiligenceReportCreateManyAndReturnArgs>(args?: SelectSubset<T, DueDiligenceReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DueDiligenceReport.
     * @param {DueDiligenceReportDeleteArgs} args - Arguments to delete one DueDiligenceReport.
     * @example
     * // Delete one DueDiligenceReport
     * const DueDiligenceReport = await prisma.dueDiligenceReport.delete({
     *   where: {
     *     // ... filter to delete one DueDiligenceReport
     *   }
     * })
     * 
     */
    delete<T extends DueDiligenceReportDeleteArgs>(args: SelectSubset<T, DueDiligenceReportDeleteArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DueDiligenceReport.
     * @param {DueDiligenceReportUpdateArgs} args - Arguments to update one DueDiligenceReport.
     * @example
     * // Update one DueDiligenceReport
     * const dueDiligenceReport = await prisma.dueDiligenceReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DueDiligenceReportUpdateArgs>(args: SelectSubset<T, DueDiligenceReportUpdateArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DueDiligenceReports.
     * @param {DueDiligenceReportDeleteManyArgs} args - Arguments to filter DueDiligenceReports to delete.
     * @example
     * // Delete a few DueDiligenceReports
     * const { count } = await prisma.dueDiligenceReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DueDiligenceReportDeleteManyArgs>(args?: SelectSubset<T, DueDiligenceReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DueDiligenceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DueDiligenceReports
     * const dueDiligenceReport = await prisma.dueDiligenceReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DueDiligenceReportUpdateManyArgs>(args: SelectSubset<T, DueDiligenceReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DueDiligenceReports and returns the data updated in the database.
     * @param {DueDiligenceReportUpdateManyAndReturnArgs} args - Arguments to update many DueDiligenceReports.
     * @example
     * // Update many DueDiligenceReports
     * const dueDiligenceReport = await prisma.dueDiligenceReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DueDiligenceReports and only return the `id`
     * const dueDiligenceReportWithIdOnly = await prisma.dueDiligenceReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DueDiligenceReportUpdateManyAndReturnArgs>(args: SelectSubset<T, DueDiligenceReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DueDiligenceReport.
     * @param {DueDiligenceReportUpsertArgs} args - Arguments to update or create a DueDiligenceReport.
     * @example
     * // Update or create a DueDiligenceReport
     * const dueDiligenceReport = await prisma.dueDiligenceReport.upsert({
     *   create: {
     *     // ... data to create a DueDiligenceReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DueDiligenceReport we want to update
     *   }
     * })
     */
    upsert<T extends DueDiligenceReportUpsertArgs>(args: SelectSubset<T, DueDiligenceReportUpsertArgs<ExtArgs>>): Prisma__DueDiligenceReportClient<$Result.GetResult<Prisma.$DueDiligenceReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DueDiligenceReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportCountArgs} args - Arguments to filter DueDiligenceReports to count.
     * @example
     * // Count the number of DueDiligenceReports
     * const count = await prisma.dueDiligenceReport.count({
     *   where: {
     *     // ... the filter for the DueDiligenceReports we want to count
     *   }
     * })
    **/
    count<T extends DueDiligenceReportCountArgs>(
      args?: Subset<T, DueDiligenceReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DueDiligenceReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DueDiligenceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DueDiligenceReportAggregateArgs>(args: Subset<T, DueDiligenceReportAggregateArgs>): Prisma.PrismaPromise<GetDueDiligenceReportAggregateType<T>>

    /**
     * Group by DueDiligenceReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DueDiligenceReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DueDiligenceReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DueDiligenceReportGroupByArgs['orderBy'] }
        : { orderBy?: DueDiligenceReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DueDiligenceReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDueDiligenceReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DueDiligenceReport model
   */
  readonly fields: DueDiligenceReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DueDiligenceReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DueDiligenceReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Startup<T extends DueDiligenceReport$StartupArgs<ExtArgs> = {}>(args?: Subset<T, DueDiligenceReport$StartupArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Token<T extends DueDiligenceReport$TokenArgs<ExtArgs> = {}>(args?: Subset<T, DueDiligenceReport$TokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DueDiligenceReport model
   */
  interface DueDiligenceReportFieldRefs {
    readonly id: FieldRef<"DueDiligenceReport", 'String'>
    readonly entityType: FieldRef<"DueDiligenceReport", 'EntityType'>
    readonly entityId: FieldRef<"DueDiligenceReport", 'String'>
    readonly summary: FieldRef<"DueDiligenceReport", 'String'>
    readonly riskScore: FieldRef<"DueDiligenceReport", 'Int'>
    readonly sentiment: FieldRef<"DueDiligenceReport", 'String'>
    readonly financialScore: FieldRef<"DueDiligenceReport", 'Int'>
    readonly teamScore: FieldRef<"DueDiligenceReport", 'Int'>
    readonly marketScore: FieldRef<"DueDiligenceReport", 'Int'>
    readonly technologyScore: FieldRef<"DueDiligenceReport", 'Int'>
    readonly aiGenerated: FieldRef<"DueDiligenceReport", 'Boolean'>
    readonly createdAt: FieldRef<"DueDiligenceReport", 'DateTime'>
    readonly updatedAt: FieldRef<"DueDiligenceReport", 'DateTime'>
    readonly startupId: FieldRef<"DueDiligenceReport", 'String'>
    readonly tokenId: FieldRef<"DueDiligenceReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DueDiligenceReport findUnique
   */
  export type DueDiligenceReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligenceReport to fetch.
     */
    where: DueDiligenceReportWhereUniqueInput
  }

  /**
   * DueDiligenceReport findUniqueOrThrow
   */
  export type DueDiligenceReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligenceReport to fetch.
     */
    where: DueDiligenceReportWhereUniqueInput
  }

  /**
   * DueDiligenceReport findFirst
   */
  export type DueDiligenceReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligenceReport to fetch.
     */
    where?: DueDiligenceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligenceReports to fetch.
     */
    orderBy?: DueDiligenceReportOrderByWithRelationInput | DueDiligenceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDiligenceReports.
     */
    cursor?: DueDiligenceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligenceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligenceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDiligenceReports.
     */
    distinct?: DueDiligenceReportScalarFieldEnum | DueDiligenceReportScalarFieldEnum[]
  }

  /**
   * DueDiligenceReport findFirstOrThrow
   */
  export type DueDiligenceReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligenceReport to fetch.
     */
    where?: DueDiligenceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligenceReports to fetch.
     */
    orderBy?: DueDiligenceReportOrderByWithRelationInput | DueDiligenceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DueDiligenceReports.
     */
    cursor?: DueDiligenceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligenceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligenceReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DueDiligenceReports.
     */
    distinct?: DueDiligenceReportScalarFieldEnum | DueDiligenceReportScalarFieldEnum[]
  }

  /**
   * DueDiligenceReport findMany
   */
  export type DueDiligenceReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * Filter, which DueDiligenceReports to fetch.
     */
    where?: DueDiligenceReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DueDiligenceReports to fetch.
     */
    orderBy?: DueDiligenceReportOrderByWithRelationInput | DueDiligenceReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DueDiligenceReports.
     */
    cursor?: DueDiligenceReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DueDiligenceReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DueDiligenceReports.
     */
    skip?: number
    distinct?: DueDiligenceReportScalarFieldEnum | DueDiligenceReportScalarFieldEnum[]
  }

  /**
   * DueDiligenceReport create
   */
  export type DueDiligenceReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * The data needed to create a DueDiligenceReport.
     */
    data: XOR<DueDiligenceReportCreateInput, DueDiligenceReportUncheckedCreateInput>
  }

  /**
   * DueDiligenceReport createMany
   */
  export type DueDiligenceReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DueDiligenceReports.
     */
    data: DueDiligenceReportCreateManyInput | DueDiligenceReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DueDiligenceReport createManyAndReturn
   */
  export type DueDiligenceReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * The data used to create many DueDiligenceReports.
     */
    data: DueDiligenceReportCreateManyInput | DueDiligenceReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DueDiligenceReport update
   */
  export type DueDiligenceReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * The data needed to update a DueDiligenceReport.
     */
    data: XOR<DueDiligenceReportUpdateInput, DueDiligenceReportUncheckedUpdateInput>
    /**
     * Choose, which DueDiligenceReport to update.
     */
    where: DueDiligenceReportWhereUniqueInput
  }

  /**
   * DueDiligenceReport updateMany
   */
  export type DueDiligenceReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DueDiligenceReports.
     */
    data: XOR<DueDiligenceReportUpdateManyMutationInput, DueDiligenceReportUncheckedUpdateManyInput>
    /**
     * Filter which DueDiligenceReports to update
     */
    where?: DueDiligenceReportWhereInput
    /**
     * Limit how many DueDiligenceReports to update.
     */
    limit?: number
  }

  /**
   * DueDiligenceReport updateManyAndReturn
   */
  export type DueDiligenceReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * The data used to update DueDiligenceReports.
     */
    data: XOR<DueDiligenceReportUpdateManyMutationInput, DueDiligenceReportUncheckedUpdateManyInput>
    /**
     * Filter which DueDiligenceReports to update
     */
    where?: DueDiligenceReportWhereInput
    /**
     * Limit how many DueDiligenceReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DueDiligenceReport upsert
   */
  export type DueDiligenceReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * The filter to search for the DueDiligenceReport to update in case it exists.
     */
    where: DueDiligenceReportWhereUniqueInput
    /**
     * In case the DueDiligenceReport found by the `where` argument doesn't exist, create a new DueDiligenceReport with this data.
     */
    create: XOR<DueDiligenceReportCreateInput, DueDiligenceReportUncheckedCreateInput>
    /**
     * In case the DueDiligenceReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DueDiligenceReportUpdateInput, DueDiligenceReportUncheckedUpdateInput>
  }

  /**
   * DueDiligenceReport delete
   */
  export type DueDiligenceReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
    /**
     * Filter which DueDiligenceReport to delete.
     */
    where: DueDiligenceReportWhereUniqueInput
  }

  /**
   * DueDiligenceReport deleteMany
   */
  export type DueDiligenceReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DueDiligenceReports to delete
     */
    where?: DueDiligenceReportWhereInput
    /**
     * Limit how many DueDiligenceReports to delete.
     */
    limit?: number
  }

  /**
   * DueDiligenceReport.Startup
   */
  export type DueDiligenceReport$StartupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
  }

  /**
   * DueDiligenceReport.Token
   */
  export type DueDiligenceReport$TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * DueDiligenceReport without action
   */
  export type DueDiligenceReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DueDiligenceReport
     */
    select?: DueDiligenceReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DueDiligenceReport
     */
    omit?: DueDiligenceReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DueDiligenceReportInclude<ExtArgs> | null
  }


  /**
   * Model AdminActivityLog
   */

  export type AggregateAdminActivityLog = {
    _count: AdminActivityLogCountAggregateOutputType | null
    _min: AdminActivityLogMinAggregateOutputType | null
    _max: AdminActivityLogMaxAggregateOutputType | null
  }

  export type AdminActivityLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetId: string | null
    targetType: $Enums.EntityType | null
    timestamp: Date | null
  }

  export type AdminActivityLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetId: string | null
    targetType: $Enums.EntityType | null
    timestamp: Date | null
  }

  export type AdminActivityLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    targetId: number
    targetType: number
    details: number
    timestamp: number
    _all: number
  }


  export type AdminActivityLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetId?: true
    targetType?: true
    timestamp?: true
  }

  export type AdminActivityLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetId?: true
    targetType?: true
    timestamp?: true
  }

  export type AdminActivityLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetId?: true
    targetType?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type AdminActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActivityLog to aggregate.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminActivityLogs
    **/
    _count?: true | AdminActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminActivityLogMaxAggregateInputType
  }

  export type GetAdminActivityLogAggregateType<T extends AdminActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminActivityLog[P]>
      : GetScalarType<T[P], AggregateAdminActivityLog[P]>
  }




  export type AdminActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActivityLogWhereInput
    orderBy?: AdminActivityLogOrderByWithAggregationInput | AdminActivityLogOrderByWithAggregationInput[]
    by: AdminActivityLogScalarFieldEnum[] | AdminActivityLogScalarFieldEnum
    having?: AdminActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminActivityLogCountAggregateInputType | true
    _min?: AdminActivityLogMinAggregateInputType
    _max?: AdminActivityLogMaxAggregateInputType
  }

  export type AdminActivityLogGroupByOutputType = {
    id: string
    adminId: string
    action: string
    targetId: string | null
    targetType: $Enums.EntityType | null
    details: JsonValue | null
    timestamp: Date
    _count: AdminActivityLogCountAggregateOutputType | null
    _min: AdminActivityLogMinAggregateOutputType | null
    _max: AdminActivityLogMaxAggregateOutputType | null
  }

  type GetAdminActivityLogGroupByPayload<T extends AdminActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    timestamp?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActivityLog"]>

  export type AdminActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    timestamp?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActivityLog"]>

  export type AdminActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    timestamp?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActivityLog"]>

  export type AdminActivityLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetId?: boolean
    targetType?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type AdminActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "targetId" | "targetType" | "details" | "timestamp", ExtArgs["result"]["adminActivityLog"]>
  export type AdminActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminActivityLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      targetId: string | null
      targetType: $Enums.EntityType | null
      details: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["adminActivityLog"]>
    composites: {}
  }

  type AdminActivityLogGetPayload<S extends boolean | null | undefined | AdminActivityLogDefaultArgs> = $Result.GetResult<Prisma.$AdminActivityLogPayload, S>

  type AdminActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminActivityLogCountAggregateInputType | true
    }

  export interface AdminActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminActivityLog'], meta: { name: 'AdminActivityLog' } }
    /**
     * Find zero or one AdminActivityLog that matches the filter.
     * @param {AdminActivityLogFindUniqueArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminActivityLogFindUniqueArgs>(args: SelectSubset<T, AdminActivityLogFindUniqueArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminActivityLogFindUniqueOrThrowArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogFindFirstArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminActivityLogFindFirstArgs>(args?: SelectSubset<T, AdminActivityLogFindFirstArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogFindFirstOrThrowArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminActivityLogs
     * const adminActivityLogs = await prisma.adminActivityLog.findMany()
     * 
     * // Get first 10 AdminActivityLogs
     * const adminActivityLogs = await prisma.adminActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminActivityLogWithIdOnly = await prisma.adminActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminActivityLogFindManyArgs>(args?: SelectSubset<T, AdminActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminActivityLog.
     * @param {AdminActivityLogCreateArgs} args - Arguments to create a AdminActivityLog.
     * @example
     * // Create one AdminActivityLog
     * const AdminActivityLog = await prisma.adminActivityLog.create({
     *   data: {
     *     // ... data to create a AdminActivityLog
     *   }
     * })
     * 
     */
    create<T extends AdminActivityLogCreateArgs>(args: SelectSubset<T, AdminActivityLogCreateArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminActivityLogs.
     * @param {AdminActivityLogCreateManyArgs} args - Arguments to create many AdminActivityLogs.
     * @example
     * // Create many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminActivityLogCreateManyArgs>(args?: SelectSubset<T, AdminActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminActivityLogs and returns the data saved in the database.
     * @param {AdminActivityLogCreateManyAndReturnArgs} args - Arguments to create many AdminActivityLogs.
     * @example
     * // Create many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminActivityLogs and only return the `id`
     * const adminActivityLogWithIdOnly = await prisma.adminActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminActivityLog.
     * @param {AdminActivityLogDeleteArgs} args - Arguments to delete one AdminActivityLog.
     * @example
     * // Delete one AdminActivityLog
     * const AdminActivityLog = await prisma.adminActivityLog.delete({
     *   where: {
     *     // ... filter to delete one AdminActivityLog
     *   }
     * })
     * 
     */
    delete<T extends AdminActivityLogDeleteArgs>(args: SelectSubset<T, AdminActivityLogDeleteArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminActivityLog.
     * @param {AdminActivityLogUpdateArgs} args - Arguments to update one AdminActivityLog.
     * @example
     * // Update one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminActivityLogUpdateArgs>(args: SelectSubset<T, AdminActivityLogUpdateArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminActivityLogs.
     * @param {AdminActivityLogDeleteManyArgs} args - Arguments to filter AdminActivityLogs to delete.
     * @example
     * // Delete a few AdminActivityLogs
     * const { count } = await prisma.adminActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminActivityLogDeleteManyArgs>(args?: SelectSubset<T, AdminActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminActivityLogUpdateManyArgs>(args: SelectSubset<T, AdminActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActivityLogs and returns the data updated in the database.
     * @param {AdminActivityLogUpdateManyAndReturnArgs} args - Arguments to update many AdminActivityLogs.
     * @example
     * // Update many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminActivityLogs and only return the `id`
     * const adminActivityLogWithIdOnly = await prisma.adminActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminActivityLog.
     * @param {AdminActivityLogUpsertArgs} args - Arguments to update or create a AdminActivityLog.
     * @example
     * // Update or create a AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.upsert({
     *   create: {
     *     // ... data to create a AdminActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminActivityLogUpsertArgs>(args: SelectSubset<T, AdminActivityLogUpsertArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogCountArgs} args - Arguments to filter AdminActivityLogs to count.
     * @example
     * // Count the number of AdminActivityLogs
     * const count = await prisma.adminActivityLog.count({
     *   where: {
     *     // ... the filter for the AdminActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminActivityLogCountArgs>(
      args?: Subset<T, AdminActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminActivityLogAggregateArgs>(args: Subset<T, AdminActivityLogAggregateArgs>): Prisma.PrismaPromise<GetAdminActivityLogAggregateType<T>>

    /**
     * Group by AdminActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminActivityLog model
   */
  readonly fields: AdminActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminActivityLog model
   */
  interface AdminActivityLogFieldRefs {
    readonly id: FieldRef<"AdminActivityLog", 'String'>
    readonly adminId: FieldRef<"AdminActivityLog", 'String'>
    readonly action: FieldRef<"AdminActivityLog", 'String'>
    readonly targetId: FieldRef<"AdminActivityLog", 'String'>
    readonly targetType: FieldRef<"AdminActivityLog", 'EntityType'>
    readonly details: FieldRef<"AdminActivityLog", 'Json'>
    readonly timestamp: FieldRef<"AdminActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminActivityLog findUnique
   */
  export type AdminActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog findUniqueOrThrow
   */
  export type AdminActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog findFirst
   */
  export type AdminActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActivityLogs.
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActivityLogs.
     */
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * AdminActivityLog findFirstOrThrow
   */
  export type AdminActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActivityLogs.
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActivityLogs.
     */
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * AdminActivityLog findMany
   */
  export type AdminActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLogs to fetch.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminActivityLogs.
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * AdminActivityLog create
   */
  export type AdminActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminActivityLog.
     */
    data: XOR<AdminActivityLogCreateInput, AdminActivityLogUncheckedCreateInput>
  }

  /**
   * AdminActivityLog createMany
   */
  export type AdminActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminActivityLogs.
     */
    data: AdminActivityLogCreateManyInput | AdminActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminActivityLog createManyAndReturn
   */
  export type AdminActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminActivityLogs.
     */
    data: AdminActivityLogCreateManyInput | AdminActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminActivityLog update
   */
  export type AdminActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminActivityLog.
     */
    data: XOR<AdminActivityLogUpdateInput, AdminActivityLogUncheckedUpdateInput>
    /**
     * Choose, which AdminActivityLog to update.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog updateMany
   */
  export type AdminActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminActivityLogs.
     */
    data: XOR<AdminActivityLogUpdateManyMutationInput, AdminActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminActivityLogs to update
     */
    where?: AdminActivityLogWhereInput
    /**
     * Limit how many AdminActivityLogs to update.
     */
    limit?: number
  }

  /**
   * AdminActivityLog updateManyAndReturn
   */
  export type AdminActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminActivityLogs.
     */
    data: XOR<AdminActivityLogUpdateManyMutationInput, AdminActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminActivityLogs to update
     */
    where?: AdminActivityLogWhereInput
    /**
     * Limit how many AdminActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminActivityLog upsert
   */
  export type AdminActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminActivityLog to update in case it exists.
     */
    where: AdminActivityLogWhereUniqueInput
    /**
     * In case the AdminActivityLog found by the `where` argument doesn't exist, create a new AdminActivityLog with this data.
     */
    create: XOR<AdminActivityLogCreateInput, AdminActivityLogUncheckedCreateInput>
    /**
     * In case the AdminActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminActivityLogUpdateInput, AdminActivityLogUncheckedUpdateInput>
  }

  /**
   * AdminActivityLog delete
   */
  export type AdminActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter which AdminActivityLog to delete.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog deleteMany
   */
  export type AdminActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActivityLogs to delete
     */
    where?: AdminActivityLogWhereInput
    /**
     * Limit how many AdminActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminActivityLog without action
   */
  export type AdminActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model PaymentIntent
   */

  export type AggregatePaymentIntent = {
    _count: PaymentIntentCountAggregateOutputType | null
    _avg: PaymentIntentAvgAggregateOutputType | null
    _sum: PaymentIntentSumAggregateOutputType | null
    _min: PaymentIntentMinAggregateOutputType | null
    _max: PaymentIntentMaxAggregateOutputType | null
  }

  export type PaymentIntentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentIntentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentIntentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentIntentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentIntentCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerId: number
    amount: number
    currency: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentIntentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentIntentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentIntentMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentIntentMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    amount?: true
    currency?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentIntentCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerId?: true
    amount?: true
    currency?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentIntentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentIntent to aggregate.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentIntents
    **/
    _count?: true | PaymentIntentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentIntentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentIntentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentIntentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentIntentMaxAggregateInputType
  }

  export type GetPaymentIntentAggregateType<T extends PaymentIntentAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentIntent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentIntent[P]>
      : GetScalarType<T[P], AggregatePaymentIntent[P]>
  }




  export type PaymentIntentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentIntentWhereInput
    orderBy?: PaymentIntentOrderByWithAggregationInput | PaymentIntentOrderByWithAggregationInput[]
    by: PaymentIntentScalarFieldEnum[] | PaymentIntentScalarFieldEnum
    having?: PaymentIntentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentIntentCountAggregateInputType | true
    _avg?: PaymentIntentAvgAggregateInputType
    _sum?: PaymentIntentSumAggregateInputType
    _min?: PaymentIntentMinAggregateInputType
    _max?: PaymentIntentMaxAggregateInputType
  }

  export type PaymentIntentGroupByOutputType = {
    id: string
    userId: string
    provider: string
    providerId: string
    amount: Decimal
    currency: string
    status: $Enums.PaymentStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentIntentCountAggregateOutputType | null
    _avg: PaymentIntentAvgAggregateOutputType | null
    _sum: PaymentIntentSumAggregateOutputType | null
    _min: PaymentIntentMinAggregateOutputType | null
    _max: PaymentIntentMaxAggregateOutputType | null
  }

  type GetPaymentIntentGroupByPayload<T extends PaymentIntentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentIntentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentIntentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentIntentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentIntentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentIntentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentIntent"]>

  export type PaymentIntentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentIntent"]>

  export type PaymentIntentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentIntent"]>

  export type PaymentIntentSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentIntentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "providerId" | "amount" | "currency" | "status" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentIntent"]>
  export type PaymentIntentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIntentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIntentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentIntentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentIntent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      providerId: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PaymentStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentIntent"]>
    composites: {}
  }

  type PaymentIntentGetPayload<S extends boolean | null | undefined | PaymentIntentDefaultArgs> = $Result.GetResult<Prisma.$PaymentIntentPayload, S>

  type PaymentIntentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentIntentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentIntentCountAggregateInputType | true
    }

  export interface PaymentIntentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentIntent'], meta: { name: 'PaymentIntent' } }
    /**
     * Find zero or one PaymentIntent that matches the filter.
     * @param {PaymentIntentFindUniqueArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentIntentFindUniqueArgs>(args: SelectSubset<T, PaymentIntentFindUniqueArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentIntent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentIntentFindUniqueOrThrowArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentIntentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentIntentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentIntent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentFindFirstArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentIntentFindFirstArgs>(args?: SelectSubset<T, PaymentIntentFindFirstArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentIntent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentFindFirstOrThrowArgs} args - Arguments to find a PaymentIntent
     * @example
     * // Get one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentIntentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentIntentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentIntents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentIntents
     * const paymentIntents = await prisma.paymentIntent.findMany()
     * 
     * // Get first 10 PaymentIntents
     * const paymentIntents = await prisma.paymentIntent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentIntentWithIdOnly = await prisma.paymentIntent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentIntentFindManyArgs>(args?: SelectSubset<T, PaymentIntentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentIntent.
     * @param {PaymentIntentCreateArgs} args - Arguments to create a PaymentIntent.
     * @example
     * // Create one PaymentIntent
     * const PaymentIntent = await prisma.paymentIntent.create({
     *   data: {
     *     // ... data to create a PaymentIntent
     *   }
     * })
     * 
     */
    create<T extends PaymentIntentCreateArgs>(args: SelectSubset<T, PaymentIntentCreateArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentIntents.
     * @param {PaymentIntentCreateManyArgs} args - Arguments to create many PaymentIntents.
     * @example
     * // Create many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentIntentCreateManyArgs>(args?: SelectSubset<T, PaymentIntentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentIntents and returns the data saved in the database.
     * @param {PaymentIntentCreateManyAndReturnArgs} args - Arguments to create many PaymentIntents.
     * @example
     * // Create many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentIntents and only return the `id`
     * const paymentIntentWithIdOnly = await prisma.paymentIntent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentIntentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentIntentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentIntent.
     * @param {PaymentIntentDeleteArgs} args - Arguments to delete one PaymentIntent.
     * @example
     * // Delete one PaymentIntent
     * const PaymentIntent = await prisma.paymentIntent.delete({
     *   where: {
     *     // ... filter to delete one PaymentIntent
     *   }
     * })
     * 
     */
    delete<T extends PaymentIntentDeleteArgs>(args: SelectSubset<T, PaymentIntentDeleteArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentIntent.
     * @param {PaymentIntentUpdateArgs} args - Arguments to update one PaymentIntent.
     * @example
     * // Update one PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentIntentUpdateArgs>(args: SelectSubset<T, PaymentIntentUpdateArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentIntents.
     * @param {PaymentIntentDeleteManyArgs} args - Arguments to filter PaymentIntents to delete.
     * @example
     * // Delete a few PaymentIntents
     * const { count } = await prisma.paymentIntent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentIntentDeleteManyArgs>(args?: SelectSubset<T, PaymentIntentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentIntents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentIntentUpdateManyArgs>(args: SelectSubset<T, PaymentIntentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentIntents and returns the data updated in the database.
     * @param {PaymentIntentUpdateManyAndReturnArgs} args - Arguments to update many PaymentIntents.
     * @example
     * // Update many PaymentIntents
     * const paymentIntent = await prisma.paymentIntent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentIntents and only return the `id`
     * const paymentIntentWithIdOnly = await prisma.paymentIntent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentIntentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentIntentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentIntent.
     * @param {PaymentIntentUpsertArgs} args - Arguments to update or create a PaymentIntent.
     * @example
     * // Update or create a PaymentIntent
     * const paymentIntent = await prisma.paymentIntent.upsert({
     *   create: {
     *     // ... data to create a PaymentIntent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentIntent we want to update
     *   }
     * })
     */
    upsert<T extends PaymentIntentUpsertArgs>(args: SelectSubset<T, PaymentIntentUpsertArgs<ExtArgs>>): Prisma__PaymentIntentClient<$Result.GetResult<Prisma.$PaymentIntentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentIntents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentCountArgs} args - Arguments to filter PaymentIntents to count.
     * @example
     * // Count the number of PaymentIntents
     * const count = await prisma.paymentIntent.count({
     *   where: {
     *     // ... the filter for the PaymentIntents we want to count
     *   }
     * })
    **/
    count<T extends PaymentIntentCountArgs>(
      args?: Subset<T, PaymentIntentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentIntentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentIntent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentIntentAggregateArgs>(args: Subset<T, PaymentIntentAggregateArgs>): Prisma.PrismaPromise<GetPaymentIntentAggregateType<T>>

    /**
     * Group by PaymentIntent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentIntentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentIntentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentIntentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentIntentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentIntentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentIntentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentIntent model
   */
  readonly fields: PaymentIntentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentIntent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentIntentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentIntent model
   */
  interface PaymentIntentFieldRefs {
    readonly id: FieldRef<"PaymentIntent", 'String'>
    readonly userId: FieldRef<"PaymentIntent", 'String'>
    readonly provider: FieldRef<"PaymentIntent", 'String'>
    readonly providerId: FieldRef<"PaymentIntent", 'String'>
    readonly amount: FieldRef<"PaymentIntent", 'Decimal'>
    readonly currency: FieldRef<"PaymentIntent", 'String'>
    readonly status: FieldRef<"PaymentIntent", 'PaymentStatus'>
    readonly metadata: FieldRef<"PaymentIntent", 'Json'>
    readonly createdAt: FieldRef<"PaymentIntent", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentIntent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentIntent findUnique
   */
  export type PaymentIntentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent findUniqueOrThrow
   */
  export type PaymentIntentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent findFirst
   */
  export type PaymentIntentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentIntents.
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentIntents.
     */
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * PaymentIntent findFirstOrThrow
   */
  export type PaymentIntentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntent to fetch.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentIntents.
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentIntents.
     */
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * PaymentIntent findMany
   */
  export type PaymentIntentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter, which PaymentIntents to fetch.
     */
    where?: PaymentIntentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentIntents to fetch.
     */
    orderBy?: PaymentIntentOrderByWithRelationInput | PaymentIntentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentIntents.
     */
    cursor?: PaymentIntentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentIntents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentIntents.
     */
    skip?: number
    distinct?: PaymentIntentScalarFieldEnum | PaymentIntentScalarFieldEnum[]
  }

  /**
   * PaymentIntent create
   */
  export type PaymentIntentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentIntent.
     */
    data: XOR<PaymentIntentCreateInput, PaymentIntentUncheckedCreateInput>
  }

  /**
   * PaymentIntent createMany
   */
  export type PaymentIntentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentIntents.
     */
    data: PaymentIntentCreateManyInput | PaymentIntentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentIntent createManyAndReturn
   */
  export type PaymentIntentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentIntents.
     */
    data: PaymentIntentCreateManyInput | PaymentIntentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentIntent update
   */
  export type PaymentIntentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentIntent.
     */
    data: XOR<PaymentIntentUpdateInput, PaymentIntentUncheckedUpdateInput>
    /**
     * Choose, which PaymentIntent to update.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent updateMany
   */
  export type PaymentIntentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentIntents.
     */
    data: XOR<PaymentIntentUpdateManyMutationInput, PaymentIntentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentIntents to update
     */
    where?: PaymentIntentWhereInput
    /**
     * Limit how many PaymentIntents to update.
     */
    limit?: number
  }

  /**
   * PaymentIntent updateManyAndReturn
   */
  export type PaymentIntentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * The data used to update PaymentIntents.
     */
    data: XOR<PaymentIntentUpdateManyMutationInput, PaymentIntentUncheckedUpdateManyInput>
    /**
     * Filter which PaymentIntents to update
     */
    where?: PaymentIntentWhereInput
    /**
     * Limit how many PaymentIntents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentIntent upsert
   */
  export type PaymentIntentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentIntent to update in case it exists.
     */
    where: PaymentIntentWhereUniqueInput
    /**
     * In case the PaymentIntent found by the `where` argument doesn't exist, create a new PaymentIntent with this data.
     */
    create: XOR<PaymentIntentCreateInput, PaymentIntentUncheckedCreateInput>
    /**
     * In case the PaymentIntent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentIntentUpdateInput, PaymentIntentUncheckedUpdateInput>
  }

  /**
   * PaymentIntent delete
   */
  export type PaymentIntentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
    /**
     * Filter which PaymentIntent to delete.
     */
    where: PaymentIntentWhereUniqueInput
  }

  /**
   * PaymentIntent deleteMany
   */
  export type PaymentIntentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentIntents to delete
     */
    where?: PaymentIntentWhereInput
    /**
     * Limit how many PaymentIntents to delete.
     */
    limit?: number
  }

  /**
   * PaymentIntent without action
   */
  export type PaymentIntentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentIntent
     */
    select?: PaymentIntentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentIntent
     */
    omit?: PaymentIntentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIntentInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    chain: $Enums.Chain | null
    nickname: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    chain: $Enums.Chain | null
    nickname: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    address: number
    chain: number
    nickname: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    chain?: true
    nickname?: true
    isActive?: true
    createdAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    chain?: true
    nickname?: true
    isActive?: true
    createdAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    chain?: true
    nickname?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    address: string
    chain: $Enums.Chain
    nickname: string | null
    isActive: boolean
    createdAt: Date
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    chain?: boolean
    nickname?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    txs?: boolean | Wallet$txsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    chain?: boolean
    nickname?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    chain?: boolean
    nickname?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    address?: boolean
    chain?: boolean
    nickname?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "address" | "chain" | "nickname" | "isActive" | "createdAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    txs?: boolean | Wallet$txsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      txs: Prisma.$CryptoTxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      address: string
      chain: $Enums.Chain
      nickname: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    txs<T extends Wallet$txsArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$txsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly address: FieldRef<"Wallet", 'String'>
    readonly chain: FieldRef<"Wallet", 'Chain'>
    readonly nickname: FieldRef<"Wallet", 'String'>
    readonly isActive: FieldRef<"Wallet", 'Boolean'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet.txs
   */
  export type Wallet$txsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    where?: CryptoTxWhereInput
    orderBy?: CryptoTxOrderByWithRelationInput | CryptoTxOrderByWithRelationInput[]
    cursor?: CryptoTxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoTxScalarFieldEnum | CryptoTxScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model CryptoTx
   */

  export type AggregateCryptoTx = {
    _count: CryptoTxCountAggregateOutputType | null
    _avg: CryptoTxAvgAggregateOutputType | null
    _sum: CryptoTxSumAggregateOutputType | null
    _min: CryptoTxMinAggregateOutputType | null
    _max: CryptoTxMaxAggregateOutputType | null
  }

  export type CryptoTxAvgAggregateOutputType = {
    amount: Decimal | null
    blockNumber: number | null
    gasUsed: number | null
  }

  export type CryptoTxSumAggregateOutputType = {
    amount: Decimal | null
    blockNumber: bigint | null
    gasUsed: bigint | null
  }

  export type CryptoTxMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    txHash: string | null
    amount: Decimal | null
    status: $Enums.PaymentStatus | null
    blockNumber: bigint | null
    gasUsed: bigint | null
    timestamp: Date | null
  }

  export type CryptoTxMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    txHash: string | null
    amount: Decimal | null
    status: $Enums.PaymentStatus | null
    blockNumber: bigint | null
    gasUsed: bigint | null
    timestamp: Date | null
  }

  export type CryptoTxCountAggregateOutputType = {
    id: number
    walletId: number
    entityType: number
    entityId: number
    txHash: number
    amount: number
    status: number
    blockNumber: number
    gasUsed: number
    timestamp: number
    _all: number
  }


  export type CryptoTxAvgAggregateInputType = {
    amount?: true
    blockNumber?: true
    gasUsed?: true
  }

  export type CryptoTxSumAggregateInputType = {
    amount?: true
    blockNumber?: true
    gasUsed?: true
  }

  export type CryptoTxMinAggregateInputType = {
    id?: true
    walletId?: true
    entityType?: true
    entityId?: true
    txHash?: true
    amount?: true
    status?: true
    blockNumber?: true
    gasUsed?: true
    timestamp?: true
  }

  export type CryptoTxMaxAggregateInputType = {
    id?: true
    walletId?: true
    entityType?: true
    entityId?: true
    txHash?: true
    amount?: true
    status?: true
    blockNumber?: true
    gasUsed?: true
    timestamp?: true
  }

  export type CryptoTxCountAggregateInputType = {
    id?: true
    walletId?: true
    entityType?: true
    entityId?: true
    txHash?: true
    amount?: true
    status?: true
    blockNumber?: true
    gasUsed?: true
    timestamp?: true
    _all?: true
  }

  export type CryptoTxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoTx to aggregate.
     */
    where?: CryptoTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTxes to fetch.
     */
    orderBy?: CryptoTxOrderByWithRelationInput | CryptoTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoTxes
    **/
    _count?: true | CryptoTxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoTxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoTxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoTxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoTxMaxAggregateInputType
  }

  export type GetCryptoTxAggregateType<T extends CryptoTxAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoTx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoTx[P]>
      : GetScalarType<T[P], AggregateCryptoTx[P]>
  }




  export type CryptoTxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoTxWhereInput
    orderBy?: CryptoTxOrderByWithAggregationInput | CryptoTxOrderByWithAggregationInput[]
    by: CryptoTxScalarFieldEnum[] | CryptoTxScalarFieldEnum
    having?: CryptoTxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoTxCountAggregateInputType | true
    _avg?: CryptoTxAvgAggregateInputType
    _sum?: CryptoTxSumAggregateInputType
    _min?: CryptoTxMinAggregateInputType
    _max?: CryptoTxMaxAggregateInputType
  }

  export type CryptoTxGroupByOutputType = {
    id: string
    walletId: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal
    status: $Enums.PaymentStatus
    blockNumber: bigint | null
    gasUsed: bigint | null
    timestamp: Date
    _count: CryptoTxCountAggregateOutputType | null
    _avg: CryptoTxAvgAggregateOutputType | null
    _sum: CryptoTxSumAggregateOutputType | null
    _min: CryptoTxMinAggregateOutputType | null
    _max: CryptoTxMaxAggregateOutputType | null
  }

  type GetCryptoTxGroupByPayload<T extends CryptoTxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoTxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoTxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoTxGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoTxGroupByOutputType[P]>
        }
      >
    >


  export type CryptoTxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    entityType?: boolean
    entityId?: boolean
    txHash?: boolean
    amount?: boolean
    status?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    timestamp?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoTx"]>

  export type CryptoTxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    entityType?: boolean
    entityId?: boolean
    txHash?: boolean
    amount?: boolean
    status?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    timestamp?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoTx"]>

  export type CryptoTxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    entityType?: boolean
    entityId?: boolean
    txHash?: boolean
    amount?: boolean
    status?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    timestamp?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoTx"]>

  export type CryptoTxSelectScalar = {
    id?: boolean
    walletId?: boolean
    entityType?: boolean
    entityId?: boolean
    txHash?: boolean
    amount?: boolean
    status?: boolean
    blockNumber?: boolean
    gasUsed?: boolean
    timestamp?: boolean
  }

  export type CryptoTxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "entityType" | "entityId" | "txHash" | "amount" | "status" | "blockNumber" | "gasUsed" | "timestamp", ExtArgs["result"]["cryptoTx"]>
  export type CryptoTxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type CryptoTxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type CryptoTxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }

  export type $CryptoTxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoTx"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      entityType: $Enums.EntityType
      entityId: string
      txHash: string
      amount: Prisma.Decimal
      status: $Enums.PaymentStatus
      blockNumber: bigint | null
      gasUsed: bigint | null
      timestamp: Date
    }, ExtArgs["result"]["cryptoTx"]>
    composites: {}
  }

  type CryptoTxGetPayload<S extends boolean | null | undefined | CryptoTxDefaultArgs> = $Result.GetResult<Prisma.$CryptoTxPayload, S>

  type CryptoTxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CryptoTxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptoTxCountAggregateInputType | true
    }

  export interface CryptoTxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoTx'], meta: { name: 'CryptoTx' } }
    /**
     * Find zero or one CryptoTx that matches the filter.
     * @param {CryptoTxFindUniqueArgs} args - Arguments to find a CryptoTx
     * @example
     * // Get one CryptoTx
     * const cryptoTx = await prisma.cryptoTx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoTxFindUniqueArgs>(args: SelectSubset<T, CryptoTxFindUniqueArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CryptoTx that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CryptoTxFindUniqueOrThrowArgs} args - Arguments to find a CryptoTx
     * @example
     * // Get one CryptoTx
     * const cryptoTx = await prisma.cryptoTx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoTxFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoTxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoTx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxFindFirstArgs} args - Arguments to find a CryptoTx
     * @example
     * // Get one CryptoTx
     * const cryptoTx = await prisma.cryptoTx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoTxFindFirstArgs>(args?: SelectSubset<T, CryptoTxFindFirstArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CryptoTx that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxFindFirstOrThrowArgs} args - Arguments to find a CryptoTx
     * @example
     * // Get one CryptoTx
     * const cryptoTx = await prisma.cryptoTx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoTxFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoTxFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CryptoTxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoTxes
     * const cryptoTxes = await prisma.cryptoTx.findMany()
     * 
     * // Get first 10 CryptoTxes
     * const cryptoTxes = await prisma.cryptoTx.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoTxWithIdOnly = await prisma.cryptoTx.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoTxFindManyArgs>(args?: SelectSubset<T, CryptoTxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CryptoTx.
     * @param {CryptoTxCreateArgs} args - Arguments to create a CryptoTx.
     * @example
     * // Create one CryptoTx
     * const CryptoTx = await prisma.cryptoTx.create({
     *   data: {
     *     // ... data to create a CryptoTx
     *   }
     * })
     * 
     */
    create<T extends CryptoTxCreateArgs>(args: SelectSubset<T, CryptoTxCreateArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CryptoTxes.
     * @param {CryptoTxCreateManyArgs} args - Arguments to create many CryptoTxes.
     * @example
     * // Create many CryptoTxes
     * const cryptoTx = await prisma.cryptoTx.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoTxCreateManyArgs>(args?: SelectSubset<T, CryptoTxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoTxes and returns the data saved in the database.
     * @param {CryptoTxCreateManyAndReturnArgs} args - Arguments to create many CryptoTxes.
     * @example
     * // Create many CryptoTxes
     * const cryptoTx = await prisma.cryptoTx.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoTxes and only return the `id`
     * const cryptoTxWithIdOnly = await prisma.cryptoTx.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoTxCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoTxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CryptoTx.
     * @param {CryptoTxDeleteArgs} args - Arguments to delete one CryptoTx.
     * @example
     * // Delete one CryptoTx
     * const CryptoTx = await prisma.cryptoTx.delete({
     *   where: {
     *     // ... filter to delete one CryptoTx
     *   }
     * })
     * 
     */
    delete<T extends CryptoTxDeleteArgs>(args: SelectSubset<T, CryptoTxDeleteArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CryptoTx.
     * @param {CryptoTxUpdateArgs} args - Arguments to update one CryptoTx.
     * @example
     * // Update one CryptoTx
     * const cryptoTx = await prisma.cryptoTx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoTxUpdateArgs>(args: SelectSubset<T, CryptoTxUpdateArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CryptoTxes.
     * @param {CryptoTxDeleteManyArgs} args - Arguments to filter CryptoTxes to delete.
     * @example
     * // Delete a few CryptoTxes
     * const { count } = await prisma.cryptoTx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoTxDeleteManyArgs>(args?: SelectSubset<T, CryptoTxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoTxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoTxes
     * const cryptoTx = await prisma.cryptoTx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoTxUpdateManyArgs>(args: SelectSubset<T, CryptoTxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoTxes and returns the data updated in the database.
     * @param {CryptoTxUpdateManyAndReturnArgs} args - Arguments to update many CryptoTxes.
     * @example
     * // Update many CryptoTxes
     * const cryptoTx = await prisma.cryptoTx.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CryptoTxes and only return the `id`
     * const cryptoTxWithIdOnly = await prisma.cryptoTx.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CryptoTxUpdateManyAndReturnArgs>(args: SelectSubset<T, CryptoTxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CryptoTx.
     * @param {CryptoTxUpsertArgs} args - Arguments to update or create a CryptoTx.
     * @example
     * // Update or create a CryptoTx
     * const cryptoTx = await prisma.cryptoTx.upsert({
     *   create: {
     *     // ... data to create a CryptoTx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoTx we want to update
     *   }
     * })
     */
    upsert<T extends CryptoTxUpsertArgs>(args: SelectSubset<T, CryptoTxUpsertArgs<ExtArgs>>): Prisma__CryptoTxClient<$Result.GetResult<Prisma.$CryptoTxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CryptoTxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxCountArgs} args - Arguments to filter CryptoTxes to count.
     * @example
     * // Count the number of CryptoTxes
     * const count = await prisma.cryptoTx.count({
     *   where: {
     *     // ... the filter for the CryptoTxes we want to count
     *   }
     * })
    **/
    count<T extends CryptoTxCountArgs>(
      args?: Subset<T, CryptoTxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoTxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoTx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoTxAggregateArgs>(args: Subset<T, CryptoTxAggregateArgs>): Prisma.PrismaPromise<GetCryptoTxAggregateType<T>>

    /**
     * Group by CryptoTx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoTxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoTxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoTxGroupByArgs['orderBy'] }
        : { orderBy?: CryptoTxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoTxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoTxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoTx model
   */
  readonly fields: CryptoTxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoTx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoTxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoTx model
   */
  interface CryptoTxFieldRefs {
    readonly id: FieldRef<"CryptoTx", 'String'>
    readonly walletId: FieldRef<"CryptoTx", 'String'>
    readonly entityType: FieldRef<"CryptoTx", 'EntityType'>
    readonly entityId: FieldRef<"CryptoTx", 'String'>
    readonly txHash: FieldRef<"CryptoTx", 'String'>
    readonly amount: FieldRef<"CryptoTx", 'Decimal'>
    readonly status: FieldRef<"CryptoTx", 'PaymentStatus'>
    readonly blockNumber: FieldRef<"CryptoTx", 'BigInt'>
    readonly gasUsed: FieldRef<"CryptoTx", 'BigInt'>
    readonly timestamp: FieldRef<"CryptoTx", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoTx findUnique
   */
  export type CryptoTxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTx to fetch.
     */
    where: CryptoTxWhereUniqueInput
  }

  /**
   * CryptoTx findUniqueOrThrow
   */
  export type CryptoTxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTx to fetch.
     */
    where: CryptoTxWhereUniqueInput
  }

  /**
   * CryptoTx findFirst
   */
  export type CryptoTxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTx to fetch.
     */
    where?: CryptoTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTxes to fetch.
     */
    orderBy?: CryptoTxOrderByWithRelationInput | CryptoTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTxes.
     */
    cursor?: CryptoTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTxes.
     */
    distinct?: CryptoTxScalarFieldEnum | CryptoTxScalarFieldEnum[]
  }

  /**
   * CryptoTx findFirstOrThrow
   */
  export type CryptoTxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTx to fetch.
     */
    where?: CryptoTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTxes to fetch.
     */
    orderBy?: CryptoTxOrderByWithRelationInput | CryptoTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoTxes.
     */
    cursor?: CryptoTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoTxes.
     */
    distinct?: CryptoTxScalarFieldEnum | CryptoTxScalarFieldEnum[]
  }

  /**
   * CryptoTx findMany
   */
  export type CryptoTxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * Filter, which CryptoTxes to fetch.
     */
    where?: CryptoTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoTxes to fetch.
     */
    orderBy?: CryptoTxOrderByWithRelationInput | CryptoTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoTxes.
     */
    cursor?: CryptoTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoTxes.
     */
    skip?: number
    distinct?: CryptoTxScalarFieldEnum | CryptoTxScalarFieldEnum[]
  }

  /**
   * CryptoTx create
   */
  export type CryptoTxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoTx.
     */
    data: XOR<CryptoTxCreateInput, CryptoTxUncheckedCreateInput>
  }

  /**
   * CryptoTx createMany
   */
  export type CryptoTxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoTxes.
     */
    data: CryptoTxCreateManyInput | CryptoTxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoTx createManyAndReturn
   */
  export type CryptoTxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * The data used to create many CryptoTxes.
     */
    data: CryptoTxCreateManyInput | CryptoTxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoTx update
   */
  export type CryptoTxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoTx.
     */
    data: XOR<CryptoTxUpdateInput, CryptoTxUncheckedUpdateInput>
    /**
     * Choose, which CryptoTx to update.
     */
    where: CryptoTxWhereUniqueInput
  }

  /**
   * CryptoTx updateMany
   */
  export type CryptoTxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoTxes.
     */
    data: XOR<CryptoTxUpdateManyMutationInput, CryptoTxUncheckedUpdateManyInput>
    /**
     * Filter which CryptoTxes to update
     */
    where?: CryptoTxWhereInput
    /**
     * Limit how many CryptoTxes to update.
     */
    limit?: number
  }

  /**
   * CryptoTx updateManyAndReturn
   */
  export type CryptoTxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * The data used to update CryptoTxes.
     */
    data: XOR<CryptoTxUpdateManyMutationInput, CryptoTxUncheckedUpdateManyInput>
    /**
     * Filter which CryptoTxes to update
     */
    where?: CryptoTxWhereInput
    /**
     * Limit how many CryptoTxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoTx upsert
   */
  export type CryptoTxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoTx to update in case it exists.
     */
    where: CryptoTxWhereUniqueInput
    /**
     * In case the CryptoTx found by the `where` argument doesn't exist, create a new CryptoTx with this data.
     */
    create: XOR<CryptoTxCreateInput, CryptoTxUncheckedCreateInput>
    /**
     * In case the CryptoTx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoTxUpdateInput, CryptoTxUncheckedUpdateInput>
  }

  /**
   * CryptoTx delete
   */
  export type CryptoTxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
    /**
     * Filter which CryptoTx to delete.
     */
    where: CryptoTxWhereUniqueInput
  }

  /**
   * CryptoTx deleteMany
   */
  export type CryptoTxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoTxes to delete
     */
    where?: CryptoTxWhereInput
    /**
     * Limit how many CryptoTxes to delete.
     */
    limit?: number
  }

  /**
   * CryptoTx without action
   */
  export type CryptoTxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoTx
     */
    select?: CryptoTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CryptoTx
     */
    omit?: CryptoTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoTxInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    type: $Enums.DocumentType | null
    fileSize: number | null
    mimeType: string | null
    uploadedBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    startupId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    type: $Enums.DocumentType | null
    fileSize: number | null
    mimeType: string | null
    uploadedBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    startupId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    url: number
    title: number
    type: number
    fileSize: number
    mimeType: number
    uploadedBy: number
    isActive: number
    createdAt: number
    startupId: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    url?: true
    title?: true
    type?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    isActive?: true
    createdAt?: true
    startupId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    url?: true
    title?: true
    type?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    isActive?: true
    createdAt?: true
    startupId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    url?: true
    title?: true
    type?: true
    fileSize?: true
    mimeType?: true
    uploadedBy?: true
    isActive?: true
    createdAt?: true
    startupId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize: number | null
    mimeType: string | null
    uploadedBy: string | null
    isActive: boolean
    createdAt: Date
    startupId: string | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    type?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    startupId?: boolean
    entities?: boolean | Document$entitiesArgs<ExtArgs>
    Startup?: boolean | Document$StartupArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    type?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    startupId?: boolean
    Startup?: boolean | Document$StartupArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    type?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    startupId?: boolean
    Startup?: boolean | Document$StartupArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    url?: boolean
    title?: boolean
    type?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    startupId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "title" | "type" | "fileSize" | "mimeType" | "uploadedBy" | "isActive" | "createdAt" | "startupId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | Document$entitiesArgs<ExtArgs>
    Startup?: boolean | Document$StartupArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Startup?: boolean | Document$StartupArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Startup?: boolean | Document$StartupArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      entities: Prisma.$EntityDocumentPayload<ExtArgs>[]
      Startup: Prisma.$StartupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      title: string
      type: $Enums.DocumentType
      fileSize: number | null
      mimeType: string | null
      uploadedBy: string | null
      isActive: boolean
      createdAt: Date
      startupId: string | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entities<T extends Document$entitiesArgs<ExtArgs> = {}>(args?: Subset<T, Document$entitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Startup<T extends Document$StartupArgs<ExtArgs> = {}>(args?: Subset<T, Document$StartupArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly isActive: FieldRef<"Document", 'Boolean'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly startupId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.entities
   */
  export type Document$entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    where?: EntityDocumentWhereInput
    orderBy?: EntityDocumentOrderByWithRelationInput | EntityDocumentOrderByWithRelationInput[]
    cursor?: EntityDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityDocumentScalarFieldEnum | EntityDocumentScalarFieldEnum[]
  }

  /**
   * Document.Startup
   */
  export type Document$StartupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model EntityDocument
   */

  export type AggregateEntityDocument = {
    _count: EntityDocumentCountAggregateOutputType | null
    _min: EntityDocumentMinAggregateOutputType | null
    _max: EntityDocumentMaxAggregateOutputType | null
  }

  export type EntityDocumentMinAggregateOutputType = {
    id: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    documentId: string | null
    visibility: string | null
    createdAt: Date | null
    tokenId: string | null
  }

  export type EntityDocumentMaxAggregateOutputType = {
    id: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    documentId: string | null
    visibility: string | null
    createdAt: Date | null
    tokenId: string | null
  }

  export type EntityDocumentCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    documentId: number
    visibility: number
    createdAt: number
    tokenId: number
    _all: number
  }


  export type EntityDocumentMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    documentId?: true
    visibility?: true
    createdAt?: true
    tokenId?: true
  }

  export type EntityDocumentMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    documentId?: true
    visibility?: true
    createdAt?: true
    tokenId?: true
  }

  export type EntityDocumentCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    documentId?: true
    visibility?: true
    createdAt?: true
    tokenId?: true
    _all?: true
  }

  export type EntityDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityDocument to aggregate.
     */
    where?: EntityDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDocuments to fetch.
     */
    orderBy?: EntityDocumentOrderByWithRelationInput | EntityDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityDocuments
    **/
    _count?: true | EntityDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityDocumentMaxAggregateInputType
  }

  export type GetEntityDocumentAggregateType<T extends EntityDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityDocument[P]>
      : GetScalarType<T[P], AggregateEntityDocument[P]>
  }




  export type EntityDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityDocumentWhereInput
    orderBy?: EntityDocumentOrderByWithAggregationInput | EntityDocumentOrderByWithAggregationInput[]
    by: EntityDocumentScalarFieldEnum[] | EntityDocumentScalarFieldEnum
    having?: EntityDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityDocumentCountAggregateInputType | true
    _min?: EntityDocumentMinAggregateInputType
    _max?: EntityDocumentMaxAggregateInputType
  }

  export type EntityDocumentGroupByOutputType = {
    id: string
    entityType: $Enums.EntityType
    entityId: string
    documentId: string
    visibility: string
    createdAt: Date
    tokenId: string | null
    _count: EntityDocumentCountAggregateOutputType | null
    _min: EntityDocumentMinAggregateOutputType | null
    _max: EntityDocumentMaxAggregateOutputType | null
  }

  type GetEntityDocumentGroupByPayload<T extends EntityDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], EntityDocumentGroupByOutputType[P]>
        }
      >
    >


  export type EntityDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    documentId?: boolean
    visibility?: boolean
    createdAt?: boolean
    tokenId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    Token?: boolean | EntityDocument$TokenArgs<ExtArgs>
  }, ExtArgs["result"]["entityDocument"]>

  export type EntityDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    documentId?: boolean
    visibility?: boolean
    createdAt?: boolean
    tokenId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    Token?: boolean | EntityDocument$TokenArgs<ExtArgs>
  }, ExtArgs["result"]["entityDocument"]>

  export type EntityDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    documentId?: boolean
    visibility?: boolean
    createdAt?: boolean
    tokenId?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    Token?: boolean | EntityDocument$TokenArgs<ExtArgs>
  }, ExtArgs["result"]["entityDocument"]>

  export type EntityDocumentSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    documentId?: boolean
    visibility?: boolean
    createdAt?: boolean
    tokenId?: boolean
  }

  export type EntityDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "entityId" | "documentId" | "visibility" | "createdAt" | "tokenId", ExtArgs["result"]["entityDocument"]>
  export type EntityDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    Token?: boolean | EntityDocument$TokenArgs<ExtArgs>
  }
  export type EntityDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    Token?: boolean | EntityDocument$TokenArgs<ExtArgs>
  }
  export type EntityDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    Token?: boolean | EntityDocument$TokenArgs<ExtArgs>
  }

  export type $EntityDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityDocument"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      Token: Prisma.$TokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: $Enums.EntityType
      entityId: string
      documentId: string
      visibility: string
      createdAt: Date
      tokenId: string | null
    }, ExtArgs["result"]["entityDocument"]>
    composites: {}
  }

  type EntityDocumentGetPayload<S extends boolean | null | undefined | EntityDocumentDefaultArgs> = $Result.GetResult<Prisma.$EntityDocumentPayload, S>

  type EntityDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntityDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntityDocumentCountAggregateInputType | true
    }

  export interface EntityDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityDocument'], meta: { name: 'EntityDocument' } }
    /**
     * Find zero or one EntityDocument that matches the filter.
     * @param {EntityDocumentFindUniqueArgs} args - Arguments to find a EntityDocument
     * @example
     * // Get one EntityDocument
     * const entityDocument = await prisma.entityDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntityDocumentFindUniqueArgs>(args: SelectSubset<T, EntityDocumentFindUniqueArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EntityDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntityDocumentFindUniqueOrThrowArgs} args - Arguments to find a EntityDocument
     * @example
     * // Get one EntityDocument
     * const entityDocument = await prisma.entityDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntityDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, EntityDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EntityDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentFindFirstArgs} args - Arguments to find a EntityDocument
     * @example
     * // Get one EntityDocument
     * const entityDocument = await prisma.entityDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntityDocumentFindFirstArgs>(args?: SelectSubset<T, EntityDocumentFindFirstArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EntityDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentFindFirstOrThrowArgs} args - Arguments to find a EntityDocument
     * @example
     * // Get one EntityDocument
     * const entityDocument = await prisma.entityDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntityDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, EntityDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EntityDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityDocuments
     * const entityDocuments = await prisma.entityDocument.findMany()
     * 
     * // Get first 10 EntityDocuments
     * const entityDocuments = await prisma.entityDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityDocumentWithIdOnly = await prisma.entityDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntityDocumentFindManyArgs>(args?: SelectSubset<T, EntityDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EntityDocument.
     * @param {EntityDocumentCreateArgs} args - Arguments to create a EntityDocument.
     * @example
     * // Create one EntityDocument
     * const EntityDocument = await prisma.entityDocument.create({
     *   data: {
     *     // ... data to create a EntityDocument
     *   }
     * })
     * 
     */
    create<T extends EntityDocumentCreateArgs>(args: SelectSubset<T, EntityDocumentCreateArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EntityDocuments.
     * @param {EntityDocumentCreateManyArgs} args - Arguments to create many EntityDocuments.
     * @example
     * // Create many EntityDocuments
     * const entityDocument = await prisma.entityDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntityDocumentCreateManyArgs>(args?: SelectSubset<T, EntityDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EntityDocuments and returns the data saved in the database.
     * @param {EntityDocumentCreateManyAndReturnArgs} args - Arguments to create many EntityDocuments.
     * @example
     * // Create many EntityDocuments
     * const entityDocument = await prisma.entityDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EntityDocuments and only return the `id`
     * const entityDocumentWithIdOnly = await prisma.entityDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntityDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, EntityDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EntityDocument.
     * @param {EntityDocumentDeleteArgs} args - Arguments to delete one EntityDocument.
     * @example
     * // Delete one EntityDocument
     * const EntityDocument = await prisma.entityDocument.delete({
     *   where: {
     *     // ... filter to delete one EntityDocument
     *   }
     * })
     * 
     */
    delete<T extends EntityDocumentDeleteArgs>(args: SelectSubset<T, EntityDocumentDeleteArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EntityDocument.
     * @param {EntityDocumentUpdateArgs} args - Arguments to update one EntityDocument.
     * @example
     * // Update one EntityDocument
     * const entityDocument = await prisma.entityDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntityDocumentUpdateArgs>(args: SelectSubset<T, EntityDocumentUpdateArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EntityDocuments.
     * @param {EntityDocumentDeleteManyArgs} args - Arguments to filter EntityDocuments to delete.
     * @example
     * // Delete a few EntityDocuments
     * const { count } = await prisma.entityDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntityDocumentDeleteManyArgs>(args?: SelectSubset<T, EntityDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityDocuments
     * const entityDocument = await prisma.entityDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntityDocumentUpdateManyArgs>(args: SelectSubset<T, EntityDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityDocuments and returns the data updated in the database.
     * @param {EntityDocumentUpdateManyAndReturnArgs} args - Arguments to update many EntityDocuments.
     * @example
     * // Update many EntityDocuments
     * const entityDocument = await prisma.entityDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EntityDocuments and only return the `id`
     * const entityDocumentWithIdOnly = await prisma.entityDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EntityDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, EntityDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EntityDocument.
     * @param {EntityDocumentUpsertArgs} args - Arguments to update or create a EntityDocument.
     * @example
     * // Update or create a EntityDocument
     * const entityDocument = await prisma.entityDocument.upsert({
     *   create: {
     *     // ... data to create a EntityDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityDocument we want to update
     *   }
     * })
     */
    upsert<T extends EntityDocumentUpsertArgs>(args: SelectSubset<T, EntityDocumentUpsertArgs<ExtArgs>>): Prisma__EntityDocumentClient<$Result.GetResult<Prisma.$EntityDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EntityDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentCountArgs} args - Arguments to filter EntityDocuments to count.
     * @example
     * // Count the number of EntityDocuments
     * const count = await prisma.entityDocument.count({
     *   where: {
     *     // ... the filter for the EntityDocuments we want to count
     *   }
     * })
    **/
    count<T extends EntityDocumentCountArgs>(
      args?: Subset<T, EntityDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityDocumentAggregateArgs>(args: Subset<T, EntityDocumentAggregateArgs>): Prisma.PrismaPromise<GetEntityDocumentAggregateType<T>>

    /**
     * Group by EntityDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityDocumentGroupByArgs['orderBy'] }
        : { orderBy?: EntityDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityDocument model
   */
  readonly fields: EntityDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Token<T extends EntityDocument$TokenArgs<ExtArgs> = {}>(args?: Subset<T, EntityDocument$TokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EntityDocument model
   */
  interface EntityDocumentFieldRefs {
    readonly id: FieldRef<"EntityDocument", 'String'>
    readonly entityType: FieldRef<"EntityDocument", 'EntityType'>
    readonly entityId: FieldRef<"EntityDocument", 'String'>
    readonly documentId: FieldRef<"EntityDocument", 'String'>
    readonly visibility: FieldRef<"EntityDocument", 'String'>
    readonly createdAt: FieldRef<"EntityDocument", 'DateTime'>
    readonly tokenId: FieldRef<"EntityDocument", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EntityDocument findUnique
   */
  export type EntityDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EntityDocument to fetch.
     */
    where: EntityDocumentWhereUniqueInput
  }

  /**
   * EntityDocument findUniqueOrThrow
   */
  export type EntityDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EntityDocument to fetch.
     */
    where: EntityDocumentWhereUniqueInput
  }

  /**
   * EntityDocument findFirst
   */
  export type EntityDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EntityDocument to fetch.
     */
    where?: EntityDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDocuments to fetch.
     */
    orderBy?: EntityDocumentOrderByWithRelationInput | EntityDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityDocuments.
     */
    cursor?: EntityDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityDocuments.
     */
    distinct?: EntityDocumentScalarFieldEnum | EntityDocumentScalarFieldEnum[]
  }

  /**
   * EntityDocument findFirstOrThrow
   */
  export type EntityDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EntityDocument to fetch.
     */
    where?: EntityDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDocuments to fetch.
     */
    orderBy?: EntityDocumentOrderByWithRelationInput | EntityDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityDocuments.
     */
    cursor?: EntityDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityDocuments.
     */
    distinct?: EntityDocumentScalarFieldEnum | EntityDocumentScalarFieldEnum[]
  }

  /**
   * EntityDocument findMany
   */
  export type EntityDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EntityDocuments to fetch.
     */
    where?: EntityDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityDocuments to fetch.
     */
    orderBy?: EntityDocumentOrderByWithRelationInput | EntityDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityDocuments.
     */
    cursor?: EntityDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityDocuments.
     */
    skip?: number
    distinct?: EntityDocumentScalarFieldEnum | EntityDocumentScalarFieldEnum[]
  }

  /**
   * EntityDocument create
   */
  export type EntityDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityDocument.
     */
    data: XOR<EntityDocumentCreateInput, EntityDocumentUncheckedCreateInput>
  }

  /**
   * EntityDocument createMany
   */
  export type EntityDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityDocuments.
     */
    data: EntityDocumentCreateManyInput | EntityDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntityDocument createManyAndReturn
   */
  export type EntityDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many EntityDocuments.
     */
    data: EntityDocumentCreateManyInput | EntityDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EntityDocument update
   */
  export type EntityDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityDocument.
     */
    data: XOR<EntityDocumentUpdateInput, EntityDocumentUncheckedUpdateInput>
    /**
     * Choose, which EntityDocument to update.
     */
    where: EntityDocumentWhereUniqueInput
  }

  /**
   * EntityDocument updateMany
   */
  export type EntityDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityDocuments.
     */
    data: XOR<EntityDocumentUpdateManyMutationInput, EntityDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EntityDocuments to update
     */
    where?: EntityDocumentWhereInput
    /**
     * Limit how many EntityDocuments to update.
     */
    limit?: number
  }

  /**
   * EntityDocument updateManyAndReturn
   */
  export type EntityDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * The data used to update EntityDocuments.
     */
    data: XOR<EntityDocumentUpdateManyMutationInput, EntityDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EntityDocuments to update
     */
    where?: EntityDocumentWhereInput
    /**
     * Limit how many EntityDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EntityDocument upsert
   */
  export type EntityDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityDocument to update in case it exists.
     */
    where: EntityDocumentWhereUniqueInput
    /**
     * In case the EntityDocument found by the `where` argument doesn't exist, create a new EntityDocument with this data.
     */
    create: XOR<EntityDocumentCreateInput, EntityDocumentUncheckedCreateInput>
    /**
     * In case the EntityDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityDocumentUpdateInput, EntityDocumentUncheckedUpdateInput>
  }

  /**
   * EntityDocument delete
   */
  export type EntityDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
    /**
     * Filter which EntityDocument to delete.
     */
    where: EntityDocumentWhereUniqueInput
  }

  /**
   * EntityDocument deleteMany
   */
  export type EntityDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityDocuments to delete
     */
    where?: EntityDocumentWhereInput
    /**
     * Limit how many EntityDocuments to delete.
     */
    limit?: number
  }

  /**
   * EntityDocument.Token
   */
  export type EntityDocument$TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * EntityDocument without action
   */
  export type EntityDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityDocument
     */
    select?: EntityDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityDocument
     */
    omit?: EntityDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    data: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    data: JsonValue | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "data" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      data: Prisma.JsonValue | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    body: string | null
    parentId: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    startupId: string | null
    tokenId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    entityType: $Enums.EntityType | null
    entityId: string | null
    body: string | null
    parentId: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    startupId: string | null
    tokenId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    userId: number
    entityType: number
    entityId: number
    body: number
    parentId: number
    isEdited: number
    createdAt: number
    updatedAt: number
    startupId: number
    tokenId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    body?: true
    parentId?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
    startupId?: true
    tokenId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    body?: true
    parentId?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
    startupId?: true
    tokenId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    body?: true
    parentId?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
    startupId?: true
    tokenId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId: string | null
    isEdited: boolean
    createdAt: Date
    updatedAt: Date
    startupId: string | null
    tokenId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    body?: boolean
    parentId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Comment$startupArgs<ExtArgs>
    token?: boolean | Comment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    body?: boolean
    parentId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Comment$startupArgs<ExtArgs>
    token?: boolean | Comment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    body?: boolean
    parentId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Comment$startupArgs<ExtArgs>
    token?: boolean | Comment$tokenArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    body?: boolean
    parentId?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    startupId?: boolean
    tokenId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "entityType" | "entityId" | "body" | "parentId" | "isEdited" | "createdAt" | "updatedAt" | "startupId" | "tokenId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Comment$startupArgs<ExtArgs>
    token?: boolean | Comment$tokenArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Comment$startupArgs<ExtArgs>
    token?: boolean | Comment$tokenArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    startup?: boolean | Comment$startupArgs<ExtArgs>
    token?: boolean | Comment$tokenArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      startup: Prisma.$StartupPayload<ExtArgs> | null
      token: Prisma.$TokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      entityType: $Enums.EntityType
      entityId: string
      body: string
      parentId: string | null
      isEdited: boolean
      createdAt: Date
      updatedAt: Date
      startupId: string | null
      tokenId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    startup<T extends Comment$startupArgs<ExtArgs> = {}>(args?: Subset<T, Comment$startupArgs<ExtArgs>>): Prisma__StartupClient<$Result.GetResult<Prisma.$StartupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    token<T extends Comment$tokenArgs<ExtArgs> = {}>(args?: Subset<T, Comment$tokenArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
    readonly entityType: FieldRef<"Comment", 'EntityType'>
    readonly entityId: FieldRef<"Comment", 'String'>
    readonly body: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly isEdited: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly startupId: FieldRef<"Comment", 'String'>
    readonly tokenId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.startup
   */
  export type Comment$startupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Startup
     */
    select?: StartupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Startup
     */
    omit?: StartupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StartupInclude<ExtArgs> | null
    where?: StartupWhereInput
  }

  /**
   * Comment.token
   */
  export type Comment$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    role: 'role',
    founderStatus: 'founderStatus',
    accreditationStatus: 'accreditationStatus',
    dealAccessLevel: 'dealAccessLevel',
    totalSimulationScore: 'totalSimulationScore',
    completedSimulations: 'completedSimulations',
    simulationLevel: 'simulationLevel',
    bio: 'bio',
    profilePicture: 'profilePicture',
    linkedinUrl: 'linkedinUrl',
    location: 'location',
    investmentPreferences: 'investmentPreferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    idToken: 'idToken',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    website: 'website',
    logoUrl: 'logoUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrganizationMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    organizationId: 'organizationId',
    role: 'role',
    joinedAt: 'joinedAt'
  };

  export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


  export const StartupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    industry: 'industry',
    stage: 'stage',
    website: 'website',
    pitchDeck: 'pitchDeck',
    fundingGoal: 'fundingGoal',
    amountRaised: 'amountRaised',
    valuation: 'valuation',
    isApproved: 'isApproved',
    isActive: 'isActive',
    aiGeneratedMetrics: 'aiGeneratedMetrics',
    simulationData: 'simulationData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    founderId: 'founderId',
    organizationId: 'organizationId'
  };

  export type StartupScalarFieldEnum = (typeof StartupScalarFieldEnum)[keyof typeof StartupScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    description: 'description',
    totalSupply: 'totalSupply',
    tokenomics: 'tokenomics',
    whitepaperUrl: 'whitepaperUrl',
    fundingGoal: 'fundingGoal',
    currentPrice: 'currentPrice',
    isApproved: 'isApproved',
    isActive: 'isActive',
    contractAddress: 'contractAddress',
    chain: 'chain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    organizationId: 'organizationId'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const SimulationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    maxParticipants: 'maxParticipants',
    startDate: 'startDate',
    endDate: 'endDate',
    initialBudget: 'initialBudget',
    difficultyLevel: 'difficultyLevel',
    scenarioData: 'scenarioData',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SimulationScalarFieldEnum = (typeof SimulationScalarFieldEnum)[keyof typeof SimulationScalarFieldEnum]


  export const SimulationInvestmentScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    userId: 'userId',
    startupId: 'startupId',
    tokenId: 'tokenId',
    amount: 'amount',
    ownership: 'ownership',
    currentValue: 'currentValue',
    roi: 'roi',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SimulationInvestmentScalarFieldEnum = (typeof SimulationInvestmentScalarFieldEnum)[keyof typeof SimulationInvestmentScalarFieldEnum]


  export const SimulationLeaderboardScalarFieldEnum: {
    id: 'id',
    simulationId: 'simulationId',
    userId: 'userId',
    rank: 'rank',
    totalReturn: 'totalReturn',
    roiPercent: 'roiPercent'
  };

  export type SimulationLeaderboardScalarFieldEnum = (typeof SimulationLeaderboardScalarFieldEnum)[keyof typeof SimulationLeaderboardScalarFieldEnum]


  export const DealMatchingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startupId: 'startupId',
    tokenId: 'tokenId',
    matchScore: 'matchScore',
    reasoning: 'reasoning',
    isRecommended: 'isRecommended',
    userFeedback: 'userFeedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealMatchingScalarFieldEnum = (typeof DealMatchingScalarFieldEnum)[keyof typeof DealMatchingScalarFieldEnum]


  export const LearningModuleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    category: 'category',
    difficulty: 'difficulty',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LearningModuleScalarFieldEnum = (typeof LearningModuleScalarFieldEnum)[keyof typeof LearningModuleScalarFieldEnum]


  export const UserLearningModuleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    learningModuleId: 'learningModuleId',
    completed: 'completed',
    score: 'score',
    completedAt: 'completedAt'
  };

  export type UserLearningModuleScalarFieldEnum = (typeof UserLearningModuleScalarFieldEnum)[keyof typeof UserLearningModuleScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalScore: 'totalScore',
    currentLevel: 'currentLevel',
    completedSimulations: 'completedSimulations',
    successfulInvestments: 'successfulInvestments',
    averageROI: 'averageROI',
    valuationSkill: 'valuationSkill',
    dueDiligenceSkill: 'dueDiligenceSkill',
    riskAssessmentSkill: 'riskAssessmentSkill',
    lastActivityAt: 'lastActivityAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const InvestmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startupId: 'startupId',
    tokenId: 'tokenId',
    amount: 'amount',
    ownership: 'ownership',
    valuation: 'valuation',
    terms: 'terms',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestmentScalarFieldEnum = (typeof InvestmentScalarFieldEnum)[keyof typeof InvestmentScalarFieldEnum]


  export const VestingScheduleScalarFieldEnum: {
    id: 'id',
    investmentId: 'investmentId',
    cliffDate: 'cliffDate',
    unlockDate: 'unlockDate',
    percentage: 'percentage',
    isUnlocked: 'isUnlocked',
    createdAt: 'createdAt'
  };

  export type VestingScheduleScalarFieldEnum = (typeof VestingScheduleScalarFieldEnum)[keyof typeof VestingScheduleScalarFieldEnum]


  export const KYCRecordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    accreditationStatus: 'accreditationStatus',
    reason: 'reason',
    documentUrls: 'documentUrls',
    verificationData: 'verificationData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KYCRecordScalarFieldEnum = (typeof KYCRecordScalarFieldEnum)[keyof typeof KYCRecordScalarFieldEnum]


  export const DueDiligenceReportScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    summary: 'summary',
    riskScore: 'riskScore',
    sentiment: 'sentiment',
    financialScore: 'financialScore',
    teamScore: 'teamScore',
    marketScore: 'marketScore',
    technologyScore: 'technologyScore',
    aiGenerated: 'aiGenerated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startupId: 'startupId',
    tokenId: 'tokenId'
  };

  export type DueDiligenceReportScalarFieldEnum = (typeof DueDiligenceReportScalarFieldEnum)[keyof typeof DueDiligenceReportScalarFieldEnum]


  export const AdminActivityLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetId: 'targetId',
    targetType: 'targetType',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type AdminActivityLogScalarFieldEnum = (typeof AdminActivityLogScalarFieldEnum)[keyof typeof AdminActivityLogScalarFieldEnum]


  export const PaymentIntentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerId: 'providerId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentIntentScalarFieldEnum = (typeof PaymentIntentScalarFieldEnum)[keyof typeof PaymentIntentScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    address: 'address',
    chain: 'chain',
    nickname: 'nickname',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const CryptoTxScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    entityType: 'entityType',
    entityId: 'entityId',
    txHash: 'txHash',
    amount: 'amount',
    status: 'status',
    blockNumber: 'blockNumber',
    gasUsed: 'gasUsed',
    timestamp: 'timestamp'
  };

  export type CryptoTxScalarFieldEnum = (typeof CryptoTxScalarFieldEnum)[keyof typeof CryptoTxScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    url: 'url',
    title: 'title',
    type: 'type',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedBy: 'uploadedBy',
    isActive: 'isActive',
    createdAt: 'createdAt',
    startupId: 'startupId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const EntityDocumentScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    documentId: 'documentId',
    visibility: 'visibility',
    createdAt: 'createdAt',
    tokenId: 'tokenId'
  };

  export type EntityDocumentScalarFieldEnum = (typeof EntityDocumentScalarFieldEnum)[keyof typeof EntityDocumentScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    entityType: 'entityType',
    entityId: 'entityId',
    body: 'body',
    parentId: 'parentId',
    isEdited: 'isEdited',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    startupId: 'startupId',
    tokenId: 'tokenId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'FounderStatus'
   */
  export type EnumFounderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FounderStatus'>
    


  /**
   * Reference to a field of type 'FounderStatus[]'
   */
  export type ListEnumFounderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FounderStatus[]'>
    


  /**
   * Reference to a field of type 'AccreditationStatus'
   */
  export type EnumAccreditationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccreditationStatus'>
    


  /**
   * Reference to a field of type 'AccreditationStatus[]'
   */
  export type ListEnumAccreditationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccreditationStatus[]'>
    


  /**
   * Reference to a field of type 'DealAccessLevel'
   */
  export type EnumDealAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealAccessLevel'>
    


  /**
   * Reference to a field of type 'DealAccessLevel[]'
   */
  export type ListEnumDealAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealAccessLevel[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'FundingStage'
   */
  export type EnumFundingStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FundingStage'>
    


  /**
   * Reference to a field of type 'FundingStage[]'
   */
  export type ListEnumFundingStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FundingStage[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Chain'
   */
  export type EnumChainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Chain'>
    


  /**
   * Reference to a field of type 'Chain[]'
   */
  export type ListEnumChainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Chain[]'>
    


  /**
   * Reference to a field of type 'SimulationType'
   */
  export type EnumSimulationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationType'>
    


  /**
   * Reference to a field of type 'SimulationType[]'
   */
  export type ListEnumSimulationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationType[]'>
    


  /**
   * Reference to a field of type 'SimulationStatus'
   */
  export type EnumSimulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationStatus'>
    


  /**
   * Reference to a field of type 'SimulationStatus[]'
   */
  export type ListEnumSimulationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SimulationStatus[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'EntityType[]'
   */
  export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    founderStatus?: EnumFounderStatusNullableFilter<"User"> | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFilter<"User"> | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFilter<"User"> | $Enums.DealAccessLevel
    totalSimulationScore?: IntFilter<"User"> | number
    completedSimulations?: IntFilter<"User"> | number
    simulationLevel?: IntFilter<"User"> | number
    bio?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    investmentPreferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    kycRecord?: XOR<KYCRecordNullableScalarRelationFilter, KYCRecordWhereInput> | null
    organizations?: OrganizationMemberListRelationFilter
    investments?: InvestmentListRelationFilter
    simulationInvestments?: SimulationInvestmentListRelationFilter
    notifications?: NotificationListRelationFilter
    startups?: StartupListRelationFilter
    tokens?: TokenListRelationFilter
    adminLogs?: AdminActivityLogListRelationFilter
    paymentIntents?: PaymentIntentListRelationFilter
    wallets?: WalletListRelationFilter
    comments?: CommentListRelationFilter
    simulations?: SimulationListRelationFilter
    ownedSimulations?: SimulationListRelationFilter
    dealMatchings?: DealMatchingListRelationFilter
    userProgress?: UserProgressListRelationFilter
    learningModules?: UserLearningModuleListRelationFilter
    leaderboardEntries?: SimulationLeaderboardListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    founderStatus?: SortOrderInput | SortOrder
    accreditationStatus?: SortOrder
    dealAccessLevel?: SortOrder
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
    bio?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    investmentPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    kycRecord?: KYCRecordOrderByWithRelationInput
    organizations?: OrganizationMemberOrderByRelationAggregateInput
    investments?: InvestmentOrderByRelationAggregateInput
    simulationInvestments?: SimulationInvestmentOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    startups?: StartupOrderByRelationAggregateInput
    tokens?: TokenOrderByRelationAggregateInput
    adminLogs?: AdminActivityLogOrderByRelationAggregateInput
    paymentIntents?: PaymentIntentOrderByRelationAggregateInput
    wallets?: WalletOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    simulations?: SimulationOrderByRelationAggregateInput
    ownedSimulations?: SimulationOrderByRelationAggregateInput
    dealMatchings?: DealMatchingOrderByRelationAggregateInput
    userProgress?: UserProgressOrderByRelationAggregateInput
    learningModules?: UserLearningModuleOrderByRelationAggregateInput
    leaderboardEntries?: SimulationLeaderboardOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    founderStatus?: EnumFounderStatusNullableFilter<"User"> | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFilter<"User"> | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFilter<"User"> | $Enums.DealAccessLevel
    totalSimulationScore?: IntFilter<"User"> | number
    completedSimulations?: IntFilter<"User"> | number
    simulationLevel?: IntFilter<"User"> | number
    bio?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    investmentPreferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    kycRecord?: XOR<KYCRecordNullableScalarRelationFilter, KYCRecordWhereInput> | null
    organizations?: OrganizationMemberListRelationFilter
    investments?: InvestmentListRelationFilter
    simulationInvestments?: SimulationInvestmentListRelationFilter
    notifications?: NotificationListRelationFilter
    startups?: StartupListRelationFilter
    tokens?: TokenListRelationFilter
    adminLogs?: AdminActivityLogListRelationFilter
    paymentIntents?: PaymentIntentListRelationFilter
    wallets?: WalletListRelationFilter
    comments?: CommentListRelationFilter
    simulations?: SimulationListRelationFilter
    ownedSimulations?: SimulationListRelationFilter
    dealMatchings?: DealMatchingListRelationFilter
    userProgress?: UserProgressListRelationFilter
    learningModules?: UserLearningModuleListRelationFilter
    leaderboardEntries?: SimulationLeaderboardListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    founderStatus?: SortOrderInput | SortOrder
    accreditationStatus?: SortOrder
    dealAccessLevel?: SortOrder
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
    bio?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    investmentPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    founderStatus?: EnumFounderStatusNullableWithAggregatesFilter<"User"> | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusWithAggregatesFilter<"User"> | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelWithAggregatesFilter<"User"> | $Enums.DealAccessLevel
    totalSimulationScore?: IntWithAggregatesFilter<"User"> | number
    completedSimulations?: IntWithAggregatesFilter<"User"> | number
    simulationLevel?: IntWithAggregatesFilter<"User"> | number
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    investmentPreferences?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"Session"> | string
    userAgent?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    providerId_accountId?: AccountProviderIdAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "providerId_accountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_value?: VerificationIdentifierValueCompoundUniqueInput
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id" | "identifier_value">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    isActive?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrganizationMemberListRelationFilter
    startups?: StartupListRelationFilter
    tokens?: TokenListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: OrganizationMemberOrderByRelationAggregateInput
    startups?: StartupOrderByRelationAggregateInput
    tokens?: TokenOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    website?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    isActive?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrganizationMemberListRelationFilter
    startups?: StartupListRelationFilter
    tokens?: TokenListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    description?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    website?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    isActive?: BoolWithAggregatesFilter<"Organization"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type OrganizationMemberWhereInput = {
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type OrganizationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_organizationId?: OrganizationMemberUserIdOrganizationIdCompoundUniqueInput
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    userId?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "userId_organizationId">

  export type OrganizationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    _count?: OrganizationMemberCountOrderByAggregateInput
    _max?: OrganizationMemberMaxOrderByAggregateInput
    _min?: OrganizationMemberMinOrderByAggregateInput
  }

  export type OrganizationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganizationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMember"> | string
    userId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    role?: StringWithAggregatesFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
  }

  export type StartupWhereInput = {
    AND?: StartupWhereInput | StartupWhereInput[]
    OR?: StartupWhereInput[]
    NOT?: StartupWhereInput | StartupWhereInput[]
    id?: StringFilter<"Startup"> | string
    name?: StringFilter<"Startup"> | string
    description?: StringFilter<"Startup"> | string
    industry?: StringFilter<"Startup"> | string
    stage?: EnumFundingStageFilter<"Startup"> | $Enums.FundingStage
    website?: StringNullableFilter<"Startup"> | string | null
    pitchDeck?: StringNullableFilter<"Startup"> | string | null
    fundingGoal?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFilter<"Startup"> | boolean
    isActive?: BoolFilter<"Startup"> | boolean
    aiGeneratedMetrics?: JsonNullableFilter<"Startup">
    simulationData?: JsonNullableFilter<"Startup">
    createdAt?: DateTimeFilter<"Startup"> | Date | string
    updatedAt?: DateTimeFilter<"Startup"> | Date | string
    founderId?: StringFilter<"Startup"> | string
    organizationId?: StringNullableFilter<"Startup"> | string | null
    founder?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    investments?: InvestmentListRelationFilter
    simulationInvestments?: SimulationInvestmentListRelationFilter
    dueDiligenceReports?: DueDiligenceReportListRelationFilter
    documents?: DocumentListRelationFilter
    comments?: CommentListRelationFilter
    dealMatchings?: DealMatchingListRelationFilter
  }

  export type StartupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    stage?: SortOrder
    website?: SortOrderInput | SortOrder
    pitchDeck?: SortOrderInput | SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    aiGeneratedMetrics?: SortOrderInput | SortOrder
    simulationData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founderId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    founder?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    investments?: InvestmentOrderByRelationAggregateInput
    simulationInvestments?: SimulationInvestmentOrderByRelationAggregateInput
    dueDiligenceReports?: DueDiligenceReportOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    dealMatchings?: DealMatchingOrderByRelationAggregateInput
  }

  export type StartupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StartupWhereInput | StartupWhereInput[]
    OR?: StartupWhereInput[]
    NOT?: StartupWhereInput | StartupWhereInput[]
    name?: StringFilter<"Startup"> | string
    description?: StringFilter<"Startup"> | string
    industry?: StringFilter<"Startup"> | string
    stage?: EnumFundingStageFilter<"Startup"> | $Enums.FundingStage
    website?: StringNullableFilter<"Startup"> | string | null
    pitchDeck?: StringNullableFilter<"Startup"> | string | null
    fundingGoal?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFilter<"Startup"> | boolean
    isActive?: BoolFilter<"Startup"> | boolean
    aiGeneratedMetrics?: JsonNullableFilter<"Startup">
    simulationData?: JsonNullableFilter<"Startup">
    createdAt?: DateTimeFilter<"Startup"> | Date | string
    updatedAt?: DateTimeFilter<"Startup"> | Date | string
    founderId?: StringFilter<"Startup"> | string
    organizationId?: StringNullableFilter<"Startup"> | string | null
    founder?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    investments?: InvestmentListRelationFilter
    simulationInvestments?: SimulationInvestmentListRelationFilter
    dueDiligenceReports?: DueDiligenceReportListRelationFilter
    documents?: DocumentListRelationFilter
    comments?: CommentListRelationFilter
    dealMatchings?: DealMatchingListRelationFilter
  }, "id">

  export type StartupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    stage?: SortOrder
    website?: SortOrderInput | SortOrder
    pitchDeck?: SortOrderInput | SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    aiGeneratedMetrics?: SortOrderInput | SortOrder
    simulationData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founderId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    _count?: StartupCountOrderByAggregateInput
    _avg?: StartupAvgOrderByAggregateInput
    _max?: StartupMaxOrderByAggregateInput
    _min?: StartupMinOrderByAggregateInput
    _sum?: StartupSumOrderByAggregateInput
  }

  export type StartupScalarWhereWithAggregatesInput = {
    AND?: StartupScalarWhereWithAggregatesInput | StartupScalarWhereWithAggregatesInput[]
    OR?: StartupScalarWhereWithAggregatesInput[]
    NOT?: StartupScalarWhereWithAggregatesInput | StartupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Startup"> | string
    name?: StringWithAggregatesFilter<"Startup"> | string
    description?: StringWithAggregatesFilter<"Startup"> | string
    industry?: StringWithAggregatesFilter<"Startup"> | string
    stage?: EnumFundingStageWithAggregatesFilter<"Startup"> | $Enums.FundingStage
    website?: StringNullableWithAggregatesFilter<"Startup"> | string | null
    pitchDeck?: StringNullableWithAggregatesFilter<"Startup"> | string | null
    fundingGoal?: DecimalWithAggregatesFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalWithAggregatesFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalWithAggregatesFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolWithAggregatesFilter<"Startup"> | boolean
    isActive?: BoolWithAggregatesFilter<"Startup"> | boolean
    aiGeneratedMetrics?: JsonNullableWithAggregatesFilter<"Startup">
    simulationData?: JsonNullableWithAggregatesFilter<"Startup">
    createdAt?: DateTimeWithAggregatesFilter<"Startup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Startup"> | Date | string
    founderId?: StringWithAggregatesFilter<"Startup"> | string
    organizationId?: StringNullableWithAggregatesFilter<"Startup"> | string | null
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    name?: StringFilter<"Token"> | string
    symbol?: StringFilter<"Token"> | string
    description?: StringFilter<"Token"> | string
    totalSupply?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFilter<"Token"> | string
    whitepaperUrl?: StringNullableFilter<"Token"> | string | null
    fundingGoal?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFilter<"Token"> | boolean
    isActive?: BoolFilter<"Token"> | boolean
    contractAddress?: StringNullableFilter<"Token"> | string | null
    chain?: EnumChainNullableFilter<"Token"> | $Enums.Chain | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    creatorId?: StringFilter<"Token"> | string
    organizationId?: StringNullableFilter<"Token"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    investments?: InvestmentListRelationFilter
    simulationInvestments?: SimulationInvestmentListRelationFilter
    dueDiligenceReports?: DueDiligenceReportListRelationFilter
    documents?: EntityDocumentListRelationFilter
    comments?: CommentListRelationFilter
    dealMatchings?: DealMatchingListRelationFilter
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    totalSupply?: SortOrder
    tokenomics?: SortOrder
    whitepaperUrl?: SortOrderInput | SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    contractAddress?: SortOrderInput | SortOrder
    chain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    investments?: InvestmentOrderByRelationAggregateInput
    simulationInvestments?: SimulationInvestmentOrderByRelationAggregateInput
    dueDiligenceReports?: DueDiligenceReportOrderByRelationAggregateInput
    documents?: EntityDocumentOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    dealMatchings?: DealMatchingOrderByRelationAggregateInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    symbol?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    name?: StringFilter<"Token"> | string
    description?: StringFilter<"Token"> | string
    totalSupply?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFilter<"Token"> | string
    whitepaperUrl?: StringNullableFilter<"Token"> | string | null
    fundingGoal?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFilter<"Token"> | boolean
    isActive?: BoolFilter<"Token"> | boolean
    contractAddress?: StringNullableFilter<"Token"> | string | null
    chain?: EnumChainNullableFilter<"Token"> | $Enums.Chain | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    creatorId?: StringFilter<"Token"> | string
    organizationId?: StringNullableFilter<"Token"> | string | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    investments?: InvestmentListRelationFilter
    simulationInvestments?: SimulationInvestmentListRelationFilter
    dueDiligenceReports?: DueDiligenceReportListRelationFilter
    documents?: EntityDocumentListRelationFilter
    comments?: CommentListRelationFilter
    dealMatchings?: DealMatchingListRelationFilter
  }, "id" | "symbol">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    totalSupply?: SortOrder
    tokenomics?: SortOrder
    whitepaperUrl?: SortOrderInput | SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    contractAddress?: SortOrderInput | SortOrder
    chain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    name?: StringWithAggregatesFilter<"Token"> | string
    symbol?: StringWithAggregatesFilter<"Token"> | string
    description?: StringWithAggregatesFilter<"Token"> | string
    totalSupply?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    tokenomics?: StringWithAggregatesFilter<"Token"> | string
    whitepaperUrl?: StringNullableWithAggregatesFilter<"Token"> | string | null
    fundingGoal?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolWithAggregatesFilter<"Token"> | boolean
    isActive?: BoolWithAggregatesFilter<"Token"> | boolean
    contractAddress?: StringNullableWithAggregatesFilter<"Token"> | string | null
    chain?: EnumChainNullableWithAggregatesFilter<"Token"> | $Enums.Chain | null
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Token"> | string
    organizationId?: StringNullableWithAggregatesFilter<"Token"> | string | null
  }

  export type SimulationWhereInput = {
    AND?: SimulationWhereInput | SimulationWhereInput[]
    OR?: SimulationWhereInput[]
    NOT?: SimulationWhereInput | SimulationWhereInput[]
    id?: StringFilter<"Simulation"> | string
    title?: StringFilter<"Simulation"> | string
    description?: StringFilter<"Simulation"> | string
    type?: EnumSimulationTypeFilter<"Simulation"> | $Enums.SimulationType
    status?: EnumSimulationStatusFilter<"Simulation"> | $Enums.SimulationStatus
    maxParticipants?: IntFilter<"Simulation"> | number
    startDate?: DateTimeFilter<"Simulation"> | Date | string
    endDate?: DateTimeFilter<"Simulation"> | Date | string
    initialBudget?: DecimalFilter<"Simulation"> | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFilter<"Simulation"> | number
    scenarioData?: JsonFilter<"Simulation">
    ownerId?: StringFilter<"Simulation"> | string
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeFilter<"Simulation"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    participants?: UserListRelationFilter
    investments?: SimulationInvestmentListRelationFilter
    leaderboard?: SimulationLeaderboardListRelationFilter
  }

  export type SimulationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxParticipants?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
    scenarioData?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    participants?: UserOrderByRelationAggregateInput
    investments?: SimulationInvestmentOrderByRelationAggregateInput
    leaderboard?: SimulationLeaderboardOrderByRelationAggregateInput
  }

  export type SimulationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SimulationWhereInput | SimulationWhereInput[]
    OR?: SimulationWhereInput[]
    NOT?: SimulationWhereInput | SimulationWhereInput[]
    title?: StringFilter<"Simulation"> | string
    description?: StringFilter<"Simulation"> | string
    type?: EnumSimulationTypeFilter<"Simulation"> | $Enums.SimulationType
    status?: EnumSimulationStatusFilter<"Simulation"> | $Enums.SimulationStatus
    maxParticipants?: IntFilter<"Simulation"> | number
    startDate?: DateTimeFilter<"Simulation"> | Date | string
    endDate?: DateTimeFilter<"Simulation"> | Date | string
    initialBudget?: DecimalFilter<"Simulation"> | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFilter<"Simulation"> | number
    scenarioData?: JsonFilter<"Simulation">
    ownerId?: StringFilter<"Simulation"> | string
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeFilter<"Simulation"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    participants?: UserListRelationFilter
    investments?: SimulationInvestmentListRelationFilter
    leaderboard?: SimulationLeaderboardListRelationFilter
  }, "id">

  export type SimulationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxParticipants?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
    scenarioData?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SimulationCountOrderByAggregateInput
    _avg?: SimulationAvgOrderByAggregateInput
    _max?: SimulationMaxOrderByAggregateInput
    _min?: SimulationMinOrderByAggregateInput
    _sum?: SimulationSumOrderByAggregateInput
  }

  export type SimulationScalarWhereWithAggregatesInput = {
    AND?: SimulationScalarWhereWithAggregatesInput | SimulationScalarWhereWithAggregatesInput[]
    OR?: SimulationScalarWhereWithAggregatesInput[]
    NOT?: SimulationScalarWhereWithAggregatesInput | SimulationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Simulation"> | string
    title?: StringWithAggregatesFilter<"Simulation"> | string
    description?: StringWithAggregatesFilter<"Simulation"> | string
    type?: EnumSimulationTypeWithAggregatesFilter<"Simulation"> | $Enums.SimulationType
    status?: EnumSimulationStatusWithAggregatesFilter<"Simulation"> | $Enums.SimulationStatus
    maxParticipants?: IntWithAggregatesFilter<"Simulation"> | number
    startDate?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
    initialBudget?: DecimalWithAggregatesFilter<"Simulation"> | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntWithAggregatesFilter<"Simulation"> | number
    scenarioData?: JsonWithAggregatesFilter<"Simulation">
    ownerId?: StringWithAggregatesFilter<"Simulation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Simulation"> | Date | string
  }

  export type SimulationInvestmentWhereInput = {
    AND?: SimulationInvestmentWhereInput | SimulationInvestmentWhereInput[]
    OR?: SimulationInvestmentWhereInput[]
    NOT?: SimulationInvestmentWhereInput | SimulationInvestmentWhereInput[]
    id?: StringFilter<"SimulationInvestment"> | string
    simulationId?: StringFilter<"SimulationInvestment"> | string
    userId?: StringFilter<"SimulationInvestment"> | string
    startupId?: StringNullableFilter<"SimulationInvestment"> | string | null
    tokenId?: StringNullableFilter<"SimulationInvestment"> | string | null
    amount?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    roi?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SimulationInvestment"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationInvestment"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }

  export type SimulationInvestmentOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    simulation?: SimulationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    startup?: StartupOrderByWithRelationInput
    token?: TokenOrderByWithRelationInput
  }

  export type SimulationInvestmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    simulationId_userId_startupId?: SimulationInvestmentSimulationIdUserIdStartupIdCompoundUniqueInput
    simulationId_userId_tokenId?: SimulationInvestmentSimulationIdUserIdTokenIdCompoundUniqueInput
    AND?: SimulationInvestmentWhereInput | SimulationInvestmentWhereInput[]
    OR?: SimulationInvestmentWhereInput[]
    NOT?: SimulationInvestmentWhereInput | SimulationInvestmentWhereInput[]
    simulationId?: StringFilter<"SimulationInvestment"> | string
    userId?: StringFilter<"SimulationInvestment"> | string
    startupId?: StringNullableFilter<"SimulationInvestment"> | string | null
    tokenId?: StringNullableFilter<"SimulationInvestment"> | string | null
    amount?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    roi?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SimulationInvestment"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationInvestment"> | Date | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }, "id" | "simulationId_userId_startupId" | "simulationId_userId_tokenId">

  export type SimulationInvestmentOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SimulationInvestmentCountOrderByAggregateInput
    _avg?: SimulationInvestmentAvgOrderByAggregateInput
    _max?: SimulationInvestmentMaxOrderByAggregateInput
    _min?: SimulationInvestmentMinOrderByAggregateInput
    _sum?: SimulationInvestmentSumOrderByAggregateInput
  }

  export type SimulationInvestmentScalarWhereWithAggregatesInput = {
    AND?: SimulationInvestmentScalarWhereWithAggregatesInput | SimulationInvestmentScalarWhereWithAggregatesInput[]
    OR?: SimulationInvestmentScalarWhereWithAggregatesInput[]
    NOT?: SimulationInvestmentScalarWhereWithAggregatesInput | SimulationInvestmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimulationInvestment"> | string
    simulationId?: StringWithAggregatesFilter<"SimulationInvestment"> | string
    userId?: StringWithAggregatesFilter<"SimulationInvestment"> | string
    startupId?: StringNullableWithAggregatesFilter<"SimulationInvestment"> | string | null
    tokenId?: StringNullableWithAggregatesFilter<"SimulationInvestment"> | string | null
    amount?: DecimalWithAggregatesFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalWithAggregatesFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalWithAggregatesFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    roi?: DecimalWithAggregatesFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SimulationInvestment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SimulationInvestment"> | Date | string
  }

  export type SimulationLeaderboardWhereInput = {
    AND?: SimulationLeaderboardWhereInput | SimulationLeaderboardWhereInput[]
    OR?: SimulationLeaderboardWhereInput[]
    NOT?: SimulationLeaderboardWhereInput | SimulationLeaderboardWhereInput[]
    id?: StringFilter<"SimulationLeaderboard"> | string
    simulationId?: StringFilter<"SimulationLeaderboard"> | string
    userId?: StringFilter<"SimulationLeaderboard"> | string
    rank?: IntFilter<"SimulationLeaderboard"> | number
    totalReturn?: DecimalFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SimulationLeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
    simulation?: SimulationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SimulationLeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    simulationId_userId?: SimulationLeaderboardSimulationIdUserIdCompoundUniqueInput
    AND?: SimulationLeaderboardWhereInput | SimulationLeaderboardWhereInput[]
    OR?: SimulationLeaderboardWhereInput[]
    NOT?: SimulationLeaderboardWhereInput | SimulationLeaderboardWhereInput[]
    simulationId?: StringFilter<"SimulationLeaderboard"> | string
    userId?: StringFilter<"SimulationLeaderboard"> | string
    rank?: IntFilter<"SimulationLeaderboard"> | number
    totalReturn?: DecimalFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
    simulation?: XOR<SimulationScalarRelationFilter, SimulationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "simulationId_userId">

  export type SimulationLeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
    _count?: SimulationLeaderboardCountOrderByAggregateInput
    _avg?: SimulationLeaderboardAvgOrderByAggregateInput
    _max?: SimulationLeaderboardMaxOrderByAggregateInput
    _min?: SimulationLeaderboardMinOrderByAggregateInput
    _sum?: SimulationLeaderboardSumOrderByAggregateInput
  }

  export type SimulationLeaderboardScalarWhereWithAggregatesInput = {
    AND?: SimulationLeaderboardScalarWhereWithAggregatesInput | SimulationLeaderboardScalarWhereWithAggregatesInput[]
    OR?: SimulationLeaderboardScalarWhereWithAggregatesInput[]
    NOT?: SimulationLeaderboardScalarWhereWithAggregatesInput | SimulationLeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SimulationLeaderboard"> | string
    simulationId?: StringWithAggregatesFilter<"SimulationLeaderboard"> | string
    userId?: StringWithAggregatesFilter<"SimulationLeaderboard"> | string
    rank?: IntWithAggregatesFilter<"SimulationLeaderboard"> | number
    totalReturn?: DecimalWithAggregatesFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalWithAggregatesFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
  }

  export type DealMatchingWhereInput = {
    AND?: DealMatchingWhereInput | DealMatchingWhereInput[]
    OR?: DealMatchingWhereInput[]
    NOT?: DealMatchingWhereInput | DealMatchingWhereInput[]
    id?: StringFilter<"DealMatching"> | string
    userId?: StringFilter<"DealMatching"> | string
    startupId?: StringNullableFilter<"DealMatching"> | string | null
    tokenId?: StringNullableFilter<"DealMatching"> | string | null
    matchScore?: DecimalFilter<"DealMatching"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringFilter<"DealMatching"> | string
    isRecommended?: BoolFilter<"DealMatching"> | boolean
    userFeedback?: StringNullableFilter<"DealMatching"> | string | null
    createdAt?: DateTimeFilter<"DealMatching"> | Date | string
    updatedAt?: DateTimeFilter<"DealMatching"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }

  export type DealMatchingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    matchScore?: SortOrder
    reasoning?: SortOrder
    isRecommended?: SortOrder
    userFeedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    startup?: StartupOrderByWithRelationInput
    token?: TokenOrderByWithRelationInput
  }

  export type DealMatchingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealMatchingWhereInput | DealMatchingWhereInput[]
    OR?: DealMatchingWhereInput[]
    NOT?: DealMatchingWhereInput | DealMatchingWhereInput[]
    userId?: StringFilter<"DealMatching"> | string
    startupId?: StringNullableFilter<"DealMatching"> | string | null
    tokenId?: StringNullableFilter<"DealMatching"> | string | null
    matchScore?: DecimalFilter<"DealMatching"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringFilter<"DealMatching"> | string
    isRecommended?: BoolFilter<"DealMatching"> | boolean
    userFeedback?: StringNullableFilter<"DealMatching"> | string | null
    createdAt?: DateTimeFilter<"DealMatching"> | Date | string
    updatedAt?: DateTimeFilter<"DealMatching"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }, "id">

  export type DealMatchingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    matchScore?: SortOrder
    reasoning?: SortOrder
    isRecommended?: SortOrder
    userFeedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealMatchingCountOrderByAggregateInput
    _avg?: DealMatchingAvgOrderByAggregateInput
    _max?: DealMatchingMaxOrderByAggregateInput
    _min?: DealMatchingMinOrderByAggregateInput
    _sum?: DealMatchingSumOrderByAggregateInput
  }

  export type DealMatchingScalarWhereWithAggregatesInput = {
    AND?: DealMatchingScalarWhereWithAggregatesInput | DealMatchingScalarWhereWithAggregatesInput[]
    OR?: DealMatchingScalarWhereWithAggregatesInput[]
    NOT?: DealMatchingScalarWhereWithAggregatesInput | DealMatchingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DealMatching"> | string
    userId?: StringWithAggregatesFilter<"DealMatching"> | string
    startupId?: StringNullableWithAggregatesFilter<"DealMatching"> | string | null
    tokenId?: StringNullableWithAggregatesFilter<"DealMatching"> | string | null
    matchScore?: DecimalWithAggregatesFilter<"DealMatching"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringWithAggregatesFilter<"DealMatching"> | string
    isRecommended?: BoolWithAggregatesFilter<"DealMatching"> | boolean
    userFeedback?: StringNullableWithAggregatesFilter<"DealMatching"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DealMatching"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DealMatching"> | Date | string
  }

  export type LearningModuleWhereInput = {
    AND?: LearningModuleWhereInput | LearningModuleWhereInput[]
    OR?: LearningModuleWhereInput[]
    NOT?: LearningModuleWhereInput | LearningModuleWhereInput[]
    id?: StringFilter<"LearningModule"> | string
    title?: StringFilter<"LearningModule"> | string
    description?: StringFilter<"LearningModule"> | string
    content?: StringFilter<"LearningModule"> | string
    category?: StringFilter<"LearningModule"> | string
    difficulty?: IntFilter<"LearningModule"> | number
    order?: IntFilter<"LearningModule"> | number
    isActive?: BoolFilter<"LearningModule"> | boolean
    createdAt?: DateTimeFilter<"LearningModule"> | Date | string
    updatedAt?: DateTimeFilter<"LearningModule"> | Date | string
    userLearningModules?: UserLearningModuleListRelationFilter
  }

  export type LearningModuleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userLearningModules?: UserLearningModuleOrderByRelationAggregateInput
  }

  export type LearningModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningModuleWhereInput | LearningModuleWhereInput[]
    OR?: LearningModuleWhereInput[]
    NOT?: LearningModuleWhereInput | LearningModuleWhereInput[]
    title?: StringFilter<"LearningModule"> | string
    description?: StringFilter<"LearningModule"> | string
    content?: StringFilter<"LearningModule"> | string
    category?: StringFilter<"LearningModule"> | string
    difficulty?: IntFilter<"LearningModule"> | number
    order?: IntFilter<"LearningModule"> | number
    isActive?: BoolFilter<"LearningModule"> | boolean
    createdAt?: DateTimeFilter<"LearningModule"> | Date | string
    updatedAt?: DateTimeFilter<"LearningModule"> | Date | string
    userLearningModules?: UserLearningModuleListRelationFilter
  }, "id">

  export type LearningModuleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LearningModuleCountOrderByAggregateInput
    _avg?: LearningModuleAvgOrderByAggregateInput
    _max?: LearningModuleMaxOrderByAggregateInput
    _min?: LearningModuleMinOrderByAggregateInput
    _sum?: LearningModuleSumOrderByAggregateInput
  }

  export type LearningModuleScalarWhereWithAggregatesInput = {
    AND?: LearningModuleScalarWhereWithAggregatesInput | LearningModuleScalarWhereWithAggregatesInput[]
    OR?: LearningModuleScalarWhereWithAggregatesInput[]
    NOT?: LearningModuleScalarWhereWithAggregatesInput | LearningModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningModule"> | string
    title?: StringWithAggregatesFilter<"LearningModule"> | string
    description?: StringWithAggregatesFilter<"LearningModule"> | string
    content?: StringWithAggregatesFilter<"LearningModule"> | string
    category?: StringWithAggregatesFilter<"LearningModule"> | string
    difficulty?: IntWithAggregatesFilter<"LearningModule"> | number
    order?: IntWithAggregatesFilter<"LearningModule"> | number
    isActive?: BoolWithAggregatesFilter<"LearningModule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LearningModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningModule"> | Date | string
  }

  export type UserLearningModuleWhereInput = {
    AND?: UserLearningModuleWhereInput | UserLearningModuleWhereInput[]
    OR?: UserLearningModuleWhereInput[]
    NOT?: UserLearningModuleWhereInput | UserLearningModuleWhereInput[]
    id?: StringFilter<"UserLearningModule"> | string
    userId?: StringFilter<"UserLearningModule"> | string
    learningModuleId?: StringFilter<"UserLearningModule"> | string
    completed?: BoolFilter<"UserLearningModule"> | boolean
    score?: IntNullableFilter<"UserLearningModule"> | number | null
    completedAt?: DateTimeNullableFilter<"UserLearningModule"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    learningModule?: XOR<LearningModuleScalarRelationFilter, LearningModuleWhereInput>
  }

  export type UserLearningModuleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningModuleId?: SortOrder
    completed?: SortOrder
    score?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    learningModule?: LearningModuleOrderByWithRelationInput
  }

  export type UserLearningModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_learningModuleId?: UserLearningModuleUserIdLearningModuleIdCompoundUniqueInput
    AND?: UserLearningModuleWhereInput | UserLearningModuleWhereInput[]
    OR?: UserLearningModuleWhereInput[]
    NOT?: UserLearningModuleWhereInput | UserLearningModuleWhereInput[]
    userId?: StringFilter<"UserLearningModule"> | string
    learningModuleId?: StringFilter<"UserLearningModule"> | string
    completed?: BoolFilter<"UserLearningModule"> | boolean
    score?: IntNullableFilter<"UserLearningModule"> | number | null
    completedAt?: DateTimeNullableFilter<"UserLearningModule"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    learningModule?: XOR<LearningModuleScalarRelationFilter, LearningModuleWhereInput>
  }, "id" | "userId_learningModuleId">

  export type UserLearningModuleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningModuleId?: SortOrder
    completed?: SortOrder
    score?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: UserLearningModuleCountOrderByAggregateInput
    _avg?: UserLearningModuleAvgOrderByAggregateInput
    _max?: UserLearningModuleMaxOrderByAggregateInput
    _min?: UserLearningModuleMinOrderByAggregateInput
    _sum?: UserLearningModuleSumOrderByAggregateInput
  }

  export type UserLearningModuleScalarWhereWithAggregatesInput = {
    AND?: UserLearningModuleScalarWhereWithAggregatesInput | UserLearningModuleScalarWhereWithAggregatesInput[]
    OR?: UserLearningModuleScalarWhereWithAggregatesInput[]
    NOT?: UserLearningModuleScalarWhereWithAggregatesInput | UserLearningModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLearningModule"> | string
    userId?: StringWithAggregatesFilter<"UserLearningModule"> | string
    learningModuleId?: StringWithAggregatesFilter<"UserLearningModule"> | string
    completed?: BoolWithAggregatesFilter<"UserLearningModule"> | boolean
    score?: IntNullableWithAggregatesFilter<"UserLearningModule"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserLearningModule"> | Date | string | null
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    totalScore?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    completedSimulations?: IntFilter<"UserProgress"> | number
    successfulInvestments?: IntFilter<"UserProgress"> | number
    averageROI?: DecimalFilter<"UserProgress"> | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFilter<"UserProgress"> | number
    dueDiligenceSkill?: IntFilter<"UserProgress"> | number
    riskAssessmentSkill?: IntFilter<"UserProgress"> | number
    lastActivityAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
    lastActivityAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    totalScore?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    completedSimulations?: IntFilter<"UserProgress"> | number
    successfulInvestments?: IntFilter<"UserProgress"> | number
    averageROI?: DecimalFilter<"UserProgress"> | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFilter<"UserProgress"> | number
    dueDiligenceSkill?: IntFilter<"UserProgress"> | number
    riskAssessmentSkill?: IntFilter<"UserProgress"> | number
    lastActivityAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
    lastActivityAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    totalScore?: IntWithAggregatesFilter<"UserProgress"> | number
    currentLevel?: IntWithAggregatesFilter<"UserProgress"> | number
    completedSimulations?: IntWithAggregatesFilter<"UserProgress"> | number
    successfulInvestments?: IntWithAggregatesFilter<"UserProgress"> | number
    averageROI?: DecimalWithAggregatesFilter<"UserProgress"> | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntWithAggregatesFilter<"UserProgress"> | number
    dueDiligenceSkill?: IntWithAggregatesFilter<"UserProgress"> | number
    riskAssessmentSkill?: IntWithAggregatesFilter<"UserProgress"> | number
    lastActivityAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type InvestmentWhereInput = {
    AND?: InvestmentWhereInput | InvestmentWhereInput[]
    OR?: InvestmentWhereInput[]
    NOT?: InvestmentWhereInput | InvestmentWhereInput[]
    id?: StringFilter<"Investment"> | string
    userId?: StringFilter<"Investment"> | string
    startupId?: StringNullableFilter<"Investment"> | string | null
    tokenId?: StringNullableFilter<"Investment"> | string | null
    amount?: DecimalFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalNullableFilter<"Investment"> | Decimal | DecimalJsLike | number | string | null
    terms?: JsonNullableFilter<"Investment">
    status?: StringFilter<"Investment"> | string
    createdAt?: DateTimeFilter<"Investment"> | Date | string
    updatedAt?: DateTimeFilter<"Investment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
    vesting?: VestingScheduleListRelationFilter
  }

  export type InvestmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    startup?: StartupOrderByWithRelationInput
    token?: TokenOrderByWithRelationInput
    vesting?: VestingScheduleOrderByRelationAggregateInput
  }

  export type InvestmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_startupId?: InvestmentUserIdStartupIdCompoundUniqueInput
    userId_tokenId?: InvestmentUserIdTokenIdCompoundUniqueInput
    AND?: InvestmentWhereInput | InvestmentWhereInput[]
    OR?: InvestmentWhereInput[]
    NOT?: InvestmentWhereInput | InvestmentWhereInput[]
    userId?: StringFilter<"Investment"> | string
    startupId?: StringNullableFilter<"Investment"> | string | null
    tokenId?: StringNullableFilter<"Investment"> | string | null
    amount?: DecimalFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalNullableFilter<"Investment"> | Decimal | DecimalJsLike | number | string | null
    terms?: JsonNullableFilter<"Investment">
    status?: StringFilter<"Investment"> | string
    createdAt?: DateTimeFilter<"Investment"> | Date | string
    updatedAt?: DateTimeFilter<"Investment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
    vesting?: VestingScheduleListRelationFilter
  }, "id" | "userId_startupId" | "userId_tokenId">

  export type InvestmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestmentCountOrderByAggregateInput
    _avg?: InvestmentAvgOrderByAggregateInput
    _max?: InvestmentMaxOrderByAggregateInput
    _min?: InvestmentMinOrderByAggregateInput
    _sum?: InvestmentSumOrderByAggregateInput
  }

  export type InvestmentScalarWhereWithAggregatesInput = {
    AND?: InvestmentScalarWhereWithAggregatesInput | InvestmentScalarWhereWithAggregatesInput[]
    OR?: InvestmentScalarWhereWithAggregatesInput[]
    NOT?: InvestmentScalarWhereWithAggregatesInput | InvestmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investment"> | string
    userId?: StringWithAggregatesFilter<"Investment"> | string
    startupId?: StringNullableWithAggregatesFilter<"Investment"> | string | null
    tokenId?: StringNullableWithAggregatesFilter<"Investment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalWithAggregatesFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalNullableWithAggregatesFilter<"Investment"> | Decimal | DecimalJsLike | number | string | null
    terms?: JsonNullableWithAggregatesFilter<"Investment">
    status?: StringWithAggregatesFilter<"Investment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Investment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investment"> | Date | string
  }

  export type VestingScheduleWhereInput = {
    AND?: VestingScheduleWhereInput | VestingScheduleWhereInput[]
    OR?: VestingScheduleWhereInput[]
    NOT?: VestingScheduleWhereInput | VestingScheduleWhereInput[]
    id?: StringFilter<"VestingSchedule"> | string
    investmentId?: StringFilter<"VestingSchedule"> | string
    cliffDate?: DateTimeFilter<"VestingSchedule"> | Date | string
    unlockDate?: DateTimeFilter<"VestingSchedule"> | Date | string
    percentage?: DecimalFilter<"VestingSchedule"> | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFilter<"VestingSchedule"> | boolean
    createdAt?: DateTimeFilter<"VestingSchedule"> | Date | string
    investment?: XOR<InvestmentScalarRelationFilter, InvestmentWhereInput>
  }

  export type VestingScheduleOrderByWithRelationInput = {
    id?: SortOrder
    investmentId?: SortOrder
    cliffDate?: SortOrder
    unlockDate?: SortOrder
    percentage?: SortOrder
    isUnlocked?: SortOrder
    createdAt?: SortOrder
    investment?: InvestmentOrderByWithRelationInput
  }

  export type VestingScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VestingScheduleWhereInput | VestingScheduleWhereInput[]
    OR?: VestingScheduleWhereInput[]
    NOT?: VestingScheduleWhereInput | VestingScheduleWhereInput[]
    investmentId?: StringFilter<"VestingSchedule"> | string
    cliffDate?: DateTimeFilter<"VestingSchedule"> | Date | string
    unlockDate?: DateTimeFilter<"VestingSchedule"> | Date | string
    percentage?: DecimalFilter<"VestingSchedule"> | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFilter<"VestingSchedule"> | boolean
    createdAt?: DateTimeFilter<"VestingSchedule"> | Date | string
    investment?: XOR<InvestmentScalarRelationFilter, InvestmentWhereInput>
  }, "id">

  export type VestingScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    investmentId?: SortOrder
    cliffDate?: SortOrder
    unlockDate?: SortOrder
    percentage?: SortOrder
    isUnlocked?: SortOrder
    createdAt?: SortOrder
    _count?: VestingScheduleCountOrderByAggregateInput
    _avg?: VestingScheduleAvgOrderByAggregateInput
    _max?: VestingScheduleMaxOrderByAggregateInput
    _min?: VestingScheduleMinOrderByAggregateInput
    _sum?: VestingScheduleSumOrderByAggregateInput
  }

  export type VestingScheduleScalarWhereWithAggregatesInput = {
    AND?: VestingScheduleScalarWhereWithAggregatesInput | VestingScheduleScalarWhereWithAggregatesInput[]
    OR?: VestingScheduleScalarWhereWithAggregatesInput[]
    NOT?: VestingScheduleScalarWhereWithAggregatesInput | VestingScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VestingSchedule"> | string
    investmentId?: StringWithAggregatesFilter<"VestingSchedule"> | string
    cliffDate?: DateTimeWithAggregatesFilter<"VestingSchedule"> | Date | string
    unlockDate?: DateTimeWithAggregatesFilter<"VestingSchedule"> | Date | string
    percentage?: DecimalWithAggregatesFilter<"VestingSchedule"> | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolWithAggregatesFilter<"VestingSchedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VestingSchedule"> | Date | string
  }

  export type KYCRecordWhereInput = {
    AND?: KYCRecordWhereInput | KYCRecordWhereInput[]
    OR?: KYCRecordWhereInput[]
    NOT?: KYCRecordWhereInput | KYCRecordWhereInput[]
    id?: StringFilter<"KYCRecord"> | string
    userId?: StringFilter<"KYCRecord"> | string
    status?: EnumKYCStatusFilter<"KYCRecord"> | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFilter<"KYCRecord"> | $Enums.AccreditationStatus
    reason?: StringNullableFilter<"KYCRecord"> | string | null
    documentUrls?: StringNullableFilter<"KYCRecord"> | string | null
    verificationData?: JsonNullableFilter<"KYCRecord">
    createdAt?: DateTimeFilter<"KYCRecord"> | Date | string
    updatedAt?: DateTimeFilter<"KYCRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KYCRecordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    accreditationStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    documentUrls?: SortOrderInput | SortOrder
    verificationData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type KYCRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: KYCRecordWhereInput | KYCRecordWhereInput[]
    OR?: KYCRecordWhereInput[]
    NOT?: KYCRecordWhereInput | KYCRecordWhereInput[]
    status?: EnumKYCStatusFilter<"KYCRecord"> | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFilter<"KYCRecord"> | $Enums.AccreditationStatus
    reason?: StringNullableFilter<"KYCRecord"> | string | null
    documentUrls?: StringNullableFilter<"KYCRecord"> | string | null
    verificationData?: JsonNullableFilter<"KYCRecord">
    createdAt?: DateTimeFilter<"KYCRecord"> | Date | string
    updatedAt?: DateTimeFilter<"KYCRecord"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type KYCRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    accreditationStatus?: SortOrder
    reason?: SortOrderInput | SortOrder
    documentUrls?: SortOrderInput | SortOrder
    verificationData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KYCRecordCountOrderByAggregateInput
    _max?: KYCRecordMaxOrderByAggregateInput
    _min?: KYCRecordMinOrderByAggregateInput
  }

  export type KYCRecordScalarWhereWithAggregatesInput = {
    AND?: KYCRecordScalarWhereWithAggregatesInput | KYCRecordScalarWhereWithAggregatesInput[]
    OR?: KYCRecordScalarWhereWithAggregatesInput[]
    NOT?: KYCRecordScalarWhereWithAggregatesInput | KYCRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYCRecord"> | string
    userId?: StringWithAggregatesFilter<"KYCRecord"> | string
    status?: EnumKYCStatusWithAggregatesFilter<"KYCRecord"> | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusWithAggregatesFilter<"KYCRecord"> | $Enums.AccreditationStatus
    reason?: StringNullableWithAggregatesFilter<"KYCRecord"> | string | null
    documentUrls?: StringNullableWithAggregatesFilter<"KYCRecord"> | string | null
    verificationData?: JsonNullableWithAggregatesFilter<"KYCRecord">
    createdAt?: DateTimeWithAggregatesFilter<"KYCRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KYCRecord"> | Date | string
  }

  export type DueDiligenceReportWhereInput = {
    AND?: DueDiligenceReportWhereInput | DueDiligenceReportWhereInput[]
    OR?: DueDiligenceReportWhereInput[]
    NOT?: DueDiligenceReportWhereInput | DueDiligenceReportWhereInput[]
    id?: StringFilter<"DueDiligenceReport"> | string
    entityType?: EnumEntityTypeFilter<"DueDiligenceReport"> | $Enums.EntityType
    entityId?: StringFilter<"DueDiligenceReport"> | string
    summary?: StringFilter<"DueDiligenceReport"> | string
    riskScore?: IntFilter<"DueDiligenceReport"> | number
    sentiment?: StringNullableFilter<"DueDiligenceReport"> | string | null
    financialScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    teamScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    marketScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    technologyScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    aiGenerated?: BoolFilter<"DueDiligenceReport"> | boolean
    createdAt?: DateTimeFilter<"DueDiligenceReport"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligenceReport"> | Date | string
    startupId?: StringNullableFilter<"DueDiligenceReport"> | string | null
    tokenId?: StringNullableFilter<"DueDiligenceReport"> | string | null
    Startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    Token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }

  export type DueDiligenceReportOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    summary?: SortOrder
    riskScore?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    financialScore?: SortOrderInput | SortOrder
    teamScore?: SortOrderInput | SortOrder
    marketScore?: SortOrderInput | SortOrder
    technologyScore?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    Startup?: StartupOrderByWithRelationInput
    Token?: TokenOrderByWithRelationInput
  }

  export type DueDiligenceReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DueDiligenceReportWhereInput | DueDiligenceReportWhereInput[]
    OR?: DueDiligenceReportWhereInput[]
    NOT?: DueDiligenceReportWhereInput | DueDiligenceReportWhereInput[]
    entityType?: EnumEntityTypeFilter<"DueDiligenceReport"> | $Enums.EntityType
    entityId?: StringFilter<"DueDiligenceReport"> | string
    summary?: StringFilter<"DueDiligenceReport"> | string
    riskScore?: IntFilter<"DueDiligenceReport"> | number
    sentiment?: StringNullableFilter<"DueDiligenceReport"> | string | null
    financialScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    teamScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    marketScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    technologyScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    aiGenerated?: BoolFilter<"DueDiligenceReport"> | boolean
    createdAt?: DateTimeFilter<"DueDiligenceReport"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligenceReport"> | Date | string
    startupId?: StringNullableFilter<"DueDiligenceReport"> | string | null
    tokenId?: StringNullableFilter<"DueDiligenceReport"> | string | null
    Startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    Token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }, "id">

  export type DueDiligenceReportOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    summary?: SortOrder
    riskScore?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    financialScore?: SortOrderInput | SortOrder
    teamScore?: SortOrderInput | SortOrder
    marketScore?: SortOrderInput | SortOrder
    technologyScore?: SortOrderInput | SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    _count?: DueDiligenceReportCountOrderByAggregateInput
    _avg?: DueDiligenceReportAvgOrderByAggregateInput
    _max?: DueDiligenceReportMaxOrderByAggregateInput
    _min?: DueDiligenceReportMinOrderByAggregateInput
    _sum?: DueDiligenceReportSumOrderByAggregateInput
  }

  export type DueDiligenceReportScalarWhereWithAggregatesInput = {
    AND?: DueDiligenceReportScalarWhereWithAggregatesInput | DueDiligenceReportScalarWhereWithAggregatesInput[]
    OR?: DueDiligenceReportScalarWhereWithAggregatesInput[]
    NOT?: DueDiligenceReportScalarWhereWithAggregatesInput | DueDiligenceReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DueDiligenceReport"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"DueDiligenceReport"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"DueDiligenceReport"> | string
    summary?: StringWithAggregatesFilter<"DueDiligenceReport"> | string
    riskScore?: IntWithAggregatesFilter<"DueDiligenceReport"> | number
    sentiment?: StringNullableWithAggregatesFilter<"DueDiligenceReport"> | string | null
    financialScore?: IntNullableWithAggregatesFilter<"DueDiligenceReport"> | number | null
    teamScore?: IntNullableWithAggregatesFilter<"DueDiligenceReport"> | number | null
    marketScore?: IntNullableWithAggregatesFilter<"DueDiligenceReport"> | number | null
    technologyScore?: IntNullableWithAggregatesFilter<"DueDiligenceReport"> | number | null
    aiGenerated?: BoolWithAggregatesFilter<"DueDiligenceReport"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DueDiligenceReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DueDiligenceReport"> | Date | string
    startupId?: StringNullableWithAggregatesFilter<"DueDiligenceReport"> | string | null
    tokenId?: StringNullableWithAggregatesFilter<"DueDiligenceReport"> | string | null
  }

  export type AdminActivityLogWhereInput = {
    AND?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    OR?: AdminActivityLogWhereInput[]
    NOT?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    id?: StringFilter<"AdminActivityLog"> | string
    adminId?: StringFilter<"AdminActivityLog"> | string
    action?: StringFilter<"AdminActivityLog"> | string
    targetId?: StringNullableFilter<"AdminActivityLog"> | string | null
    targetType?: EnumEntityTypeNullableFilter<"AdminActivityLog"> | $Enums.EntityType | null
    details?: JsonNullableFilter<"AdminActivityLog">
    timestamp?: DateTimeFilter<"AdminActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    OR?: AdminActivityLogWhereInput[]
    NOT?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    adminId?: StringFilter<"AdminActivityLog"> | string
    action?: StringFilter<"AdminActivityLog"> | string
    targetId?: StringNullableFilter<"AdminActivityLog"> | string | null
    targetType?: EnumEntityTypeNullableFilter<"AdminActivityLog"> | $Enums.EntityType | null
    details?: JsonNullableFilter<"AdminActivityLog">
    timestamp?: DateTimeFilter<"AdminActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetType?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AdminActivityLogCountOrderByAggregateInput
    _max?: AdminActivityLogMaxOrderByAggregateInput
    _min?: AdminActivityLogMinOrderByAggregateInput
  }

  export type AdminActivityLogScalarWhereWithAggregatesInput = {
    AND?: AdminActivityLogScalarWhereWithAggregatesInput | AdminActivityLogScalarWhereWithAggregatesInput[]
    OR?: AdminActivityLogScalarWhereWithAggregatesInput[]
    NOT?: AdminActivityLogScalarWhereWithAggregatesInput | AdminActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    adminId?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    action?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AdminActivityLog"> | string | null
    targetType?: EnumEntityTypeNullableWithAggregatesFilter<"AdminActivityLog"> | $Enums.EntityType | null
    details?: JsonNullableWithAggregatesFilter<"AdminActivityLog">
    timestamp?: DateTimeWithAggregatesFilter<"AdminActivityLog"> | Date | string
  }

  export type PaymentIntentWhereInput = {
    AND?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    OR?: PaymentIntentWhereInput[]
    NOT?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    id?: StringFilter<"PaymentIntent"> | string
    userId?: StringFilter<"PaymentIntent"> | string
    provider?: StringFilter<"PaymentIntent"> | string
    providerId?: StringFilter<"PaymentIntent"> | string
    amount?: DecimalFilter<"PaymentIntent"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentIntent"> | string
    status?: EnumPaymentStatusFilter<"PaymentIntent"> | $Enums.PaymentStatus
    metadata?: JsonNullableFilter<"PaymentIntent">
    createdAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaymentIntentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentIntentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    OR?: PaymentIntentWhereInput[]
    NOT?: PaymentIntentWhereInput | PaymentIntentWhereInput[]
    userId?: StringFilter<"PaymentIntent"> | string
    provider?: StringFilter<"PaymentIntent"> | string
    providerId?: StringFilter<"PaymentIntent"> | string
    amount?: DecimalFilter<"PaymentIntent"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentIntent"> | string
    status?: EnumPaymentStatusFilter<"PaymentIntent"> | $Enums.PaymentStatus
    metadata?: JsonNullableFilter<"PaymentIntent">
    createdAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PaymentIntentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentIntentCountOrderByAggregateInput
    _avg?: PaymentIntentAvgOrderByAggregateInput
    _max?: PaymentIntentMaxOrderByAggregateInput
    _min?: PaymentIntentMinOrderByAggregateInput
    _sum?: PaymentIntentSumOrderByAggregateInput
  }

  export type PaymentIntentScalarWhereWithAggregatesInput = {
    AND?: PaymentIntentScalarWhereWithAggregatesInput | PaymentIntentScalarWhereWithAggregatesInput[]
    OR?: PaymentIntentScalarWhereWithAggregatesInput[]
    NOT?: PaymentIntentScalarWhereWithAggregatesInput | PaymentIntentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentIntent"> | string
    userId?: StringWithAggregatesFilter<"PaymentIntent"> | string
    provider?: StringWithAggregatesFilter<"PaymentIntent"> | string
    providerId?: StringWithAggregatesFilter<"PaymentIntent"> | string
    amount?: DecimalWithAggregatesFilter<"PaymentIntent"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"PaymentIntent"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"PaymentIntent"> | $Enums.PaymentStatus
    metadata?: JsonNullableWithAggregatesFilter<"PaymentIntent">
    createdAt?: DateTimeWithAggregatesFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentIntent"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    chain?: EnumChainFilter<"Wallet"> | $Enums.Chain
    nickname?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    txs?: CryptoTxListRelationFilter
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    nickname?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    txs?: CryptoTxOrderByRelationAggregateInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chain_address?: WalletChainAddressCompoundUniqueInput
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    userId?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    chain?: EnumChainFilter<"Wallet"> | $Enums.Chain
    nickname?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    txs?: CryptoTxListRelationFilter
  }, "id" | "chain_address">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    nickname?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    address?: StringWithAggregatesFilter<"Wallet"> | string
    chain?: EnumChainWithAggregatesFilter<"Wallet"> | $Enums.Chain
    nickname?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    isActive?: BoolWithAggregatesFilter<"Wallet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type CryptoTxWhereInput = {
    AND?: CryptoTxWhereInput | CryptoTxWhereInput[]
    OR?: CryptoTxWhereInput[]
    NOT?: CryptoTxWhereInput | CryptoTxWhereInput[]
    id?: StringFilter<"CryptoTx"> | string
    walletId?: StringFilter<"CryptoTx"> | string
    entityType?: EnumEntityTypeFilter<"CryptoTx"> | $Enums.EntityType
    entityId?: StringFilter<"CryptoTx"> | string
    txHash?: StringFilter<"CryptoTx"> | string
    amount?: DecimalFilter<"CryptoTx"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"CryptoTx"> | $Enums.PaymentStatus
    blockNumber?: BigIntNullableFilter<"CryptoTx"> | bigint | number | null
    gasUsed?: BigIntNullableFilter<"CryptoTx"> | bigint | number | null
    timestamp?: DateTimeFilter<"CryptoTx"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
  }

  export type CryptoTxOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    txHash?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    gasUsed?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type CryptoTxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    txHash?: string
    AND?: CryptoTxWhereInput | CryptoTxWhereInput[]
    OR?: CryptoTxWhereInput[]
    NOT?: CryptoTxWhereInput | CryptoTxWhereInput[]
    walletId?: StringFilter<"CryptoTx"> | string
    entityType?: EnumEntityTypeFilter<"CryptoTx"> | $Enums.EntityType
    entityId?: StringFilter<"CryptoTx"> | string
    amount?: DecimalFilter<"CryptoTx"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"CryptoTx"> | $Enums.PaymentStatus
    blockNumber?: BigIntNullableFilter<"CryptoTx"> | bigint | number | null
    gasUsed?: BigIntNullableFilter<"CryptoTx"> | bigint | number | null
    timestamp?: DateTimeFilter<"CryptoTx"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
  }, "id" | "txHash">

  export type CryptoTxOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    txHash?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrderInput | SortOrder
    gasUsed?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: CryptoTxCountOrderByAggregateInput
    _avg?: CryptoTxAvgOrderByAggregateInput
    _max?: CryptoTxMaxOrderByAggregateInput
    _min?: CryptoTxMinOrderByAggregateInput
    _sum?: CryptoTxSumOrderByAggregateInput
  }

  export type CryptoTxScalarWhereWithAggregatesInput = {
    AND?: CryptoTxScalarWhereWithAggregatesInput | CryptoTxScalarWhereWithAggregatesInput[]
    OR?: CryptoTxScalarWhereWithAggregatesInput[]
    NOT?: CryptoTxScalarWhereWithAggregatesInput | CryptoTxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoTx"> | string
    walletId?: StringWithAggregatesFilter<"CryptoTx"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"CryptoTx"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"CryptoTx"> | string
    txHash?: StringWithAggregatesFilter<"CryptoTx"> | string
    amount?: DecimalWithAggregatesFilter<"CryptoTx"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusWithAggregatesFilter<"CryptoTx"> | $Enums.PaymentStatus
    blockNumber?: BigIntNullableWithAggregatesFilter<"CryptoTx"> | bigint | number | null
    gasUsed?: BigIntNullableWithAggregatesFilter<"CryptoTx"> | bigint | number | null
    timestamp?: DateTimeWithAggregatesFilter<"CryptoTx"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    isActive?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    startupId?: StringNullableFilter<"Document"> | string | null
    entities?: EntityDocumentListRelationFilter
    Startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    startupId?: SortOrderInput | SortOrder
    entities?: EntityDocumentOrderByRelationAggregateInput
    Startup?: StartupOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    url?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    isActive?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    startupId?: StringNullableFilter<"Document"> | string | null
    entities?: EntityDocumentListRelationFilter
    Startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    startupId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    url?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    isActive?: BoolWithAggregatesFilter<"Document"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    startupId?: StringNullableWithAggregatesFilter<"Document"> | string | null
  }

  export type EntityDocumentWhereInput = {
    AND?: EntityDocumentWhereInput | EntityDocumentWhereInput[]
    OR?: EntityDocumentWhereInput[]
    NOT?: EntityDocumentWhereInput | EntityDocumentWhereInput[]
    id?: StringFilter<"EntityDocument"> | string
    entityType?: EnumEntityTypeFilter<"EntityDocument"> | $Enums.EntityType
    entityId?: StringFilter<"EntityDocument"> | string
    documentId?: StringFilter<"EntityDocument"> | string
    visibility?: StringFilter<"EntityDocument"> | string
    createdAt?: DateTimeFilter<"EntityDocument"> | Date | string
    tokenId?: StringNullableFilter<"EntityDocument"> | string | null
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    Token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }

  export type EntityDocumentOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    documentId?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    document?: DocumentOrderByWithRelationInput
    Token?: TokenOrderByWithRelationInput
  }

  export type EntityDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EntityDocumentWhereInput | EntityDocumentWhereInput[]
    OR?: EntityDocumentWhereInput[]
    NOT?: EntityDocumentWhereInput | EntityDocumentWhereInput[]
    entityType?: EnumEntityTypeFilter<"EntityDocument"> | $Enums.EntityType
    entityId?: StringFilter<"EntityDocument"> | string
    documentId?: StringFilter<"EntityDocument"> | string
    visibility?: StringFilter<"EntityDocument"> | string
    createdAt?: DateTimeFilter<"EntityDocument"> | Date | string
    tokenId?: StringNullableFilter<"EntityDocument"> | string | null
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    Token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }, "id">

  export type EntityDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    documentId?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    _count?: EntityDocumentCountOrderByAggregateInput
    _max?: EntityDocumentMaxOrderByAggregateInput
    _min?: EntityDocumentMinOrderByAggregateInput
  }

  export type EntityDocumentScalarWhereWithAggregatesInput = {
    AND?: EntityDocumentScalarWhereWithAggregatesInput | EntityDocumentScalarWhereWithAggregatesInput[]
    OR?: EntityDocumentScalarWhereWithAggregatesInput[]
    NOT?: EntityDocumentScalarWhereWithAggregatesInput | EntityDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EntityDocument"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"EntityDocument"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"EntityDocument"> | string
    documentId?: StringWithAggregatesFilter<"EntityDocument"> | string
    visibility?: StringWithAggregatesFilter<"EntityDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EntityDocument"> | Date | string
    tokenId?: StringNullableWithAggregatesFilter<"EntityDocument"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    entityType?: EnumEntityTypeFilter<"Comment"> | $Enums.EntityType
    entityId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isEdited?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    startupId?: StringNullableFilter<"Comment"> | string | null
    tokenId?: StringNullableFilter<"Comment"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    body?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    startup?: StartupOrderByWithRelationInput
    token?: TokenOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    userId?: StringFilter<"Comment"> | string
    entityType?: EnumEntityTypeFilter<"Comment"> | $Enums.EntityType
    entityId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isEdited?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    startupId?: StringNullableFilter<"Comment"> | string | null
    tokenId?: StringNullableFilter<"Comment"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    startup?: XOR<StartupNullableScalarRelationFilter, StartupWhereInput> | null
    token?: XOR<TokenNullableScalarRelationFilter, TokenWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    body?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringWithAggregatesFilter<"Comment"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"Comment"> | $Enums.EntityType
    entityId?: StringWithAggregatesFilter<"Comment"> | string
    body?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    isEdited?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    startupId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    tokenId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    startups?: StartupCreateNestedManyWithoutOrganizationInput
    tokens?: TokenCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    startups?: StartupUncheckedCreateNestedManyWithoutOrganizationInput
    tokens?: TokenUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    startups?: StartupUpdateManyWithoutOrganizationNestedInput
    tokens?: TokenUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    startups?: StartupUncheckedUpdateManyWithoutOrganizationNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationsInput
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrganizationMemberUncheckedCreateInput = {
    id?: string
    userId: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyInput = {
    id?: string
    userId: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StartupCreateInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type StartupCreateManyInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
  }

  export type StartupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StartupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenCreateInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenCreateManyInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimulationCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedSimulationsInput
    participants?: UserCreateNestedManyWithoutSimulationsInput
    investments?: SimulationInvestmentCreateNestedManyWithoutSimulationInput
    leaderboard?: SimulationLeaderboardCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserUncheckedCreateNestedManyWithoutSimulationsInput
    investments?: SimulationInvestmentUncheckedCreateNestedManyWithoutSimulationInput
    leaderboard?: SimulationLeaderboardUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedSimulationsNestedInput
    participants?: UserUpdateManyWithoutSimulationsNestedInput
    investments?: SimulationInvestmentUpdateManyWithoutSimulationNestedInput
    leaderboard?: SimulationLeaderboardUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUncheckedUpdateManyWithoutSimulationsNestedInput
    investments?: SimulationInvestmentUncheckedUpdateManyWithoutSimulationNestedInput
    leaderboard?: SimulationLeaderboardUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationCreateManyInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutInvestmentsInput
    user: UserCreateNestedOneWithoutSimulationInvestmentsInput
    startup?: StartupCreateNestedOneWithoutSimulationInvestmentsInput
    token?: TokenCreateNestedOneWithoutSimulationInvestmentsInput
  }

  export type SimulationInvestmentUncheckedCreateInput = {
    id?: string
    simulationId: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutInvestmentsNestedInput
    user?: UserUpdateOneRequiredWithoutSimulationInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutSimulationInvestmentsNestedInput
    token?: TokenUpdateOneWithoutSimulationInvestmentsNestedInput
  }

  export type SimulationInvestmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentCreateManyInput = {
    id?: string
    simulationId: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationLeaderboardCreateInput = {
    id?: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
    simulation: SimulationCreateNestedOneWithoutLeaderboardInput
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type SimulationLeaderboardUncheckedCreateInput = {
    id?: string
    simulationId: string
    userId: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    simulation?: SimulationUpdateOneRequiredWithoutLeaderboardNestedInput
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type SimulationLeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardCreateManyInput = {
    id?: string
    simulationId: string
    userId: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type DealMatchingCreateInput = {
    id?: string
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealMatchingsInput
    startup?: StartupCreateNestedOneWithoutDealMatchingsInput
    token?: TokenCreateNestedOneWithoutDealMatchingsInput
  }

  export type DealMatchingUncheckedCreateInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealMatchingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealMatchingsNestedInput
    startup?: StartupUpdateOneWithoutDealMatchingsNestedInput
    token?: TokenUpdateOneWithoutDealMatchingsNestedInput
  }

  export type DealMatchingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealMatchingCreateManyInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealMatchingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealMatchingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningModuleCreateInput = {
    id?: string
    title: string
    description: string
    content: string
    category: string
    difficulty?: number
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userLearningModules?: UserLearningModuleCreateNestedManyWithoutLearningModuleInput
  }

  export type LearningModuleUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    content: string
    category: string
    difficulty?: number
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userLearningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutLearningModuleInput
  }

  export type LearningModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userLearningModules?: UserLearningModuleUpdateManyWithoutLearningModuleNestedInput
  }

  export type LearningModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userLearningModules?: UserLearningModuleUncheckedUpdateManyWithoutLearningModuleNestedInput
  }

  export type LearningModuleCreateManyInput = {
    id?: string
    title: string
    description: string
    content: string
    category: string
    difficulty?: number
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLearningModuleCreateInput = {
    id?: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningModulesInput
    learningModule: LearningModuleCreateNestedOneWithoutUserLearningModulesInput
  }

  export type UserLearningModuleUncheckedCreateInput = {
    id?: string
    userId: string
    learningModuleId: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
  }

  export type UserLearningModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningModulesNestedInput
    learningModule?: LearningModuleUpdateOneRequiredWithoutUserLearningModulesNestedInput
  }

  export type UserLearningModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningModuleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLearningModuleCreateManyInput = {
    id?: string
    userId: string
    learningModuleId: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
  }

  export type UserLearningModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLearningModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningModuleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProgressCreateInput = {
    id?: string
    totalScore?: number
    currentLevel?: number
    completedSimulations?: number
    successfulInvestments?: number
    averageROI?: Decimal | DecimalJsLike | number | string
    valuationSkill?: number
    dueDiligenceSkill?: number
    riskAssessmentSkill?: number
    lastActivityAt?: Date | string
    user: UserCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    totalScore?: number
    currentLevel?: number
    completedSimulations?: number
    successfulInvestments?: number
    averageROI?: Decimal | DecimalJsLike | number | string
    valuationSkill?: number
    dueDiligenceSkill?: number
    riskAssessmentSkill?: number
    lastActivityAt?: Date | string
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    totalScore?: number
    currentLevel?: number
    completedSimulations?: number
    successfulInvestments?: number
    averageROI?: Decimal | DecimalJsLike | number | string
    valuationSkill?: number
    dueDiligenceSkill?: number
    riskAssessmentSkill?: number
    lastActivityAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestmentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestmentsInput
    startup?: StartupCreateNestedOneWithoutInvestmentsInput
    token?: TokenCreateNestedOneWithoutInvestmentsInput
    vesting?: VestingScheduleCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentUncheckedCreateInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vesting?: VestingScheduleUncheckedCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutInvestmentsNestedInput
    token?: TokenUpdateOneWithoutInvestmentsNestedInput
    vesting?: VestingScheduleUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vesting?: VestingScheduleUncheckedUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentCreateManyInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VestingScheduleCreateInput = {
    id?: string
    cliffDate: Date | string
    unlockDate: Date | string
    percentage: Decimal | DecimalJsLike | number | string
    isUnlocked?: boolean
    createdAt?: Date | string
    investment: InvestmentCreateNestedOneWithoutVestingInput
  }

  export type VestingScheduleUncheckedCreateInput = {
    id?: string
    investmentId: string
    cliffDate: Date | string
    unlockDate: Date | string
    percentage: Decimal | DecimalJsLike | number | string
    isUnlocked?: boolean
    createdAt?: Date | string
  }

  export type VestingScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investment?: InvestmentUpdateOneRequiredWithoutVestingNestedInput
  }

  export type VestingScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investmentId?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VestingScheduleCreateManyInput = {
    id?: string
    investmentId: string
    cliffDate: Date | string
    unlockDate: Date | string
    percentage: Decimal | DecimalJsLike | number | string
    isUnlocked?: boolean
    createdAt?: Date | string
  }

  export type VestingScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VestingScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investmentId?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCRecordCreateInput = {
    id?: string
    status?: $Enums.KYCStatus
    accreditationStatus?: $Enums.AccreditationStatus
    reason?: string | null
    documentUrls?: string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycRecordInput
  }

  export type KYCRecordUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.KYCStatus
    accreditationStatus?: $Enums.AccreditationStatus
    reason?: string | null
    documentUrls?: string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: NullableStringFieldUpdateOperationsInput | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycRecordNestedInput
  }

  export type KYCRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: NullableStringFieldUpdateOperationsInput | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCRecordCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.KYCStatus
    accreditationStatus?: $Enums.AccreditationStatus
    reason?: string | null
    documentUrls?: string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: NullableStringFieldUpdateOperationsInput | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: NullableStringFieldUpdateOperationsInput | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceReportCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Startup?: StartupCreateNestedOneWithoutDueDiligenceReportsInput
    Token?: TokenCreateNestedOneWithoutDueDiligenceReportsInput
  }

  export type DueDiligenceReportUncheckedCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
    tokenId?: string | null
  }

  export type DueDiligenceReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Startup?: StartupUpdateOneWithoutDueDiligenceReportsNestedInput
    Token?: TokenUpdateOneWithoutDueDiligenceReportsNestedInput
  }

  export type DueDiligenceReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DueDiligenceReportCreateManyInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
    tokenId?: string | null
  }

  export type DueDiligenceReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminActivityLogCreateInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    admin: UserCreateNestedOneWithoutAdminLogsInput
  }

  export type AdminActivityLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    targetId?: string | null
    targetType?: $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AdminActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAdminLogsNestedInput
  }

  export type AdminActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogCreateManyInput = {
    id?: string
    adminId: string
    action: string
    targetId?: string | null
    targetType?: $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AdminActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentCreateInput = {
    id?: string
    provider: string
    providerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentIntentsInput
  }

  export type PaymentIntentUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    providerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentIntentsNestedInput
  }

  export type PaymentIntentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentCreateManyInput = {
    id?: string
    userId: string
    provider: string
    providerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletsInput
    txs?: CryptoTxCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
    txs?: CryptoTxUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletsNestedInput
    txs?: CryptoTxUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txs?: CryptoTxUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTxCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    blockNumber?: bigint | number | null
    gasUsed?: bigint | number | null
    timestamp?: Date | string
    wallet: WalletCreateNestedOneWithoutTxsInput
  }

  export type CryptoTxUncheckedCreateInput = {
    id?: string
    walletId: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    blockNumber?: bigint | number | null
    gasUsed?: bigint | number | null
    timestamp?: Date | string
  }

  export type CryptoTxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTxsNestedInput
  }

  export type CryptoTxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTxCreateManyInput = {
    id?: string
    walletId: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    blockNumber?: bigint | number | null
    gasUsed?: bigint | number | null
    timestamp?: Date | string
  }

  export type CryptoTxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    entities?: EntityDocumentCreateNestedManyWithoutDocumentInput
    Startup?: StartupCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    startupId?: string | null
    entities?: EntityDocumentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: EntityDocumentUpdateManyWithoutDocumentNestedInput
    Startup?: StartupUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: EntityDocumentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    startupId?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDocumentCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    visibility?: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutEntitiesInput
    Token?: TokenCreateNestedOneWithoutDocumentsInput
  }

  export type EntityDocumentUncheckedCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    documentId: string
    visibility?: string
    createdAt?: Date | string
    tokenId?: string | null
  }

  export type EntityDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutEntitiesNestedInput
    Token?: TokenUpdateOneWithoutDocumentsNestedInput
  }

  export type EntityDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDocumentCreateManyInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    documentId: string
    visibility?: string
    createdAt?: Date | string
    tokenId?: string | null
  }

  export type EntityDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    startup?: StartupCreateNestedOneWithoutCommentsInput
    token?: TokenCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
    tokenId?: string | null
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    startup?: StartupUpdateOneWithoutCommentsNestedInput
    token?: TokenUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyInput = {
    id?: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
    tokenId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumFounderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FounderStatus | EnumFounderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFounderStatusNullableFilter<$PrismaModel> | $Enums.FounderStatus | null
  }

  export type EnumAccreditationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccreditationStatus | EnumAccreditationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccreditationStatusFilter<$PrismaModel> | $Enums.AccreditationStatus
  }

  export type EnumDealAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DealAccessLevel | EnumDealAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDealAccessLevelFilter<$PrismaModel> | $Enums.DealAccessLevel
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type KYCRecordNullableScalarRelationFilter = {
    is?: KYCRecordWhereInput | null
    isNot?: KYCRecordWhereInput | null
  }

  export type OrganizationMemberListRelationFilter = {
    every?: OrganizationMemberWhereInput
    some?: OrganizationMemberWhereInput
    none?: OrganizationMemberWhereInput
  }

  export type InvestmentListRelationFilter = {
    every?: InvestmentWhereInput
    some?: InvestmentWhereInput
    none?: InvestmentWhereInput
  }

  export type SimulationInvestmentListRelationFilter = {
    every?: SimulationInvestmentWhereInput
    some?: SimulationInvestmentWhereInput
    none?: SimulationInvestmentWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type StartupListRelationFilter = {
    every?: StartupWhereInput
    some?: StartupWhereInput
    none?: StartupWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type AdminActivityLogListRelationFilter = {
    every?: AdminActivityLogWhereInput
    some?: AdminActivityLogWhereInput
    none?: AdminActivityLogWhereInput
  }

  export type PaymentIntentListRelationFilter = {
    every?: PaymentIntentWhereInput
    some?: PaymentIntentWhereInput
    none?: PaymentIntentWhereInput
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type SimulationListRelationFilter = {
    every?: SimulationWhereInput
    some?: SimulationWhereInput
    none?: SimulationWhereInput
  }

  export type DealMatchingListRelationFilter = {
    every?: DealMatchingWhereInput
    some?: DealMatchingWhereInput
    none?: DealMatchingWhereInput
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type UserLearningModuleListRelationFilter = {
    every?: UserLearningModuleWhereInput
    some?: UserLearningModuleWhereInput
    none?: UserLearningModuleWhereInput
  }

  export type SimulationLeaderboardListRelationFilter = {
    every?: SimulationLeaderboardWhereInput
    some?: SimulationLeaderboardWhereInput
    none?: SimulationLeaderboardWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationInvestmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StartupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentIntentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealMatchingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLearningModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationLeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    founderStatus?: SortOrder
    accreditationStatus?: SortOrder
    dealAccessLevel?: SortOrder
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
    bio?: SortOrder
    profilePicture?: SortOrder
    linkedinUrl?: SortOrder
    location?: SortOrder
    investmentPreferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    founderStatus?: SortOrder
    accreditationStatus?: SortOrder
    dealAccessLevel?: SortOrder
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
    bio?: SortOrder
    profilePicture?: SortOrder
    linkedinUrl?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    role?: SortOrder
    founderStatus?: SortOrder
    accreditationStatus?: SortOrder
    dealAccessLevel?: SortOrder
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
    bio?: SortOrder
    profilePicture?: SortOrder
    linkedinUrl?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    totalSimulationScore?: SortOrder
    completedSimulations?: SortOrder
    simulationLevel?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumFounderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FounderStatus | EnumFounderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFounderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.FounderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFounderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumFounderStatusNullableFilter<$PrismaModel>
  }

  export type EnumAccreditationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccreditationStatus | EnumAccreditationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccreditationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccreditationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccreditationStatusFilter<$PrismaModel>
    _max?: NestedEnumAccreditationStatusFilter<$PrismaModel>
  }

  export type EnumDealAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealAccessLevel | EnumDealAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDealAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.DealAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumDealAccessLevelFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountProviderIdAccountIdCompoundUniqueInput = {
    providerId: string
    accountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    idToken?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationIdentifierValueCompoundUniqueInput = {
    identifier: string
    value: string
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrganizationMemberUserIdOrganizationIdCompoundUniqueInput = {
    userId: string
    organizationId: string
  }

  export type OrganizationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumFundingStageFilter<$PrismaModel = never> = {
    equals?: $Enums.FundingStage | EnumFundingStageFieldRefInput<$PrismaModel>
    in?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    not?: NestedEnumFundingStageFilter<$PrismaModel> | $Enums.FundingStage
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type DueDiligenceReportListRelationFilter = {
    every?: DueDiligenceReportWhereInput
    some?: DueDiligenceReportWhereInput
    none?: DueDiligenceReportWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DueDiligenceReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StartupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    stage?: SortOrder
    website?: SortOrder
    pitchDeck?: SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    aiGeneratedMetrics?: SortOrder
    simulationData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founderId?: SortOrder
    organizationId?: SortOrder
  }

  export type StartupAvgOrderByAggregateInput = {
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
  }

  export type StartupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    stage?: SortOrder
    website?: SortOrder
    pitchDeck?: SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founderId?: SortOrder
    organizationId?: SortOrder
  }

  export type StartupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    stage?: SortOrder
    website?: SortOrder
    pitchDeck?: SortOrder
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    founderId?: SortOrder
    organizationId?: SortOrder
  }

  export type StartupSumOrderByAggregateInput = {
    fundingGoal?: SortOrder
    amountRaised?: SortOrder
    valuation?: SortOrder
  }

  export type EnumFundingStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FundingStage | EnumFundingStageFieldRefInput<$PrismaModel>
    in?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    not?: NestedEnumFundingStageWithAggregatesFilter<$PrismaModel> | $Enums.FundingStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFundingStageFilter<$PrismaModel>
    _max?: NestedEnumFundingStageFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumChainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChainNullableFilter<$PrismaModel> | $Enums.Chain | null
  }

  export type EntityDocumentListRelationFilter = {
    every?: EntityDocumentWhereInput
    some?: EntityDocumentWhereInput
    none?: EntityDocumentWhereInput
  }

  export type EntityDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    totalSupply?: SortOrder
    tokenomics?: SortOrder
    whitepaperUrl?: SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    contractAddress?: SortOrder
    chain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    organizationId?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    totalSupply?: SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    totalSupply?: SortOrder
    tokenomics?: SortOrder
    whitepaperUrl?: SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    contractAddress?: SortOrder
    chain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    organizationId?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    totalSupply?: SortOrder
    tokenomics?: SortOrder
    whitepaperUrl?: SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
    isApproved?: SortOrder
    isActive?: SortOrder
    contractAddress?: SortOrder
    chain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    organizationId?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    totalSupply?: SortOrder
    fundingGoal?: SortOrder
    currentPrice?: SortOrder
  }

  export type EnumChainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChainNullableWithAggregatesFilter<$PrismaModel> | $Enums.Chain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumChainNullableFilter<$PrismaModel>
    _max?: NestedEnumChainNullableFilter<$PrismaModel>
  }

  export type EnumSimulationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationType | EnumSimulationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationTypeFilter<$PrismaModel> | $Enums.SimulationType
  }

  export type EnumSimulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusFilter<$PrismaModel> | $Enums.SimulationStatus
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SimulationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxParticipants?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
    scenarioData?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
  }

  export type SimulationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxParticipants?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    maxParticipants?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
    initialBudget?: SortOrder
    difficultyLevel?: SortOrder
  }

  export type EnumSimulationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationType | EnumSimulationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationTypeWithAggregatesFilter<$PrismaModel> | $Enums.SimulationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationTypeFilter<$PrismaModel>
    _max?: NestedEnumSimulationTypeFilter<$PrismaModel>
  }

  export type EnumSimulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationStatusFilter<$PrismaModel>
    _max?: NestedEnumSimulationStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SimulationScalarRelationFilter = {
    is?: SimulationWhereInput
    isNot?: SimulationWhereInput
  }

  export type StartupNullableScalarRelationFilter = {
    is?: StartupWhereInput | null
    isNot?: StartupWhereInput | null
  }

  export type TokenNullableScalarRelationFilter = {
    is?: TokenWhereInput | null
    isNot?: TokenWhereInput | null
  }

  export type SimulationInvestmentSimulationIdUserIdStartupIdCompoundUniqueInput = {
    simulationId: string
    userId: string
    startupId: string
  }

  export type SimulationInvestmentSimulationIdUserIdTokenIdCompoundUniqueInput = {
    simulationId: string
    userId: string
    tokenId: string
  }

  export type SimulationInvestmentCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationInvestmentAvgOrderByAggregateInput = {
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
  }

  export type SimulationInvestmentMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationInvestmentMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SimulationInvestmentSumOrderByAggregateInput = {
    amount?: SortOrder
    ownership?: SortOrder
    currentValue?: SortOrder
    roi?: SortOrder
  }

  export type SimulationLeaderboardSimulationIdUserIdCompoundUniqueInput = {
    simulationId: string
    userId: string
  }

  export type SimulationLeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
  }

  export type SimulationLeaderboardAvgOrderByAggregateInput = {
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
  }

  export type SimulationLeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
  }

  export type SimulationLeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    simulationId?: SortOrder
    userId?: SortOrder
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
  }

  export type SimulationLeaderboardSumOrderByAggregateInput = {
    rank?: SortOrder
    totalReturn?: SortOrder
    roiPercent?: SortOrder
  }

  export type DealMatchingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    matchScore?: SortOrder
    reasoning?: SortOrder
    isRecommended?: SortOrder
    userFeedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMatchingAvgOrderByAggregateInput = {
    matchScore?: SortOrder
  }

  export type DealMatchingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    matchScore?: SortOrder
    reasoning?: SortOrder
    isRecommended?: SortOrder
    userFeedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMatchingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    matchScore?: SortOrder
    reasoning?: SortOrder
    isRecommended?: SortOrder
    userFeedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMatchingSumOrderByAggregateInput = {
    matchScore?: SortOrder
  }

  export type LearningModuleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningModuleAvgOrderByAggregateInput = {
    difficulty?: SortOrder
    order?: SortOrder
  }

  export type LearningModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningModuleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningModuleSumOrderByAggregateInput = {
    difficulty?: SortOrder
    order?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LearningModuleScalarRelationFilter = {
    is?: LearningModuleWhereInput
    isNot?: LearningModuleWhereInput
  }

  export type UserLearningModuleUserIdLearningModuleIdCompoundUniqueInput = {
    userId: string
    learningModuleId: string
  }

  export type UserLearningModuleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningModuleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
  }

  export type UserLearningModuleAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserLearningModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningModuleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
  }

  export type UserLearningModuleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningModuleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
  }

  export type UserLearningModuleSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
    lastActivityAt?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    totalScore?: SortOrder
    currentLevel?: SortOrder
    completedSimulations?: SortOrder
    successfulInvestments?: SortOrder
    averageROI?: SortOrder
    valuationSkill?: SortOrder
    dueDiligenceSkill?: SortOrder
    riskAssessmentSkill?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type VestingScheduleListRelationFilter = {
    every?: VestingScheduleWhereInput
    some?: VestingScheduleWhereInput
    none?: VestingScheduleWhereInput
  }

  export type VestingScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestmentUserIdStartupIdCompoundUniqueInput = {
    userId: string
    startupId: string
  }

  export type InvestmentUserIdTokenIdCompoundUniqueInput = {
    userId: string
    tokenId: string
  }

  export type InvestmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrder
    terms?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestmentAvgOrderByAggregateInput = {
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrder
  }

  export type InvestmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestmentSumOrderByAggregateInput = {
    amount?: SortOrder
    ownership?: SortOrder
    valuation?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type InvestmentScalarRelationFilter = {
    is?: InvestmentWhereInput
    isNot?: InvestmentWhereInput
  }

  export type VestingScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    investmentId?: SortOrder
    cliffDate?: SortOrder
    unlockDate?: SortOrder
    percentage?: SortOrder
    isUnlocked?: SortOrder
    createdAt?: SortOrder
  }

  export type VestingScheduleAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type VestingScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    investmentId?: SortOrder
    cliffDate?: SortOrder
    unlockDate?: SortOrder
    percentage?: SortOrder
    isUnlocked?: SortOrder
    createdAt?: SortOrder
  }

  export type VestingScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    investmentId?: SortOrder
    cliffDate?: SortOrder
    unlockDate?: SortOrder
    percentage?: SortOrder
    isUnlocked?: SortOrder
    createdAt?: SortOrder
  }

  export type VestingScheduleSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type KYCRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    accreditationStatus?: SortOrder
    reason?: SortOrder
    documentUrls?: SortOrder
    verificationData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KYCRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    accreditationStatus?: SortOrder
    reason?: SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KYCRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    accreditationStatus?: SortOrder
    reason?: SortOrder
    documentUrls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type EnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type DueDiligenceReportCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    summary?: SortOrder
    riskScore?: SortOrder
    sentiment?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    technologyScore?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
  }

  export type DueDiligenceReportAvgOrderByAggregateInput = {
    riskScore?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    technologyScore?: SortOrder
  }

  export type DueDiligenceReportMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    summary?: SortOrder
    riskScore?: SortOrder
    sentiment?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    technologyScore?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
  }

  export type DueDiligenceReportMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    summary?: SortOrder
    riskScore?: SortOrder
    sentiment?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    technologyScore?: SortOrder
    aiGenerated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
  }

  export type DueDiligenceReportSumOrderByAggregateInput = {
    riskScore?: SortOrder
    financialScore?: SortOrder
    teamScore?: SortOrder
    marketScore?: SortOrder
    technologyScore?: SortOrder
  }

  export type EnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type EnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type AdminActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentIntentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentIntentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentIntentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumChainFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel>
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    not?: NestedEnumChainFilter<$PrismaModel> | $Enums.Chain
  }

  export type CryptoTxListRelationFilter = {
    every?: CryptoTxWhereInput
    some?: CryptoTxWhereInput
    none?: CryptoTxWhereInput
  }

  export type CryptoTxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletChainAddressCompoundUniqueInput = {
    chain: $Enums.Chain
    address: string
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    nickname?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    nickname?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    nickname?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumChainWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel>
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    not?: NestedEnumChainWithAggregatesFilter<$PrismaModel> | $Enums.Chain
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChainFilter<$PrismaModel>
    _max?: NestedEnumChainFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type WalletScalarRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type CryptoTxCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    txHash?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
    timestamp?: SortOrder
  }

  export type CryptoTxAvgOrderByAggregateInput = {
    amount?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
  }

  export type CryptoTxMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    txHash?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
    timestamp?: SortOrder
  }

  export type CryptoTxMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    txHash?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
    timestamp?: SortOrder
  }

  export type CryptoTxSumOrderByAggregateInput = {
    amount?: SortOrder
    blockNumber?: SortOrder
    gasUsed?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    startupId?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    startupId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    type?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    startupId?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type EntityDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    documentId?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    tokenId?: SortOrder
  }

  export type EntityDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    documentId?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    tokenId?: SortOrder
  }

  export type EntityDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    documentId?: SortOrder
    visibility?: SortOrder
    createdAt?: SortOrder
    tokenId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    body?: SortOrder
    parentId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    body?: SortOrder
    parentId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    body?: SortOrder
    parentId?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    startupId?: SortOrder
    tokenId?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type KYCRecordCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCRecordCreateWithoutUserInput, KYCRecordUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCRecordCreateOrConnectWithoutUserInput
    connect?: KYCRecordWhereUniqueInput
  }

  export type OrganizationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type InvestmentCreateNestedManyWithoutUserInput = {
    create?: XOR<InvestmentCreateWithoutUserInput, InvestmentUncheckedCreateWithoutUserInput> | InvestmentCreateWithoutUserInput[] | InvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutUserInput | InvestmentCreateOrConnectWithoutUserInput[]
    createMany?: InvestmentCreateManyUserInputEnvelope
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
  }

  export type SimulationInvestmentCreateNestedManyWithoutUserInput = {
    create?: XOR<SimulationInvestmentCreateWithoutUserInput, SimulationInvestmentUncheckedCreateWithoutUserInput> | SimulationInvestmentCreateWithoutUserInput[] | SimulationInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutUserInput | SimulationInvestmentCreateOrConnectWithoutUserInput[]
    createMany?: SimulationInvestmentCreateManyUserInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StartupCreateNestedManyWithoutFounderInput = {
    create?: XOR<StartupCreateWithoutFounderInput, StartupUncheckedCreateWithoutFounderInput> | StartupCreateWithoutFounderInput[] | StartupUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutFounderInput | StartupCreateOrConnectWithoutFounderInput[]
    createMany?: StartupCreateManyFounderInputEnvelope
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type AdminActivityLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
  }

  export type PaymentIntentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentIntentCreateWithoutUserInput, PaymentIntentUncheckedCreateWithoutUserInput> | PaymentIntentCreateWithoutUserInput[] | PaymentIntentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutUserInput | PaymentIntentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentIntentCreateManyUserInputEnvelope
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
  }

  export type WalletCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SimulationCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<SimulationCreateWithoutParticipantsInput, SimulationUncheckedCreateWithoutParticipantsInput> | SimulationCreateWithoutParticipantsInput[] | SimulationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutParticipantsInput | SimulationCreateOrConnectWithoutParticipantsInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
  }

  export type SimulationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<SimulationCreateWithoutOwnerInput, SimulationUncheckedCreateWithoutOwnerInput> | SimulationCreateWithoutOwnerInput[] | SimulationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutOwnerInput | SimulationCreateOrConnectWithoutOwnerInput[]
    createMany?: SimulationCreateManyOwnerInputEnvelope
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
  }

  export type DealMatchingCreateNestedManyWithoutUserInput = {
    create?: XOR<DealMatchingCreateWithoutUserInput, DealMatchingUncheckedCreateWithoutUserInput> | DealMatchingCreateWithoutUserInput[] | DealMatchingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutUserInput | DealMatchingCreateOrConnectWithoutUserInput[]
    createMany?: DealMatchingCreateManyUserInputEnvelope
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserLearningModuleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLearningModuleCreateWithoutUserInput, UserLearningModuleUncheckedCreateWithoutUserInput> | UserLearningModuleCreateWithoutUserInput[] | UserLearningModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutUserInput | UserLearningModuleCreateOrConnectWithoutUserInput[]
    createMany?: UserLearningModuleCreateManyUserInputEnvelope
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
  }

  export type SimulationLeaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutUserInput, SimulationLeaderboardUncheckedCreateWithoutUserInput> | SimulationLeaderboardCreateWithoutUserInput[] | SimulationLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutUserInput | SimulationLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: SimulationLeaderboardCreateManyUserInputEnvelope
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type KYCRecordUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCRecordCreateWithoutUserInput, KYCRecordUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCRecordCreateOrConnectWithoutUserInput
    connect?: KYCRecordWhereUniqueInput
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type InvestmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvestmentCreateWithoutUserInput, InvestmentUncheckedCreateWithoutUserInput> | InvestmentCreateWithoutUserInput[] | InvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutUserInput | InvestmentCreateOrConnectWithoutUserInput[]
    createMany?: InvestmentCreateManyUserInputEnvelope
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
  }

  export type SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SimulationInvestmentCreateWithoutUserInput, SimulationInvestmentUncheckedCreateWithoutUserInput> | SimulationInvestmentCreateWithoutUserInput[] | SimulationInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutUserInput | SimulationInvestmentCreateOrConnectWithoutUserInput[]
    createMany?: SimulationInvestmentCreateManyUserInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StartupUncheckedCreateNestedManyWithoutFounderInput = {
    create?: XOR<StartupCreateWithoutFounderInput, StartupUncheckedCreateWithoutFounderInput> | StartupCreateWithoutFounderInput[] | StartupUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutFounderInput | StartupCreateOrConnectWithoutFounderInput[]
    createMany?: StartupCreateManyFounderInputEnvelope
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
  }

  export type PaymentIntentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentIntentCreateWithoutUserInput, PaymentIntentUncheckedCreateWithoutUserInput> | PaymentIntentCreateWithoutUserInput[] | PaymentIntentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutUserInput | PaymentIntentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentIntentCreateManyUserInputEnvelope
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SimulationUncheckedCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<SimulationCreateWithoutParticipantsInput, SimulationUncheckedCreateWithoutParticipantsInput> | SimulationCreateWithoutParticipantsInput[] | SimulationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutParticipantsInput | SimulationCreateOrConnectWithoutParticipantsInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
  }

  export type SimulationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<SimulationCreateWithoutOwnerInput, SimulationUncheckedCreateWithoutOwnerInput> | SimulationCreateWithoutOwnerInput[] | SimulationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutOwnerInput | SimulationCreateOrConnectWithoutOwnerInput[]
    createMany?: SimulationCreateManyOwnerInputEnvelope
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
  }

  export type DealMatchingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DealMatchingCreateWithoutUserInput, DealMatchingUncheckedCreateWithoutUserInput> | DealMatchingCreateWithoutUserInput[] | DealMatchingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutUserInput | DealMatchingCreateOrConnectWithoutUserInput[]
    createMany?: DealMatchingCreateManyUserInputEnvelope
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserLearningModuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLearningModuleCreateWithoutUserInput, UserLearningModuleUncheckedCreateWithoutUserInput> | UserLearningModuleCreateWithoutUserInput[] | UserLearningModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutUserInput | UserLearningModuleCreateOrConnectWithoutUserInput[]
    createMany?: UserLearningModuleCreateManyUserInputEnvelope
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
  }

  export type SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutUserInput, SimulationLeaderboardUncheckedCreateWithoutUserInput> | SimulationLeaderboardCreateWithoutUserInput[] | SimulationLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutUserInput | SimulationLeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: SimulationLeaderboardCreateManyUserInputEnvelope
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableEnumFounderStatusFieldUpdateOperationsInput = {
    set?: $Enums.FounderStatus | null
  }

  export type EnumAccreditationStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccreditationStatus
  }

  export type EnumDealAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.DealAccessLevel
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type KYCRecordUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCRecordCreateWithoutUserInput, KYCRecordUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCRecordCreateOrConnectWithoutUserInput
    upsert?: KYCRecordUpsertWithoutUserInput
    disconnect?: KYCRecordWhereInput | boolean
    delete?: KYCRecordWhereInput | boolean
    connect?: KYCRecordWhereUniqueInput
    update?: XOR<XOR<KYCRecordUpdateToOneWithWhereWithoutUserInput, KYCRecordUpdateWithoutUserInput>, KYCRecordUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type InvestmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvestmentCreateWithoutUserInput, InvestmentUncheckedCreateWithoutUserInput> | InvestmentCreateWithoutUserInput[] | InvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutUserInput | InvestmentCreateOrConnectWithoutUserInput[]
    upsert?: InvestmentUpsertWithWhereUniqueWithoutUserInput | InvestmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvestmentCreateManyUserInputEnvelope
    set?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    disconnect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    delete?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    update?: InvestmentUpdateWithWhereUniqueWithoutUserInput | InvestmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvestmentUpdateManyWithWhereWithoutUserInput | InvestmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
  }

  export type SimulationInvestmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutUserInput, SimulationInvestmentUncheckedCreateWithoutUserInput> | SimulationInvestmentCreateWithoutUserInput[] | SimulationInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutUserInput | SimulationInvestmentCreateOrConnectWithoutUserInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutUserInput | SimulationInvestmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SimulationInvestmentCreateManyUserInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutUserInput | SimulationInvestmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutUserInput | SimulationInvestmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StartupUpdateManyWithoutFounderNestedInput = {
    create?: XOR<StartupCreateWithoutFounderInput, StartupUncheckedCreateWithoutFounderInput> | StartupCreateWithoutFounderInput[] | StartupUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutFounderInput | StartupCreateOrConnectWithoutFounderInput[]
    upsert?: StartupUpsertWithWhereUniqueWithoutFounderInput | StartupUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: StartupCreateManyFounderInputEnvelope
    set?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    disconnect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    delete?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    update?: StartupUpdateWithWhereUniqueWithoutFounderInput | StartupUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: StartupUpdateManyWithWhereWithoutFounderInput | StartupUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: StartupScalarWhereInput | StartupScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutCreatorInput | TokenUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutCreatorInput | TokenUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutCreatorInput | TokenUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type AdminActivityLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput | AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    set?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    disconnect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    delete?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    update?: AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput | AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActivityLogUpdateManyWithWhereWithoutAdminInput | AdminActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
  }

  export type PaymentIntentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentIntentCreateWithoutUserInput, PaymentIntentUncheckedCreateWithoutUserInput> | PaymentIntentCreateWithoutUserInput[] | PaymentIntentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutUserInput | PaymentIntentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentIntentUpsertWithWhereUniqueWithoutUserInput | PaymentIntentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentIntentCreateManyUserInputEnvelope
    set?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    disconnect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    delete?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    update?: PaymentIntentUpdateWithWhereUniqueWithoutUserInput | PaymentIntentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentIntentUpdateManyWithWhereWithoutUserInput | PaymentIntentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
  }

  export type WalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutUserInput | WalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutUserInput | WalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutUserInput | WalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SimulationUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<SimulationCreateWithoutParticipantsInput, SimulationUncheckedCreateWithoutParticipantsInput> | SimulationCreateWithoutParticipantsInput[] | SimulationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutParticipantsInput | SimulationCreateOrConnectWithoutParticipantsInput[]
    upsert?: SimulationUpsertWithWhereUniqueWithoutParticipantsInput | SimulationUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    disconnect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    delete?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    update?: SimulationUpdateWithWhereUniqueWithoutParticipantsInput | SimulationUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: SimulationUpdateManyWithWhereWithoutParticipantsInput | SimulationUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
  }

  export type SimulationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<SimulationCreateWithoutOwnerInput, SimulationUncheckedCreateWithoutOwnerInput> | SimulationCreateWithoutOwnerInput[] | SimulationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutOwnerInput | SimulationCreateOrConnectWithoutOwnerInput[]
    upsert?: SimulationUpsertWithWhereUniqueWithoutOwnerInput | SimulationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: SimulationCreateManyOwnerInputEnvelope
    set?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    disconnect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    delete?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    update?: SimulationUpdateWithWhereUniqueWithoutOwnerInput | SimulationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: SimulationUpdateManyWithWhereWithoutOwnerInput | SimulationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
  }

  export type DealMatchingUpdateManyWithoutUserNestedInput = {
    create?: XOR<DealMatchingCreateWithoutUserInput, DealMatchingUncheckedCreateWithoutUserInput> | DealMatchingCreateWithoutUserInput[] | DealMatchingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutUserInput | DealMatchingCreateOrConnectWithoutUserInput[]
    upsert?: DealMatchingUpsertWithWhereUniqueWithoutUserInput | DealMatchingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DealMatchingCreateManyUserInputEnvelope
    set?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    disconnect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    delete?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    update?: DealMatchingUpdateWithWhereUniqueWithoutUserInput | DealMatchingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DealMatchingUpdateManyWithWhereWithoutUserInput | DealMatchingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserLearningModuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLearningModuleCreateWithoutUserInput, UserLearningModuleUncheckedCreateWithoutUserInput> | UserLearningModuleCreateWithoutUserInput[] | UserLearningModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutUserInput | UserLearningModuleCreateOrConnectWithoutUserInput[]
    upsert?: UserLearningModuleUpsertWithWhereUniqueWithoutUserInput | UserLearningModuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLearningModuleCreateManyUserInputEnvelope
    set?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    disconnect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    delete?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    update?: UserLearningModuleUpdateWithWhereUniqueWithoutUserInput | UserLearningModuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLearningModuleUpdateManyWithWhereWithoutUserInput | UserLearningModuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLearningModuleScalarWhereInput | UserLearningModuleScalarWhereInput[]
  }

  export type SimulationLeaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutUserInput, SimulationLeaderboardUncheckedCreateWithoutUserInput> | SimulationLeaderboardCreateWithoutUserInput[] | SimulationLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutUserInput | SimulationLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: SimulationLeaderboardUpsertWithWhereUniqueWithoutUserInput | SimulationLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SimulationLeaderboardCreateManyUserInputEnvelope
    set?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    disconnect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    delete?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    update?: SimulationLeaderboardUpdateWithWhereUniqueWithoutUserInput | SimulationLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SimulationLeaderboardUpdateManyWithWhereWithoutUserInput | SimulationLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SimulationLeaderboardScalarWhereInput | SimulationLeaderboardScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type KYCRecordUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCRecordCreateWithoutUserInput, KYCRecordUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCRecordCreateOrConnectWithoutUserInput
    upsert?: KYCRecordUpsertWithoutUserInput
    disconnect?: KYCRecordWhereInput | boolean
    delete?: KYCRecordWhereInput | boolean
    connect?: KYCRecordWhereUniqueInput
    update?: XOR<XOR<KYCRecordUpdateToOneWithWhereWithoutUserInput, KYCRecordUpdateWithoutUserInput>, KYCRecordUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type InvestmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvestmentCreateWithoutUserInput, InvestmentUncheckedCreateWithoutUserInput> | InvestmentCreateWithoutUserInput[] | InvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutUserInput | InvestmentCreateOrConnectWithoutUserInput[]
    upsert?: InvestmentUpsertWithWhereUniqueWithoutUserInput | InvestmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvestmentCreateManyUserInputEnvelope
    set?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    disconnect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    delete?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    update?: InvestmentUpdateWithWhereUniqueWithoutUserInput | InvestmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvestmentUpdateManyWithWhereWithoutUserInput | InvestmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutUserInput, SimulationInvestmentUncheckedCreateWithoutUserInput> | SimulationInvestmentCreateWithoutUserInput[] | SimulationInvestmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutUserInput | SimulationInvestmentCreateOrConnectWithoutUserInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutUserInput | SimulationInvestmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SimulationInvestmentCreateManyUserInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutUserInput | SimulationInvestmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutUserInput | SimulationInvestmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StartupUncheckedUpdateManyWithoutFounderNestedInput = {
    create?: XOR<StartupCreateWithoutFounderInput, StartupUncheckedCreateWithoutFounderInput> | StartupCreateWithoutFounderInput[] | StartupUncheckedCreateWithoutFounderInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutFounderInput | StartupCreateOrConnectWithoutFounderInput[]
    upsert?: StartupUpsertWithWhereUniqueWithoutFounderInput | StartupUpsertWithWhereUniqueWithoutFounderInput[]
    createMany?: StartupCreateManyFounderInputEnvelope
    set?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    disconnect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    delete?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    update?: StartupUpdateWithWhereUniqueWithoutFounderInput | StartupUpdateWithWhereUniqueWithoutFounderInput[]
    updateMany?: StartupUpdateManyWithWhereWithoutFounderInput | StartupUpdateManyWithWhereWithoutFounderInput[]
    deleteMany?: StartupScalarWhereInput | StartupScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput> | TokenCreateWithoutCreatorInput[] | TokenUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCreatorInput | TokenCreateOrConnectWithoutCreatorInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutCreatorInput | TokenUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TokenCreateManyCreatorInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutCreatorInput | TokenUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutCreatorInput | TokenUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput | AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    set?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    disconnect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    delete?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    update?: AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput | AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActivityLogUpdateManyWithWhereWithoutAdminInput | AdminActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
  }

  export type PaymentIntentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentIntentCreateWithoutUserInput, PaymentIntentUncheckedCreateWithoutUserInput> | PaymentIntentCreateWithoutUserInput[] | PaymentIntentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentIntentCreateOrConnectWithoutUserInput | PaymentIntentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentIntentUpsertWithWhereUniqueWithoutUserInput | PaymentIntentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentIntentCreateManyUserInputEnvelope
    set?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    disconnect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    delete?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    connect?: PaymentIntentWhereUniqueInput | PaymentIntentWhereUniqueInput[]
    update?: PaymentIntentUpdateWithWhereUniqueWithoutUserInput | PaymentIntentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentIntentUpdateManyWithWhereWithoutUserInput | PaymentIntentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
  }

  export type WalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput> | WalletCreateWithoutUserInput[] | WalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput | WalletCreateOrConnectWithoutUserInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutUserInput | WalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletCreateManyUserInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutUserInput | WalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutUserInput | WalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SimulationUncheckedUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<SimulationCreateWithoutParticipantsInput, SimulationUncheckedCreateWithoutParticipantsInput> | SimulationCreateWithoutParticipantsInput[] | SimulationUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutParticipantsInput | SimulationCreateOrConnectWithoutParticipantsInput[]
    upsert?: SimulationUpsertWithWhereUniqueWithoutParticipantsInput | SimulationUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    disconnect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    delete?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    update?: SimulationUpdateWithWhereUniqueWithoutParticipantsInput | SimulationUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: SimulationUpdateManyWithWhereWithoutParticipantsInput | SimulationUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
  }

  export type SimulationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<SimulationCreateWithoutOwnerInput, SimulationUncheckedCreateWithoutOwnerInput> | SimulationCreateWithoutOwnerInput[] | SimulationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: SimulationCreateOrConnectWithoutOwnerInput | SimulationCreateOrConnectWithoutOwnerInput[]
    upsert?: SimulationUpsertWithWhereUniqueWithoutOwnerInput | SimulationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: SimulationCreateManyOwnerInputEnvelope
    set?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    disconnect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    delete?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    connect?: SimulationWhereUniqueInput | SimulationWhereUniqueInput[]
    update?: SimulationUpdateWithWhereUniqueWithoutOwnerInput | SimulationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: SimulationUpdateManyWithWhereWithoutOwnerInput | SimulationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
  }

  export type DealMatchingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DealMatchingCreateWithoutUserInput, DealMatchingUncheckedCreateWithoutUserInput> | DealMatchingCreateWithoutUserInput[] | DealMatchingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutUserInput | DealMatchingCreateOrConnectWithoutUserInput[]
    upsert?: DealMatchingUpsertWithWhereUniqueWithoutUserInput | DealMatchingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DealMatchingCreateManyUserInputEnvelope
    set?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    disconnect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    delete?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    update?: DealMatchingUpdateWithWhereUniqueWithoutUserInput | DealMatchingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DealMatchingUpdateManyWithWhereWithoutUserInput | DealMatchingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLearningModuleCreateWithoutUserInput, UserLearningModuleUncheckedCreateWithoutUserInput> | UserLearningModuleCreateWithoutUserInput[] | UserLearningModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutUserInput | UserLearningModuleCreateOrConnectWithoutUserInput[]
    upsert?: UserLearningModuleUpsertWithWhereUniqueWithoutUserInput | UserLearningModuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLearningModuleCreateManyUserInputEnvelope
    set?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    disconnect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    delete?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    update?: UserLearningModuleUpdateWithWhereUniqueWithoutUserInput | UserLearningModuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLearningModuleUpdateManyWithWhereWithoutUserInput | UserLearningModuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLearningModuleScalarWhereInput | UserLearningModuleScalarWhereInput[]
  }

  export type SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutUserInput, SimulationLeaderboardUncheckedCreateWithoutUserInput> | SimulationLeaderboardCreateWithoutUserInput[] | SimulationLeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutUserInput | SimulationLeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: SimulationLeaderboardUpsertWithWhereUniqueWithoutUserInput | SimulationLeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SimulationLeaderboardCreateManyUserInputEnvelope
    set?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    disconnect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    delete?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    update?: SimulationLeaderboardUpdateWithWhereUniqueWithoutUserInput | SimulationLeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SimulationLeaderboardUpdateManyWithWhereWithoutUserInput | SimulationLeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SimulationLeaderboardScalarWhereInput | SimulationLeaderboardScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type OrganizationMemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type StartupCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StartupCreateWithoutOrganizationInput, StartupUncheckedCreateWithoutOrganizationInput> | StartupCreateWithoutOrganizationInput[] | StartupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutOrganizationInput | StartupCreateOrConnectWithoutOrganizationInput[]
    createMany?: StartupCreateManyOrganizationInputEnvelope
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TokenCreateWithoutOrganizationInput, TokenUncheckedCreateWithoutOrganizationInput> | TokenCreateWithoutOrganizationInput[] | TokenUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOrganizationInput | TokenCreateOrConnectWithoutOrganizationInput[]
    createMany?: TokenCreateManyOrganizationInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type StartupUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StartupCreateWithoutOrganizationInput, StartupUncheckedCreateWithoutOrganizationInput> | StartupCreateWithoutOrganizationInput[] | StartupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutOrganizationInput | StartupCreateOrConnectWithoutOrganizationInput[]
    createMany?: StartupCreateManyOrganizationInputEnvelope
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TokenCreateWithoutOrganizationInput, TokenUncheckedCreateWithoutOrganizationInput> | TokenCreateWithoutOrganizationInput[] | TokenUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOrganizationInput | TokenCreateOrConnectWithoutOrganizationInput[]
    createMany?: TokenCreateManyOrganizationInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type OrganizationMemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type StartupUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StartupCreateWithoutOrganizationInput, StartupUncheckedCreateWithoutOrganizationInput> | StartupCreateWithoutOrganizationInput[] | StartupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutOrganizationInput | StartupCreateOrConnectWithoutOrganizationInput[]
    upsert?: StartupUpsertWithWhereUniqueWithoutOrganizationInput | StartupUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StartupCreateManyOrganizationInputEnvelope
    set?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    disconnect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    delete?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    update?: StartupUpdateWithWhereUniqueWithoutOrganizationInput | StartupUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StartupUpdateManyWithWhereWithoutOrganizationInput | StartupUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StartupScalarWhereInput | StartupScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TokenCreateWithoutOrganizationInput, TokenUncheckedCreateWithoutOrganizationInput> | TokenCreateWithoutOrganizationInput[] | TokenUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOrganizationInput | TokenCreateOrConnectWithoutOrganizationInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutOrganizationInput | TokenUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TokenCreateManyOrganizationInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutOrganizationInput | TokenUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutOrganizationInput | TokenUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type StartupUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StartupCreateWithoutOrganizationInput, StartupUncheckedCreateWithoutOrganizationInput> | StartupCreateWithoutOrganizationInput[] | StartupUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StartupCreateOrConnectWithoutOrganizationInput | StartupCreateOrConnectWithoutOrganizationInput[]
    upsert?: StartupUpsertWithWhereUniqueWithoutOrganizationInput | StartupUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StartupCreateManyOrganizationInputEnvelope
    set?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    disconnect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    delete?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    connect?: StartupWhereUniqueInput | StartupWhereUniqueInput[]
    update?: StartupUpdateWithWhereUniqueWithoutOrganizationInput | StartupUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StartupUpdateManyWithWhereWithoutOrganizationInput | StartupUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StartupScalarWhereInput | StartupScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TokenCreateWithoutOrganizationInput, TokenUncheckedCreateWithoutOrganizationInput> | TokenCreateWithoutOrganizationInput[] | TokenUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutOrganizationInput | TokenCreateOrConnectWithoutOrganizationInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutOrganizationInput | TokenUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TokenCreateManyOrganizationInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutOrganizationInput | TokenUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutOrganizationInput | TokenUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    upsert?: UserUpsertWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationsInput, UserUpdateWithoutOrganizationsInput>, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserCreateNestedOneWithoutStartupsInput = {
    create?: XOR<UserCreateWithoutStartupsInput, UserUncheckedCreateWithoutStartupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStartupsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutStartupsInput = {
    create?: XOR<OrganizationCreateWithoutStartupsInput, OrganizationUncheckedCreateWithoutStartupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStartupsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type InvestmentCreateNestedManyWithoutStartupInput = {
    create?: XOR<InvestmentCreateWithoutStartupInput, InvestmentUncheckedCreateWithoutStartupInput> | InvestmentCreateWithoutStartupInput[] | InvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutStartupInput | InvestmentCreateOrConnectWithoutStartupInput[]
    createMany?: InvestmentCreateManyStartupInputEnvelope
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
  }

  export type SimulationInvestmentCreateNestedManyWithoutStartupInput = {
    create?: XOR<SimulationInvestmentCreateWithoutStartupInput, SimulationInvestmentUncheckedCreateWithoutStartupInput> | SimulationInvestmentCreateWithoutStartupInput[] | SimulationInvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutStartupInput | SimulationInvestmentCreateOrConnectWithoutStartupInput[]
    createMany?: SimulationInvestmentCreateManyStartupInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type DueDiligenceReportCreateNestedManyWithoutStartupInput = {
    create?: XOR<DueDiligenceReportCreateWithoutStartupInput, DueDiligenceReportUncheckedCreateWithoutStartupInput> | DueDiligenceReportCreateWithoutStartupInput[] | DueDiligenceReportUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutStartupInput | DueDiligenceReportCreateOrConnectWithoutStartupInput[]
    createMany?: DueDiligenceReportCreateManyStartupInputEnvelope
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutStartupInput = {
    create?: XOR<DocumentCreateWithoutStartupInput, DocumentUncheckedCreateWithoutStartupInput> | DocumentCreateWithoutStartupInput[] | DocumentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStartupInput | DocumentCreateOrConnectWithoutStartupInput[]
    createMany?: DocumentCreateManyStartupInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutStartupInput = {
    create?: XOR<CommentCreateWithoutStartupInput, CommentUncheckedCreateWithoutStartupInput> | CommentCreateWithoutStartupInput[] | CommentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStartupInput | CommentCreateOrConnectWithoutStartupInput[]
    createMany?: CommentCreateManyStartupInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DealMatchingCreateNestedManyWithoutStartupInput = {
    create?: XOR<DealMatchingCreateWithoutStartupInput, DealMatchingUncheckedCreateWithoutStartupInput> | DealMatchingCreateWithoutStartupInput[] | DealMatchingUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutStartupInput | DealMatchingCreateOrConnectWithoutStartupInput[]
    createMany?: DealMatchingCreateManyStartupInputEnvelope
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
  }

  export type InvestmentUncheckedCreateNestedManyWithoutStartupInput = {
    create?: XOR<InvestmentCreateWithoutStartupInput, InvestmentUncheckedCreateWithoutStartupInput> | InvestmentCreateWithoutStartupInput[] | InvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutStartupInput | InvestmentCreateOrConnectWithoutStartupInput[]
    createMany?: InvestmentCreateManyStartupInputEnvelope
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
  }

  export type SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput = {
    create?: XOR<SimulationInvestmentCreateWithoutStartupInput, SimulationInvestmentUncheckedCreateWithoutStartupInput> | SimulationInvestmentCreateWithoutStartupInput[] | SimulationInvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutStartupInput | SimulationInvestmentCreateOrConnectWithoutStartupInput[]
    createMany?: SimulationInvestmentCreateManyStartupInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput = {
    create?: XOR<DueDiligenceReportCreateWithoutStartupInput, DueDiligenceReportUncheckedCreateWithoutStartupInput> | DueDiligenceReportCreateWithoutStartupInput[] | DueDiligenceReportUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutStartupInput | DueDiligenceReportCreateOrConnectWithoutStartupInput[]
    createMany?: DueDiligenceReportCreateManyStartupInputEnvelope
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutStartupInput = {
    create?: XOR<DocumentCreateWithoutStartupInput, DocumentUncheckedCreateWithoutStartupInput> | DocumentCreateWithoutStartupInput[] | DocumentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStartupInput | DocumentCreateOrConnectWithoutStartupInput[]
    createMany?: DocumentCreateManyStartupInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutStartupInput = {
    create?: XOR<CommentCreateWithoutStartupInput, CommentUncheckedCreateWithoutStartupInput> | CommentCreateWithoutStartupInput[] | CommentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStartupInput | CommentCreateOrConnectWithoutStartupInput[]
    createMany?: CommentCreateManyStartupInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DealMatchingUncheckedCreateNestedManyWithoutStartupInput = {
    create?: XOR<DealMatchingCreateWithoutStartupInput, DealMatchingUncheckedCreateWithoutStartupInput> | DealMatchingCreateWithoutStartupInput[] | DealMatchingUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutStartupInput | DealMatchingCreateOrConnectWithoutStartupInput[]
    createMany?: DealMatchingCreateManyStartupInputEnvelope
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
  }

  export type EnumFundingStageFieldUpdateOperationsInput = {
    set?: $Enums.FundingStage
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutStartupsNestedInput = {
    create?: XOR<UserCreateWithoutStartupsInput, UserUncheckedCreateWithoutStartupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStartupsInput
    upsert?: UserUpsertWithoutStartupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStartupsInput, UserUpdateWithoutStartupsInput>, UserUncheckedUpdateWithoutStartupsInput>
  }

  export type OrganizationUpdateOneWithoutStartupsNestedInput = {
    create?: XOR<OrganizationCreateWithoutStartupsInput, OrganizationUncheckedCreateWithoutStartupsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutStartupsInput
    upsert?: OrganizationUpsertWithoutStartupsInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutStartupsInput, OrganizationUpdateWithoutStartupsInput>, OrganizationUncheckedUpdateWithoutStartupsInput>
  }

  export type InvestmentUpdateManyWithoutStartupNestedInput = {
    create?: XOR<InvestmentCreateWithoutStartupInput, InvestmentUncheckedCreateWithoutStartupInput> | InvestmentCreateWithoutStartupInput[] | InvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutStartupInput | InvestmentCreateOrConnectWithoutStartupInput[]
    upsert?: InvestmentUpsertWithWhereUniqueWithoutStartupInput | InvestmentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: InvestmentCreateManyStartupInputEnvelope
    set?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    disconnect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    delete?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    update?: InvestmentUpdateWithWhereUniqueWithoutStartupInput | InvestmentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: InvestmentUpdateManyWithWhereWithoutStartupInput | InvestmentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
  }

  export type SimulationInvestmentUpdateManyWithoutStartupNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutStartupInput, SimulationInvestmentUncheckedCreateWithoutStartupInput> | SimulationInvestmentCreateWithoutStartupInput[] | SimulationInvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutStartupInput | SimulationInvestmentCreateOrConnectWithoutStartupInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutStartupInput | SimulationInvestmentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: SimulationInvestmentCreateManyStartupInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutStartupInput | SimulationInvestmentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutStartupInput | SimulationInvestmentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type DueDiligenceReportUpdateManyWithoutStartupNestedInput = {
    create?: XOR<DueDiligenceReportCreateWithoutStartupInput, DueDiligenceReportUncheckedCreateWithoutStartupInput> | DueDiligenceReportCreateWithoutStartupInput[] | DueDiligenceReportUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutStartupInput | DueDiligenceReportCreateOrConnectWithoutStartupInput[]
    upsert?: DueDiligenceReportUpsertWithWhereUniqueWithoutStartupInput | DueDiligenceReportUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: DueDiligenceReportCreateManyStartupInputEnvelope
    set?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    disconnect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    delete?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    update?: DueDiligenceReportUpdateWithWhereUniqueWithoutStartupInput | DueDiligenceReportUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: DueDiligenceReportUpdateManyWithWhereWithoutStartupInput | DueDiligenceReportUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: DueDiligenceReportScalarWhereInput | DueDiligenceReportScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutStartupNestedInput = {
    create?: XOR<DocumentCreateWithoutStartupInput, DocumentUncheckedCreateWithoutStartupInput> | DocumentCreateWithoutStartupInput[] | DocumentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStartupInput | DocumentCreateOrConnectWithoutStartupInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutStartupInput | DocumentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: DocumentCreateManyStartupInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutStartupInput | DocumentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutStartupInput | DocumentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutStartupNestedInput = {
    create?: XOR<CommentCreateWithoutStartupInput, CommentUncheckedCreateWithoutStartupInput> | CommentCreateWithoutStartupInput[] | CommentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStartupInput | CommentCreateOrConnectWithoutStartupInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStartupInput | CommentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: CommentCreateManyStartupInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStartupInput | CommentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStartupInput | CommentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DealMatchingUpdateManyWithoutStartupNestedInput = {
    create?: XOR<DealMatchingCreateWithoutStartupInput, DealMatchingUncheckedCreateWithoutStartupInput> | DealMatchingCreateWithoutStartupInput[] | DealMatchingUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutStartupInput | DealMatchingCreateOrConnectWithoutStartupInput[]
    upsert?: DealMatchingUpsertWithWhereUniqueWithoutStartupInput | DealMatchingUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: DealMatchingCreateManyStartupInputEnvelope
    set?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    disconnect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    delete?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    update?: DealMatchingUpdateWithWhereUniqueWithoutStartupInput | DealMatchingUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: DealMatchingUpdateManyWithWhereWithoutStartupInput | DealMatchingUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
  }

  export type InvestmentUncheckedUpdateManyWithoutStartupNestedInput = {
    create?: XOR<InvestmentCreateWithoutStartupInput, InvestmentUncheckedCreateWithoutStartupInput> | InvestmentCreateWithoutStartupInput[] | InvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutStartupInput | InvestmentCreateOrConnectWithoutStartupInput[]
    upsert?: InvestmentUpsertWithWhereUniqueWithoutStartupInput | InvestmentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: InvestmentCreateManyStartupInputEnvelope
    set?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    disconnect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    delete?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    update?: InvestmentUpdateWithWhereUniqueWithoutStartupInput | InvestmentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: InvestmentUpdateManyWithWhereWithoutStartupInput | InvestmentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutStartupInput, SimulationInvestmentUncheckedCreateWithoutStartupInput> | SimulationInvestmentCreateWithoutStartupInput[] | SimulationInvestmentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutStartupInput | SimulationInvestmentCreateOrConnectWithoutStartupInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutStartupInput | SimulationInvestmentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: SimulationInvestmentCreateManyStartupInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutStartupInput | SimulationInvestmentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutStartupInput | SimulationInvestmentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput = {
    create?: XOR<DueDiligenceReportCreateWithoutStartupInput, DueDiligenceReportUncheckedCreateWithoutStartupInput> | DueDiligenceReportCreateWithoutStartupInput[] | DueDiligenceReportUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutStartupInput | DueDiligenceReportCreateOrConnectWithoutStartupInput[]
    upsert?: DueDiligenceReportUpsertWithWhereUniqueWithoutStartupInput | DueDiligenceReportUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: DueDiligenceReportCreateManyStartupInputEnvelope
    set?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    disconnect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    delete?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    update?: DueDiligenceReportUpdateWithWhereUniqueWithoutStartupInput | DueDiligenceReportUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: DueDiligenceReportUpdateManyWithWhereWithoutStartupInput | DueDiligenceReportUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: DueDiligenceReportScalarWhereInput | DueDiligenceReportScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutStartupNestedInput = {
    create?: XOR<DocumentCreateWithoutStartupInput, DocumentUncheckedCreateWithoutStartupInput> | DocumentCreateWithoutStartupInput[] | DocumentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutStartupInput | DocumentCreateOrConnectWithoutStartupInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutStartupInput | DocumentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: DocumentCreateManyStartupInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutStartupInput | DocumentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutStartupInput | DocumentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutStartupNestedInput = {
    create?: XOR<CommentCreateWithoutStartupInput, CommentUncheckedCreateWithoutStartupInput> | CommentCreateWithoutStartupInput[] | CommentUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutStartupInput | CommentCreateOrConnectWithoutStartupInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutStartupInput | CommentUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: CommentCreateManyStartupInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutStartupInput | CommentUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutStartupInput | CommentUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DealMatchingUncheckedUpdateManyWithoutStartupNestedInput = {
    create?: XOR<DealMatchingCreateWithoutStartupInput, DealMatchingUncheckedCreateWithoutStartupInput> | DealMatchingCreateWithoutStartupInput[] | DealMatchingUncheckedCreateWithoutStartupInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutStartupInput | DealMatchingCreateOrConnectWithoutStartupInput[]
    upsert?: DealMatchingUpsertWithWhereUniqueWithoutStartupInput | DealMatchingUpsertWithWhereUniqueWithoutStartupInput[]
    createMany?: DealMatchingCreateManyStartupInputEnvelope
    set?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    disconnect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    delete?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    update?: DealMatchingUpdateWithWhereUniqueWithoutStartupInput | DealMatchingUpdateWithWhereUniqueWithoutStartupInput[]
    updateMany?: DealMatchingUpdateManyWithWhereWithoutStartupInput | DealMatchingUpdateManyWithWhereWithoutStartupInput[]
    deleteMany?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutTokensInput = {
    create?: XOR<OrganizationCreateWithoutTokensInput, OrganizationUncheckedCreateWithoutTokensInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTokensInput
    connect?: OrganizationWhereUniqueInput
  }

  export type InvestmentCreateNestedManyWithoutTokenInput = {
    create?: XOR<InvestmentCreateWithoutTokenInput, InvestmentUncheckedCreateWithoutTokenInput> | InvestmentCreateWithoutTokenInput[] | InvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutTokenInput | InvestmentCreateOrConnectWithoutTokenInput[]
    createMany?: InvestmentCreateManyTokenInputEnvelope
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
  }

  export type SimulationInvestmentCreateNestedManyWithoutTokenInput = {
    create?: XOR<SimulationInvestmentCreateWithoutTokenInput, SimulationInvestmentUncheckedCreateWithoutTokenInput> | SimulationInvestmentCreateWithoutTokenInput[] | SimulationInvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutTokenInput | SimulationInvestmentCreateOrConnectWithoutTokenInput[]
    createMany?: SimulationInvestmentCreateManyTokenInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type DueDiligenceReportCreateNestedManyWithoutTokenInput = {
    create?: XOR<DueDiligenceReportCreateWithoutTokenInput, DueDiligenceReportUncheckedCreateWithoutTokenInput> | DueDiligenceReportCreateWithoutTokenInput[] | DueDiligenceReportUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutTokenInput | DueDiligenceReportCreateOrConnectWithoutTokenInput[]
    createMany?: DueDiligenceReportCreateManyTokenInputEnvelope
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
  }

  export type EntityDocumentCreateNestedManyWithoutTokenInput = {
    create?: XOR<EntityDocumentCreateWithoutTokenInput, EntityDocumentUncheckedCreateWithoutTokenInput> | EntityDocumentCreateWithoutTokenInput[] | EntityDocumentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutTokenInput | EntityDocumentCreateOrConnectWithoutTokenInput[]
    createMany?: EntityDocumentCreateManyTokenInputEnvelope
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutTokenInput = {
    create?: XOR<CommentCreateWithoutTokenInput, CommentUncheckedCreateWithoutTokenInput> | CommentCreateWithoutTokenInput[] | CommentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTokenInput | CommentCreateOrConnectWithoutTokenInput[]
    createMany?: CommentCreateManyTokenInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DealMatchingCreateNestedManyWithoutTokenInput = {
    create?: XOR<DealMatchingCreateWithoutTokenInput, DealMatchingUncheckedCreateWithoutTokenInput> | DealMatchingCreateWithoutTokenInput[] | DealMatchingUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutTokenInput | DealMatchingCreateOrConnectWithoutTokenInput[]
    createMany?: DealMatchingCreateManyTokenInputEnvelope
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
  }

  export type InvestmentUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<InvestmentCreateWithoutTokenInput, InvestmentUncheckedCreateWithoutTokenInput> | InvestmentCreateWithoutTokenInput[] | InvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutTokenInput | InvestmentCreateOrConnectWithoutTokenInput[]
    createMany?: InvestmentCreateManyTokenInputEnvelope
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
  }

  export type SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<SimulationInvestmentCreateWithoutTokenInput, SimulationInvestmentUncheckedCreateWithoutTokenInput> | SimulationInvestmentCreateWithoutTokenInput[] | SimulationInvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutTokenInput | SimulationInvestmentCreateOrConnectWithoutTokenInput[]
    createMany?: SimulationInvestmentCreateManyTokenInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<DueDiligenceReportCreateWithoutTokenInput, DueDiligenceReportUncheckedCreateWithoutTokenInput> | DueDiligenceReportCreateWithoutTokenInput[] | DueDiligenceReportUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutTokenInput | DueDiligenceReportCreateOrConnectWithoutTokenInput[]
    createMany?: DueDiligenceReportCreateManyTokenInputEnvelope
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
  }

  export type EntityDocumentUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<EntityDocumentCreateWithoutTokenInput, EntityDocumentUncheckedCreateWithoutTokenInput> | EntityDocumentCreateWithoutTokenInput[] | EntityDocumentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutTokenInput | EntityDocumentCreateOrConnectWithoutTokenInput[]
    createMany?: EntityDocumentCreateManyTokenInputEnvelope
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<CommentCreateWithoutTokenInput, CommentUncheckedCreateWithoutTokenInput> | CommentCreateWithoutTokenInput[] | CommentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTokenInput | CommentCreateOrConnectWithoutTokenInput[]
    createMany?: CommentCreateManyTokenInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DealMatchingUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<DealMatchingCreateWithoutTokenInput, DealMatchingUncheckedCreateWithoutTokenInput> | DealMatchingCreateWithoutTokenInput[] | DealMatchingUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutTokenInput | DealMatchingCreateOrConnectWithoutTokenInput[]
    createMany?: DealMatchingCreateManyTokenInputEnvelope
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
  }

  export type NullableEnumChainFieldUpdateOperationsInput = {
    set?: $Enums.Chain | null
  }

  export type UserUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensInput, UserUpdateWithoutTokensInput>, UserUncheckedUpdateWithoutTokensInput>
  }

  export type OrganizationUpdateOneWithoutTokensNestedInput = {
    create?: XOR<OrganizationCreateWithoutTokensInput, OrganizationUncheckedCreateWithoutTokensInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTokensInput
    upsert?: OrganizationUpsertWithoutTokensInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTokensInput, OrganizationUpdateWithoutTokensInput>, OrganizationUncheckedUpdateWithoutTokensInput>
  }

  export type InvestmentUpdateManyWithoutTokenNestedInput = {
    create?: XOR<InvestmentCreateWithoutTokenInput, InvestmentUncheckedCreateWithoutTokenInput> | InvestmentCreateWithoutTokenInput[] | InvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutTokenInput | InvestmentCreateOrConnectWithoutTokenInput[]
    upsert?: InvestmentUpsertWithWhereUniqueWithoutTokenInput | InvestmentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: InvestmentCreateManyTokenInputEnvelope
    set?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    disconnect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    delete?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    update?: InvestmentUpdateWithWhereUniqueWithoutTokenInput | InvestmentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: InvestmentUpdateManyWithWhereWithoutTokenInput | InvestmentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
  }

  export type SimulationInvestmentUpdateManyWithoutTokenNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutTokenInput, SimulationInvestmentUncheckedCreateWithoutTokenInput> | SimulationInvestmentCreateWithoutTokenInput[] | SimulationInvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutTokenInput | SimulationInvestmentCreateOrConnectWithoutTokenInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutTokenInput | SimulationInvestmentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: SimulationInvestmentCreateManyTokenInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutTokenInput | SimulationInvestmentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutTokenInput | SimulationInvestmentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type DueDiligenceReportUpdateManyWithoutTokenNestedInput = {
    create?: XOR<DueDiligenceReportCreateWithoutTokenInput, DueDiligenceReportUncheckedCreateWithoutTokenInput> | DueDiligenceReportCreateWithoutTokenInput[] | DueDiligenceReportUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutTokenInput | DueDiligenceReportCreateOrConnectWithoutTokenInput[]
    upsert?: DueDiligenceReportUpsertWithWhereUniqueWithoutTokenInput | DueDiligenceReportUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: DueDiligenceReportCreateManyTokenInputEnvelope
    set?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    disconnect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    delete?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    update?: DueDiligenceReportUpdateWithWhereUniqueWithoutTokenInput | DueDiligenceReportUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: DueDiligenceReportUpdateManyWithWhereWithoutTokenInput | DueDiligenceReportUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: DueDiligenceReportScalarWhereInput | DueDiligenceReportScalarWhereInput[]
  }

  export type EntityDocumentUpdateManyWithoutTokenNestedInput = {
    create?: XOR<EntityDocumentCreateWithoutTokenInput, EntityDocumentUncheckedCreateWithoutTokenInput> | EntityDocumentCreateWithoutTokenInput[] | EntityDocumentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutTokenInput | EntityDocumentCreateOrConnectWithoutTokenInput[]
    upsert?: EntityDocumentUpsertWithWhereUniqueWithoutTokenInput | EntityDocumentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: EntityDocumentCreateManyTokenInputEnvelope
    set?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    disconnect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    delete?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    update?: EntityDocumentUpdateWithWhereUniqueWithoutTokenInput | EntityDocumentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: EntityDocumentUpdateManyWithWhereWithoutTokenInput | EntityDocumentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: EntityDocumentScalarWhereInput | EntityDocumentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutTokenNestedInput = {
    create?: XOR<CommentCreateWithoutTokenInput, CommentUncheckedCreateWithoutTokenInput> | CommentCreateWithoutTokenInput[] | CommentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTokenInput | CommentCreateOrConnectWithoutTokenInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTokenInput | CommentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: CommentCreateManyTokenInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTokenInput | CommentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTokenInput | CommentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DealMatchingUpdateManyWithoutTokenNestedInput = {
    create?: XOR<DealMatchingCreateWithoutTokenInput, DealMatchingUncheckedCreateWithoutTokenInput> | DealMatchingCreateWithoutTokenInput[] | DealMatchingUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutTokenInput | DealMatchingCreateOrConnectWithoutTokenInput[]
    upsert?: DealMatchingUpsertWithWhereUniqueWithoutTokenInput | DealMatchingUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: DealMatchingCreateManyTokenInputEnvelope
    set?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    disconnect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    delete?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    update?: DealMatchingUpdateWithWhereUniqueWithoutTokenInput | DealMatchingUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: DealMatchingUpdateManyWithWhereWithoutTokenInput | DealMatchingUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
  }

  export type InvestmentUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<InvestmentCreateWithoutTokenInput, InvestmentUncheckedCreateWithoutTokenInput> | InvestmentCreateWithoutTokenInput[] | InvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: InvestmentCreateOrConnectWithoutTokenInput | InvestmentCreateOrConnectWithoutTokenInput[]
    upsert?: InvestmentUpsertWithWhereUniqueWithoutTokenInput | InvestmentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: InvestmentCreateManyTokenInputEnvelope
    set?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    disconnect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    delete?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    connect?: InvestmentWhereUniqueInput | InvestmentWhereUniqueInput[]
    update?: InvestmentUpdateWithWhereUniqueWithoutTokenInput | InvestmentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: InvestmentUpdateManyWithWhereWithoutTokenInput | InvestmentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutTokenInput, SimulationInvestmentUncheckedCreateWithoutTokenInput> | SimulationInvestmentCreateWithoutTokenInput[] | SimulationInvestmentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutTokenInput | SimulationInvestmentCreateOrConnectWithoutTokenInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutTokenInput | SimulationInvestmentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: SimulationInvestmentCreateManyTokenInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutTokenInput | SimulationInvestmentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutTokenInput | SimulationInvestmentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<DueDiligenceReportCreateWithoutTokenInput, DueDiligenceReportUncheckedCreateWithoutTokenInput> | DueDiligenceReportCreateWithoutTokenInput[] | DueDiligenceReportUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DueDiligenceReportCreateOrConnectWithoutTokenInput | DueDiligenceReportCreateOrConnectWithoutTokenInput[]
    upsert?: DueDiligenceReportUpsertWithWhereUniqueWithoutTokenInput | DueDiligenceReportUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: DueDiligenceReportCreateManyTokenInputEnvelope
    set?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    disconnect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    delete?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    connect?: DueDiligenceReportWhereUniqueInput | DueDiligenceReportWhereUniqueInput[]
    update?: DueDiligenceReportUpdateWithWhereUniqueWithoutTokenInput | DueDiligenceReportUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: DueDiligenceReportUpdateManyWithWhereWithoutTokenInput | DueDiligenceReportUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: DueDiligenceReportScalarWhereInput | DueDiligenceReportScalarWhereInput[]
  }

  export type EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<EntityDocumentCreateWithoutTokenInput, EntityDocumentUncheckedCreateWithoutTokenInput> | EntityDocumentCreateWithoutTokenInput[] | EntityDocumentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutTokenInput | EntityDocumentCreateOrConnectWithoutTokenInput[]
    upsert?: EntityDocumentUpsertWithWhereUniqueWithoutTokenInput | EntityDocumentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: EntityDocumentCreateManyTokenInputEnvelope
    set?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    disconnect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    delete?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    update?: EntityDocumentUpdateWithWhereUniqueWithoutTokenInput | EntityDocumentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: EntityDocumentUpdateManyWithWhereWithoutTokenInput | EntityDocumentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: EntityDocumentScalarWhereInput | EntityDocumentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<CommentCreateWithoutTokenInput, CommentUncheckedCreateWithoutTokenInput> | CommentCreateWithoutTokenInput[] | CommentUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutTokenInput | CommentCreateOrConnectWithoutTokenInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutTokenInput | CommentUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: CommentCreateManyTokenInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutTokenInput | CommentUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutTokenInput | CommentUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DealMatchingUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<DealMatchingCreateWithoutTokenInput, DealMatchingUncheckedCreateWithoutTokenInput> | DealMatchingCreateWithoutTokenInput[] | DealMatchingUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: DealMatchingCreateOrConnectWithoutTokenInput | DealMatchingCreateOrConnectWithoutTokenInput[]
    upsert?: DealMatchingUpsertWithWhereUniqueWithoutTokenInput | DealMatchingUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: DealMatchingCreateManyTokenInputEnvelope
    set?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    disconnect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    delete?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    connect?: DealMatchingWhereUniqueInput | DealMatchingWhereUniqueInput[]
    update?: DealMatchingUpdateWithWhereUniqueWithoutTokenInput | DealMatchingUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: DealMatchingUpdateManyWithWhereWithoutTokenInput | DealMatchingUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnedSimulationsInput = {
    create?: XOR<UserCreateWithoutOwnedSimulationsInput, UserUncheckedCreateWithoutOwnedSimulationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedSimulationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSimulationsInput = {
    create?: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput> | UserCreateWithoutSimulationsInput[] | UserUncheckedCreateWithoutSimulationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSimulationsInput | UserCreateOrConnectWithoutSimulationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SimulationInvestmentCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationInvestmentCreateWithoutSimulationInput, SimulationInvestmentUncheckedCreateWithoutSimulationInput> | SimulationInvestmentCreateWithoutSimulationInput[] | SimulationInvestmentUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutSimulationInput | SimulationInvestmentCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationInvestmentCreateManySimulationInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type SimulationLeaderboardCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutSimulationInput, SimulationLeaderboardUncheckedCreateWithoutSimulationInput> | SimulationLeaderboardCreateWithoutSimulationInput[] | SimulationLeaderboardUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutSimulationInput | SimulationLeaderboardCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationLeaderboardCreateManySimulationInputEnvelope
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutSimulationsInput = {
    create?: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput> | UserCreateWithoutSimulationsInput[] | UserUncheckedCreateWithoutSimulationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSimulationsInput | UserCreateOrConnectWithoutSimulationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SimulationInvestmentUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationInvestmentCreateWithoutSimulationInput, SimulationInvestmentUncheckedCreateWithoutSimulationInput> | SimulationInvestmentCreateWithoutSimulationInput[] | SimulationInvestmentUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutSimulationInput | SimulationInvestmentCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationInvestmentCreateManySimulationInputEnvelope
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
  }

  export type SimulationLeaderboardUncheckedCreateNestedManyWithoutSimulationInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutSimulationInput, SimulationLeaderboardUncheckedCreateWithoutSimulationInput> | SimulationLeaderboardCreateWithoutSimulationInput[] | SimulationLeaderboardUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutSimulationInput | SimulationLeaderboardCreateOrConnectWithoutSimulationInput[]
    createMany?: SimulationLeaderboardCreateManySimulationInputEnvelope
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
  }

  export type EnumSimulationTypeFieldUpdateOperationsInput = {
    set?: $Enums.SimulationType
  }

  export type EnumSimulationStatusFieldUpdateOperationsInput = {
    set?: $Enums.SimulationStatus
  }

  export type UserUpdateOneRequiredWithoutOwnedSimulationsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedSimulationsInput, UserUncheckedCreateWithoutOwnedSimulationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedSimulationsInput
    upsert?: UserUpsertWithoutOwnedSimulationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedSimulationsInput, UserUpdateWithoutOwnedSimulationsInput>, UserUncheckedUpdateWithoutOwnedSimulationsInput>
  }

  export type UserUpdateManyWithoutSimulationsNestedInput = {
    create?: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput> | UserCreateWithoutSimulationsInput[] | UserUncheckedCreateWithoutSimulationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSimulationsInput | UserCreateOrConnectWithoutSimulationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSimulationsInput | UserUpsertWithWhereUniqueWithoutSimulationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSimulationsInput | UserUpdateWithWhereUniqueWithoutSimulationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSimulationsInput | UserUpdateManyWithWhereWithoutSimulationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SimulationInvestmentUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutSimulationInput, SimulationInvestmentUncheckedCreateWithoutSimulationInput> | SimulationInvestmentCreateWithoutSimulationInput[] | SimulationInvestmentUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutSimulationInput | SimulationInvestmentCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutSimulationInput | SimulationInvestmentUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationInvestmentCreateManySimulationInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutSimulationInput | SimulationInvestmentUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutSimulationInput | SimulationInvestmentUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type SimulationLeaderboardUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutSimulationInput, SimulationLeaderboardUncheckedCreateWithoutSimulationInput> | SimulationLeaderboardCreateWithoutSimulationInput[] | SimulationLeaderboardUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutSimulationInput | SimulationLeaderboardCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationLeaderboardUpsertWithWhereUniqueWithoutSimulationInput | SimulationLeaderboardUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationLeaderboardCreateManySimulationInputEnvelope
    set?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    disconnect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    delete?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    update?: SimulationLeaderboardUpdateWithWhereUniqueWithoutSimulationInput | SimulationLeaderboardUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationLeaderboardUpdateManyWithWhereWithoutSimulationInput | SimulationLeaderboardUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationLeaderboardScalarWhereInput | SimulationLeaderboardScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutSimulationsNestedInput = {
    create?: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput> | UserCreateWithoutSimulationsInput[] | UserUncheckedCreateWithoutSimulationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSimulationsInput | UserCreateOrConnectWithoutSimulationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSimulationsInput | UserUpsertWithWhereUniqueWithoutSimulationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSimulationsInput | UserUpdateWithWhereUniqueWithoutSimulationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSimulationsInput | UserUpdateManyWithWhereWithoutSimulationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationInvestmentCreateWithoutSimulationInput, SimulationInvestmentUncheckedCreateWithoutSimulationInput> | SimulationInvestmentCreateWithoutSimulationInput[] | SimulationInvestmentUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationInvestmentCreateOrConnectWithoutSimulationInput | SimulationInvestmentCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationInvestmentUpsertWithWhereUniqueWithoutSimulationInput | SimulationInvestmentUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationInvestmentCreateManySimulationInputEnvelope
    set?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    disconnect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    delete?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    connect?: SimulationInvestmentWhereUniqueInput | SimulationInvestmentWhereUniqueInput[]
    update?: SimulationInvestmentUpdateWithWhereUniqueWithoutSimulationInput | SimulationInvestmentUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationInvestmentUpdateManyWithWhereWithoutSimulationInput | SimulationInvestmentUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
  }

  export type SimulationLeaderboardUncheckedUpdateManyWithoutSimulationNestedInput = {
    create?: XOR<SimulationLeaderboardCreateWithoutSimulationInput, SimulationLeaderboardUncheckedCreateWithoutSimulationInput> | SimulationLeaderboardCreateWithoutSimulationInput[] | SimulationLeaderboardUncheckedCreateWithoutSimulationInput[]
    connectOrCreate?: SimulationLeaderboardCreateOrConnectWithoutSimulationInput | SimulationLeaderboardCreateOrConnectWithoutSimulationInput[]
    upsert?: SimulationLeaderboardUpsertWithWhereUniqueWithoutSimulationInput | SimulationLeaderboardUpsertWithWhereUniqueWithoutSimulationInput[]
    createMany?: SimulationLeaderboardCreateManySimulationInputEnvelope
    set?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    disconnect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    delete?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    connect?: SimulationLeaderboardWhereUniqueInput | SimulationLeaderboardWhereUniqueInput[]
    update?: SimulationLeaderboardUpdateWithWhereUniqueWithoutSimulationInput | SimulationLeaderboardUpdateWithWhereUniqueWithoutSimulationInput[]
    updateMany?: SimulationLeaderboardUpdateManyWithWhereWithoutSimulationInput | SimulationLeaderboardUpdateManyWithWhereWithoutSimulationInput[]
    deleteMany?: SimulationLeaderboardScalarWhereInput | SimulationLeaderboardScalarWhereInput[]
  }

  export type SimulationCreateNestedOneWithoutInvestmentsInput = {
    create?: XOR<SimulationCreateWithoutInvestmentsInput, SimulationUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutInvestmentsInput
    connect?: SimulationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSimulationInvestmentsInput = {
    create?: XOR<UserCreateWithoutSimulationInvestmentsInput, UserUncheckedCreateWithoutSimulationInvestmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSimulationInvestmentsInput
    connect?: UserWhereUniqueInput
  }

  export type StartupCreateNestedOneWithoutSimulationInvestmentsInput = {
    create?: XOR<StartupCreateWithoutSimulationInvestmentsInput, StartupUncheckedCreateWithoutSimulationInvestmentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutSimulationInvestmentsInput
    connect?: StartupWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutSimulationInvestmentsInput = {
    create?: XOR<TokenCreateWithoutSimulationInvestmentsInput, TokenUncheckedCreateWithoutSimulationInvestmentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutSimulationInvestmentsInput
    connect?: TokenWhereUniqueInput
  }

  export type SimulationUpdateOneRequiredWithoutInvestmentsNestedInput = {
    create?: XOR<SimulationCreateWithoutInvestmentsInput, SimulationUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutInvestmentsInput
    upsert?: SimulationUpsertWithoutInvestmentsInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutInvestmentsInput, SimulationUpdateWithoutInvestmentsInput>, SimulationUncheckedUpdateWithoutInvestmentsInput>
  }

  export type UserUpdateOneRequiredWithoutSimulationInvestmentsNestedInput = {
    create?: XOR<UserCreateWithoutSimulationInvestmentsInput, UserUncheckedCreateWithoutSimulationInvestmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSimulationInvestmentsInput
    upsert?: UserUpsertWithoutSimulationInvestmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSimulationInvestmentsInput, UserUpdateWithoutSimulationInvestmentsInput>, UserUncheckedUpdateWithoutSimulationInvestmentsInput>
  }

  export type StartupUpdateOneWithoutSimulationInvestmentsNestedInput = {
    create?: XOR<StartupCreateWithoutSimulationInvestmentsInput, StartupUncheckedCreateWithoutSimulationInvestmentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutSimulationInvestmentsInput
    upsert?: StartupUpsertWithoutSimulationInvestmentsInput
    disconnect?: StartupWhereInput | boolean
    delete?: StartupWhereInput | boolean
    connect?: StartupWhereUniqueInput
    update?: XOR<XOR<StartupUpdateToOneWithWhereWithoutSimulationInvestmentsInput, StartupUpdateWithoutSimulationInvestmentsInput>, StartupUncheckedUpdateWithoutSimulationInvestmentsInput>
  }

  export type TokenUpdateOneWithoutSimulationInvestmentsNestedInput = {
    create?: XOR<TokenCreateWithoutSimulationInvestmentsInput, TokenUncheckedCreateWithoutSimulationInvestmentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutSimulationInvestmentsInput
    upsert?: TokenUpsertWithoutSimulationInvestmentsInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutSimulationInvestmentsInput, TokenUpdateWithoutSimulationInvestmentsInput>, TokenUncheckedUpdateWithoutSimulationInvestmentsInput>
  }

  export type SimulationCreateNestedOneWithoutLeaderboardInput = {
    create?: XOR<SimulationCreateWithoutLeaderboardInput, SimulationUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutLeaderboardInput
    connect?: SimulationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type SimulationUpdateOneRequiredWithoutLeaderboardNestedInput = {
    create?: XOR<SimulationCreateWithoutLeaderboardInput, SimulationUncheckedCreateWithoutLeaderboardInput>
    connectOrCreate?: SimulationCreateOrConnectWithoutLeaderboardInput
    upsert?: SimulationUpsertWithoutLeaderboardInput
    connect?: SimulationWhereUniqueInput
    update?: XOR<XOR<SimulationUpdateToOneWithWhereWithoutLeaderboardInput, SimulationUpdateWithoutLeaderboardInput>, SimulationUncheckedUpdateWithoutLeaderboardInput>
  }

  export type UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: UserUpsertWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput, UserUpdateWithoutLeaderboardEntriesInput>, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserCreateNestedOneWithoutDealMatchingsInput = {
    create?: XOR<UserCreateWithoutDealMatchingsInput, UserUncheckedCreateWithoutDealMatchingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealMatchingsInput
    connect?: UserWhereUniqueInput
  }

  export type StartupCreateNestedOneWithoutDealMatchingsInput = {
    create?: XOR<StartupCreateWithoutDealMatchingsInput, StartupUncheckedCreateWithoutDealMatchingsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutDealMatchingsInput
    connect?: StartupWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutDealMatchingsInput = {
    create?: XOR<TokenCreateWithoutDealMatchingsInput, TokenUncheckedCreateWithoutDealMatchingsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDealMatchingsInput
    connect?: TokenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDealMatchingsNestedInput = {
    create?: XOR<UserCreateWithoutDealMatchingsInput, UserUncheckedCreateWithoutDealMatchingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealMatchingsInput
    upsert?: UserUpsertWithoutDealMatchingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDealMatchingsInput, UserUpdateWithoutDealMatchingsInput>, UserUncheckedUpdateWithoutDealMatchingsInput>
  }

  export type StartupUpdateOneWithoutDealMatchingsNestedInput = {
    create?: XOR<StartupCreateWithoutDealMatchingsInput, StartupUncheckedCreateWithoutDealMatchingsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutDealMatchingsInput
    upsert?: StartupUpsertWithoutDealMatchingsInput
    disconnect?: StartupWhereInput | boolean
    delete?: StartupWhereInput | boolean
    connect?: StartupWhereUniqueInput
    update?: XOR<XOR<StartupUpdateToOneWithWhereWithoutDealMatchingsInput, StartupUpdateWithoutDealMatchingsInput>, StartupUncheckedUpdateWithoutDealMatchingsInput>
  }

  export type TokenUpdateOneWithoutDealMatchingsNestedInput = {
    create?: XOR<TokenCreateWithoutDealMatchingsInput, TokenUncheckedCreateWithoutDealMatchingsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDealMatchingsInput
    upsert?: TokenUpsertWithoutDealMatchingsInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDealMatchingsInput, TokenUpdateWithoutDealMatchingsInput>, TokenUncheckedUpdateWithoutDealMatchingsInput>
  }

  export type UserLearningModuleCreateNestedManyWithoutLearningModuleInput = {
    create?: XOR<UserLearningModuleCreateWithoutLearningModuleInput, UserLearningModuleUncheckedCreateWithoutLearningModuleInput> | UserLearningModuleCreateWithoutLearningModuleInput[] | UserLearningModuleUncheckedCreateWithoutLearningModuleInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutLearningModuleInput | UserLearningModuleCreateOrConnectWithoutLearningModuleInput[]
    createMany?: UserLearningModuleCreateManyLearningModuleInputEnvelope
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
  }

  export type UserLearningModuleUncheckedCreateNestedManyWithoutLearningModuleInput = {
    create?: XOR<UserLearningModuleCreateWithoutLearningModuleInput, UserLearningModuleUncheckedCreateWithoutLearningModuleInput> | UserLearningModuleCreateWithoutLearningModuleInput[] | UserLearningModuleUncheckedCreateWithoutLearningModuleInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutLearningModuleInput | UserLearningModuleCreateOrConnectWithoutLearningModuleInput[]
    createMany?: UserLearningModuleCreateManyLearningModuleInputEnvelope
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
  }

  export type UserLearningModuleUpdateManyWithoutLearningModuleNestedInput = {
    create?: XOR<UserLearningModuleCreateWithoutLearningModuleInput, UserLearningModuleUncheckedCreateWithoutLearningModuleInput> | UserLearningModuleCreateWithoutLearningModuleInput[] | UserLearningModuleUncheckedCreateWithoutLearningModuleInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutLearningModuleInput | UserLearningModuleCreateOrConnectWithoutLearningModuleInput[]
    upsert?: UserLearningModuleUpsertWithWhereUniqueWithoutLearningModuleInput | UserLearningModuleUpsertWithWhereUniqueWithoutLearningModuleInput[]
    createMany?: UserLearningModuleCreateManyLearningModuleInputEnvelope
    set?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    disconnect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    delete?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    update?: UserLearningModuleUpdateWithWhereUniqueWithoutLearningModuleInput | UserLearningModuleUpdateWithWhereUniqueWithoutLearningModuleInput[]
    updateMany?: UserLearningModuleUpdateManyWithWhereWithoutLearningModuleInput | UserLearningModuleUpdateManyWithWhereWithoutLearningModuleInput[]
    deleteMany?: UserLearningModuleScalarWhereInput | UserLearningModuleScalarWhereInput[]
  }

  export type UserLearningModuleUncheckedUpdateManyWithoutLearningModuleNestedInput = {
    create?: XOR<UserLearningModuleCreateWithoutLearningModuleInput, UserLearningModuleUncheckedCreateWithoutLearningModuleInput> | UserLearningModuleCreateWithoutLearningModuleInput[] | UserLearningModuleUncheckedCreateWithoutLearningModuleInput[]
    connectOrCreate?: UserLearningModuleCreateOrConnectWithoutLearningModuleInput | UserLearningModuleCreateOrConnectWithoutLearningModuleInput[]
    upsert?: UserLearningModuleUpsertWithWhereUniqueWithoutLearningModuleInput | UserLearningModuleUpsertWithWhereUniqueWithoutLearningModuleInput[]
    createMany?: UserLearningModuleCreateManyLearningModuleInputEnvelope
    set?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    disconnect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    delete?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    connect?: UserLearningModuleWhereUniqueInput | UserLearningModuleWhereUniqueInput[]
    update?: UserLearningModuleUpdateWithWhereUniqueWithoutLearningModuleInput | UserLearningModuleUpdateWithWhereUniqueWithoutLearningModuleInput[]
    updateMany?: UserLearningModuleUpdateManyWithWhereWithoutLearningModuleInput | UserLearningModuleUpdateManyWithWhereWithoutLearningModuleInput[]
    deleteMany?: UserLearningModuleScalarWhereInput | UserLearningModuleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLearningModulesInput = {
    create?: XOR<UserCreateWithoutLearningModulesInput, UserUncheckedCreateWithoutLearningModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningModulesInput
    connect?: UserWhereUniqueInput
  }

  export type LearningModuleCreateNestedOneWithoutUserLearningModulesInput = {
    create?: XOR<LearningModuleCreateWithoutUserLearningModulesInput, LearningModuleUncheckedCreateWithoutUserLearningModulesInput>
    connectOrCreate?: LearningModuleCreateOrConnectWithoutUserLearningModulesInput
    connect?: LearningModuleWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLearningModulesNestedInput = {
    create?: XOR<UserCreateWithoutLearningModulesInput, UserUncheckedCreateWithoutLearningModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLearningModulesInput
    upsert?: UserUpsertWithoutLearningModulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLearningModulesInput, UserUpdateWithoutLearningModulesInput>, UserUncheckedUpdateWithoutLearningModulesInput>
  }

  export type LearningModuleUpdateOneRequiredWithoutUserLearningModulesNestedInput = {
    create?: XOR<LearningModuleCreateWithoutUserLearningModulesInput, LearningModuleUncheckedCreateWithoutUserLearningModulesInput>
    connectOrCreate?: LearningModuleCreateOrConnectWithoutUserLearningModulesInput
    upsert?: LearningModuleUpsertWithoutUserLearningModulesInput
    connect?: LearningModuleWhereUniqueInput
    update?: XOR<XOR<LearningModuleUpdateToOneWithWhereWithoutUserLearningModulesInput, LearningModuleUpdateWithoutUserLearningModulesInput>, LearningModuleUncheckedUpdateWithoutUserLearningModulesInput>
  }

  export type UserCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProgressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserProgressInput
    upsert?: UserUpsertWithoutUserProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserProgressInput, UserUpdateWithoutUserProgressInput>, UserUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserCreateNestedOneWithoutInvestmentsInput = {
    create?: XOR<UserCreateWithoutInvestmentsInput, UserUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestmentsInput
    connect?: UserWhereUniqueInput
  }

  export type StartupCreateNestedOneWithoutInvestmentsInput = {
    create?: XOR<StartupCreateWithoutInvestmentsInput, StartupUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutInvestmentsInput
    connect?: StartupWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutInvestmentsInput = {
    create?: XOR<TokenCreateWithoutInvestmentsInput, TokenUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutInvestmentsInput
    connect?: TokenWhereUniqueInput
  }

  export type VestingScheduleCreateNestedManyWithoutInvestmentInput = {
    create?: XOR<VestingScheduleCreateWithoutInvestmentInput, VestingScheduleUncheckedCreateWithoutInvestmentInput> | VestingScheduleCreateWithoutInvestmentInput[] | VestingScheduleUncheckedCreateWithoutInvestmentInput[]
    connectOrCreate?: VestingScheduleCreateOrConnectWithoutInvestmentInput | VestingScheduleCreateOrConnectWithoutInvestmentInput[]
    createMany?: VestingScheduleCreateManyInvestmentInputEnvelope
    connect?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
  }

  export type VestingScheduleUncheckedCreateNestedManyWithoutInvestmentInput = {
    create?: XOR<VestingScheduleCreateWithoutInvestmentInput, VestingScheduleUncheckedCreateWithoutInvestmentInput> | VestingScheduleCreateWithoutInvestmentInput[] | VestingScheduleUncheckedCreateWithoutInvestmentInput[]
    connectOrCreate?: VestingScheduleCreateOrConnectWithoutInvestmentInput | VestingScheduleCreateOrConnectWithoutInvestmentInput[]
    createMany?: VestingScheduleCreateManyInvestmentInputEnvelope
    connect?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutInvestmentsNestedInput = {
    create?: XOR<UserCreateWithoutInvestmentsInput, UserUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestmentsInput
    upsert?: UserUpsertWithoutInvestmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestmentsInput, UserUpdateWithoutInvestmentsInput>, UserUncheckedUpdateWithoutInvestmentsInput>
  }

  export type StartupUpdateOneWithoutInvestmentsNestedInput = {
    create?: XOR<StartupCreateWithoutInvestmentsInput, StartupUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutInvestmentsInput
    upsert?: StartupUpsertWithoutInvestmentsInput
    disconnect?: StartupWhereInput | boolean
    delete?: StartupWhereInput | boolean
    connect?: StartupWhereUniqueInput
    update?: XOR<XOR<StartupUpdateToOneWithWhereWithoutInvestmentsInput, StartupUpdateWithoutInvestmentsInput>, StartupUncheckedUpdateWithoutInvestmentsInput>
  }

  export type TokenUpdateOneWithoutInvestmentsNestedInput = {
    create?: XOR<TokenCreateWithoutInvestmentsInput, TokenUncheckedCreateWithoutInvestmentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutInvestmentsInput
    upsert?: TokenUpsertWithoutInvestmentsInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutInvestmentsInput, TokenUpdateWithoutInvestmentsInput>, TokenUncheckedUpdateWithoutInvestmentsInput>
  }

  export type VestingScheduleUpdateManyWithoutInvestmentNestedInput = {
    create?: XOR<VestingScheduleCreateWithoutInvestmentInput, VestingScheduleUncheckedCreateWithoutInvestmentInput> | VestingScheduleCreateWithoutInvestmentInput[] | VestingScheduleUncheckedCreateWithoutInvestmentInput[]
    connectOrCreate?: VestingScheduleCreateOrConnectWithoutInvestmentInput | VestingScheduleCreateOrConnectWithoutInvestmentInput[]
    upsert?: VestingScheduleUpsertWithWhereUniqueWithoutInvestmentInput | VestingScheduleUpsertWithWhereUniqueWithoutInvestmentInput[]
    createMany?: VestingScheduleCreateManyInvestmentInputEnvelope
    set?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    disconnect?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    delete?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    connect?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    update?: VestingScheduleUpdateWithWhereUniqueWithoutInvestmentInput | VestingScheduleUpdateWithWhereUniqueWithoutInvestmentInput[]
    updateMany?: VestingScheduleUpdateManyWithWhereWithoutInvestmentInput | VestingScheduleUpdateManyWithWhereWithoutInvestmentInput[]
    deleteMany?: VestingScheduleScalarWhereInput | VestingScheduleScalarWhereInput[]
  }

  export type VestingScheduleUncheckedUpdateManyWithoutInvestmentNestedInput = {
    create?: XOR<VestingScheduleCreateWithoutInvestmentInput, VestingScheduleUncheckedCreateWithoutInvestmentInput> | VestingScheduleCreateWithoutInvestmentInput[] | VestingScheduleUncheckedCreateWithoutInvestmentInput[]
    connectOrCreate?: VestingScheduleCreateOrConnectWithoutInvestmentInput | VestingScheduleCreateOrConnectWithoutInvestmentInput[]
    upsert?: VestingScheduleUpsertWithWhereUniqueWithoutInvestmentInput | VestingScheduleUpsertWithWhereUniqueWithoutInvestmentInput[]
    createMany?: VestingScheduleCreateManyInvestmentInputEnvelope
    set?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    disconnect?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    delete?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    connect?: VestingScheduleWhereUniqueInput | VestingScheduleWhereUniqueInput[]
    update?: VestingScheduleUpdateWithWhereUniqueWithoutInvestmentInput | VestingScheduleUpdateWithWhereUniqueWithoutInvestmentInput[]
    updateMany?: VestingScheduleUpdateManyWithWhereWithoutInvestmentInput | VestingScheduleUpdateManyWithWhereWithoutInvestmentInput[]
    deleteMany?: VestingScheduleScalarWhereInput | VestingScheduleScalarWhereInput[]
  }

  export type InvestmentCreateNestedOneWithoutVestingInput = {
    create?: XOR<InvestmentCreateWithoutVestingInput, InvestmentUncheckedCreateWithoutVestingInput>
    connectOrCreate?: InvestmentCreateOrConnectWithoutVestingInput
    connect?: InvestmentWhereUniqueInput
  }

  export type InvestmentUpdateOneRequiredWithoutVestingNestedInput = {
    create?: XOR<InvestmentCreateWithoutVestingInput, InvestmentUncheckedCreateWithoutVestingInput>
    connectOrCreate?: InvestmentCreateOrConnectWithoutVestingInput
    upsert?: InvestmentUpsertWithoutVestingInput
    connect?: InvestmentWhereUniqueInput
    update?: XOR<XOR<InvestmentUpdateToOneWithWhereWithoutVestingInput, InvestmentUpdateWithoutVestingInput>, InvestmentUncheckedUpdateWithoutVestingInput>
  }

  export type UserCreateNestedOneWithoutKycRecordInput = {
    create?: XOR<UserCreateWithoutKycRecordInput, UserUncheckedCreateWithoutKycRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycRecordInput
    connect?: UserWhereUniqueInput
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type UserUpdateOneRequiredWithoutKycRecordNestedInput = {
    create?: XOR<UserCreateWithoutKycRecordInput, UserUncheckedCreateWithoutKycRecordInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycRecordInput
    upsert?: UserUpsertWithoutKycRecordInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycRecordInput, UserUpdateWithoutKycRecordInput>, UserUncheckedUpdateWithoutKycRecordInput>
  }

  export type StartupCreateNestedOneWithoutDueDiligenceReportsInput = {
    create?: XOR<StartupCreateWithoutDueDiligenceReportsInput, StartupUncheckedCreateWithoutDueDiligenceReportsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutDueDiligenceReportsInput
    connect?: StartupWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutDueDiligenceReportsInput = {
    create?: XOR<TokenCreateWithoutDueDiligenceReportsInput, TokenUncheckedCreateWithoutDueDiligenceReportsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDueDiligenceReportsInput
    connect?: TokenWhereUniqueInput
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType
  }

  export type StartupUpdateOneWithoutDueDiligenceReportsNestedInput = {
    create?: XOR<StartupCreateWithoutDueDiligenceReportsInput, StartupUncheckedCreateWithoutDueDiligenceReportsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutDueDiligenceReportsInput
    upsert?: StartupUpsertWithoutDueDiligenceReportsInput
    disconnect?: StartupWhereInput | boolean
    delete?: StartupWhereInput | boolean
    connect?: StartupWhereUniqueInput
    update?: XOR<XOR<StartupUpdateToOneWithWhereWithoutDueDiligenceReportsInput, StartupUpdateWithoutDueDiligenceReportsInput>, StartupUncheckedUpdateWithoutDueDiligenceReportsInput>
  }

  export type TokenUpdateOneWithoutDueDiligenceReportsNestedInput = {
    create?: XOR<TokenCreateWithoutDueDiligenceReportsInput, TokenUncheckedCreateWithoutDueDiligenceReportsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDueDiligenceReportsInput
    upsert?: TokenUpsertWithoutDueDiligenceReportsInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDueDiligenceReportsInput, TokenUpdateWithoutDueDiligenceReportsInput>, TokenUncheckedUpdateWithoutDueDiligenceReportsInput>
  }

  export type UserCreateNestedOneWithoutAdminLogsInput = {
    create?: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminLogsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType | null
  }

  export type UserUpdateOneRequiredWithoutAdminLogsNestedInput = {
    create?: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminLogsInput
    upsert?: UserUpsertWithoutAdminLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminLogsInput, UserUpdateWithoutAdminLogsInput>, UserUncheckedUpdateWithoutAdminLogsInput>
  }

  export type UserCreateNestedOneWithoutPaymentIntentsInput = {
    create?: XOR<UserCreateWithoutPaymentIntentsInput, UserUncheckedCreateWithoutPaymentIntentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentIntentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneRequiredWithoutPaymentIntentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentIntentsInput, UserUncheckedCreateWithoutPaymentIntentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentIntentsInput
    upsert?: UserUpsertWithoutPaymentIntentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentIntentsInput, UserUpdateWithoutPaymentIntentsInput>, UserUncheckedUpdateWithoutPaymentIntentsInput>
  }

  export type UserCreateNestedOneWithoutWalletsInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoTxCreateNestedManyWithoutWalletInput = {
    create?: XOR<CryptoTxCreateWithoutWalletInput, CryptoTxUncheckedCreateWithoutWalletInput> | CryptoTxCreateWithoutWalletInput[] | CryptoTxUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTxCreateOrConnectWithoutWalletInput | CryptoTxCreateOrConnectWithoutWalletInput[]
    createMany?: CryptoTxCreateManyWalletInputEnvelope
    connect?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
  }

  export type CryptoTxUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<CryptoTxCreateWithoutWalletInput, CryptoTxUncheckedCreateWithoutWalletInput> | CryptoTxCreateWithoutWalletInput[] | CryptoTxUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTxCreateOrConnectWithoutWalletInput | CryptoTxCreateOrConnectWithoutWalletInput[]
    createMany?: CryptoTxCreateManyWalletInputEnvelope
    connect?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
  }

  export type EnumChainFieldUpdateOperationsInput = {
    set?: $Enums.Chain
  }

  export type UserUpdateOneRequiredWithoutWalletsNestedInput = {
    create?: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletsInput
    upsert?: UserUpsertWithoutWalletsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletsInput, UserUpdateWithoutWalletsInput>, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type CryptoTxUpdateManyWithoutWalletNestedInput = {
    create?: XOR<CryptoTxCreateWithoutWalletInput, CryptoTxUncheckedCreateWithoutWalletInput> | CryptoTxCreateWithoutWalletInput[] | CryptoTxUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTxCreateOrConnectWithoutWalletInput | CryptoTxCreateOrConnectWithoutWalletInput[]
    upsert?: CryptoTxUpsertWithWhereUniqueWithoutWalletInput | CryptoTxUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: CryptoTxCreateManyWalletInputEnvelope
    set?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    disconnect?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    delete?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    connect?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    update?: CryptoTxUpdateWithWhereUniqueWithoutWalletInput | CryptoTxUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: CryptoTxUpdateManyWithWhereWithoutWalletInput | CryptoTxUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: CryptoTxScalarWhereInput | CryptoTxScalarWhereInput[]
  }

  export type CryptoTxUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<CryptoTxCreateWithoutWalletInput, CryptoTxUncheckedCreateWithoutWalletInput> | CryptoTxCreateWithoutWalletInput[] | CryptoTxUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: CryptoTxCreateOrConnectWithoutWalletInput | CryptoTxCreateOrConnectWithoutWalletInput[]
    upsert?: CryptoTxUpsertWithWhereUniqueWithoutWalletInput | CryptoTxUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: CryptoTxCreateManyWalletInputEnvelope
    set?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    disconnect?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    delete?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    connect?: CryptoTxWhereUniqueInput | CryptoTxWhereUniqueInput[]
    update?: CryptoTxUpdateWithWhereUniqueWithoutWalletInput | CryptoTxUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: CryptoTxUpdateManyWithWhereWithoutWalletInput | CryptoTxUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: CryptoTxScalarWhereInput | CryptoTxScalarWhereInput[]
  }

  export type WalletCreateNestedOneWithoutTxsInput = {
    create?: XOR<WalletCreateWithoutTxsInput, WalletUncheckedCreateWithoutTxsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTxsInput
    connect?: WalletWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type WalletUpdateOneRequiredWithoutTxsNestedInput = {
    create?: XOR<WalletCreateWithoutTxsInput, WalletUncheckedCreateWithoutTxsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTxsInput
    upsert?: WalletUpsertWithoutTxsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTxsInput, WalletUpdateWithoutTxsInput>, WalletUncheckedUpdateWithoutTxsInput>
  }

  export type EntityDocumentCreateNestedManyWithoutDocumentInput = {
    create?: XOR<EntityDocumentCreateWithoutDocumentInput, EntityDocumentUncheckedCreateWithoutDocumentInput> | EntityDocumentCreateWithoutDocumentInput[] | EntityDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutDocumentInput | EntityDocumentCreateOrConnectWithoutDocumentInput[]
    createMany?: EntityDocumentCreateManyDocumentInputEnvelope
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
  }

  export type StartupCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<StartupCreateWithoutDocumentsInput, StartupUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutDocumentsInput
    connect?: StartupWhereUniqueInput
  }

  export type EntityDocumentUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<EntityDocumentCreateWithoutDocumentInput, EntityDocumentUncheckedCreateWithoutDocumentInput> | EntityDocumentCreateWithoutDocumentInput[] | EntityDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutDocumentInput | EntityDocumentCreateOrConnectWithoutDocumentInput[]
    createMany?: EntityDocumentCreateManyDocumentInputEnvelope
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EntityDocumentUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<EntityDocumentCreateWithoutDocumentInput, EntityDocumentUncheckedCreateWithoutDocumentInput> | EntityDocumentCreateWithoutDocumentInput[] | EntityDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutDocumentInput | EntityDocumentCreateOrConnectWithoutDocumentInput[]
    upsert?: EntityDocumentUpsertWithWhereUniqueWithoutDocumentInput | EntityDocumentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: EntityDocumentCreateManyDocumentInputEnvelope
    set?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    disconnect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    delete?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    update?: EntityDocumentUpdateWithWhereUniqueWithoutDocumentInput | EntityDocumentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: EntityDocumentUpdateManyWithWhereWithoutDocumentInput | EntityDocumentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: EntityDocumentScalarWhereInput | EntityDocumentScalarWhereInput[]
  }

  export type StartupUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<StartupCreateWithoutDocumentsInput, StartupUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutDocumentsInput
    upsert?: StartupUpsertWithoutDocumentsInput
    disconnect?: StartupWhereInput | boolean
    delete?: StartupWhereInput | boolean
    connect?: StartupWhereUniqueInput
    update?: XOR<XOR<StartupUpdateToOneWithWhereWithoutDocumentsInput, StartupUpdateWithoutDocumentsInput>, StartupUncheckedUpdateWithoutDocumentsInput>
  }

  export type EntityDocumentUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<EntityDocumentCreateWithoutDocumentInput, EntityDocumentUncheckedCreateWithoutDocumentInput> | EntityDocumentCreateWithoutDocumentInput[] | EntityDocumentUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: EntityDocumentCreateOrConnectWithoutDocumentInput | EntityDocumentCreateOrConnectWithoutDocumentInput[]
    upsert?: EntityDocumentUpsertWithWhereUniqueWithoutDocumentInput | EntityDocumentUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: EntityDocumentCreateManyDocumentInputEnvelope
    set?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    disconnect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    delete?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    connect?: EntityDocumentWhereUniqueInput | EntityDocumentWhereUniqueInput[]
    update?: EntityDocumentUpdateWithWhereUniqueWithoutDocumentInput | EntityDocumentUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: EntityDocumentUpdateManyWithWhereWithoutDocumentInput | EntityDocumentUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: EntityDocumentScalarWhereInput | EntityDocumentScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutEntitiesInput = {
    create?: XOR<DocumentCreateWithoutEntitiesInput, DocumentUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutEntitiesInput
    connect?: DocumentWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TokenCreateWithoutDocumentsInput, TokenUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDocumentsInput
    connect?: TokenWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutEntitiesNestedInput = {
    create?: XOR<DocumentCreateWithoutEntitiesInput, DocumentUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutEntitiesInput
    upsert?: DocumentUpsertWithoutEntitiesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutEntitiesInput, DocumentUpdateWithoutEntitiesInput>, DocumentUncheckedUpdateWithoutEntitiesInput>
  }

  export type TokenUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<TokenCreateWithoutDocumentsInput, TokenUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutDocumentsInput
    upsert?: TokenUpsertWithoutDocumentsInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutDocumentsInput, TokenUpdateWithoutDocumentsInput>, TokenUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type StartupCreateNestedOneWithoutCommentsInput = {
    create?: XOR<StartupCreateWithoutCommentsInput, StartupUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutCommentsInput
    connect?: StartupWhereUniqueInput
  }

  export type TokenCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TokenCreateWithoutCommentsInput, TokenUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutCommentsInput
    connect?: TokenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type StartupUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<StartupCreateWithoutCommentsInput, StartupUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: StartupCreateOrConnectWithoutCommentsInput
    upsert?: StartupUpsertWithoutCommentsInput
    disconnect?: StartupWhereInput | boolean
    delete?: StartupWhereInput | boolean
    connect?: StartupWhereUniqueInput
    update?: XOR<XOR<StartupUpdateToOneWithWhereWithoutCommentsInput, StartupUpdateWithoutCommentsInput>, StartupUncheckedUpdateWithoutCommentsInput>
  }

  export type TokenUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<TokenCreateWithoutCommentsInput, TokenUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutCommentsInput
    upsert?: TokenUpsertWithoutCommentsInput
    disconnect?: TokenWhereInput | boolean
    delete?: TokenWhereInput | boolean
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutCommentsInput, TokenUpdateWithoutCommentsInput>, TokenUncheckedUpdateWithoutCommentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumFounderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FounderStatus | EnumFounderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFounderStatusNullableFilter<$PrismaModel> | $Enums.FounderStatus | null
  }

  export type NestedEnumAccreditationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccreditationStatus | EnumAccreditationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccreditationStatusFilter<$PrismaModel> | $Enums.AccreditationStatus
  }

  export type NestedEnumDealAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DealAccessLevel | EnumDealAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDealAccessLevelFilter<$PrismaModel> | $Enums.DealAccessLevel
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumFounderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FounderStatus | EnumFounderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FounderStatus[] | ListEnumFounderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFounderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.FounderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFounderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumFounderStatusNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAccreditationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccreditationStatus | EnumAccreditationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccreditationStatus[] | ListEnumAccreditationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccreditationStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccreditationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccreditationStatusFilter<$PrismaModel>
    _max?: NestedEnumAccreditationStatusFilter<$PrismaModel>
  }

  export type NestedEnumDealAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealAccessLevel | EnumDealAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealAccessLevel[] | ListEnumDealAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDealAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.DealAccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumDealAccessLevelFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFundingStageFilter<$PrismaModel = never> = {
    equals?: $Enums.FundingStage | EnumFundingStageFieldRefInput<$PrismaModel>
    in?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    not?: NestedEnumFundingStageFilter<$PrismaModel> | $Enums.FundingStage
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumFundingStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FundingStage | EnumFundingStageFieldRefInput<$PrismaModel>
    in?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.FundingStage[] | ListEnumFundingStageFieldRefInput<$PrismaModel>
    not?: NestedEnumFundingStageWithAggregatesFilter<$PrismaModel> | $Enums.FundingStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFundingStageFilter<$PrismaModel>
    _max?: NestedEnumFundingStageFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumChainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChainNullableFilter<$PrismaModel> | $Enums.Chain | null
  }

  export type NestedEnumChainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumChainNullableWithAggregatesFilter<$PrismaModel> | $Enums.Chain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumChainNullableFilter<$PrismaModel>
    _max?: NestedEnumChainNullableFilter<$PrismaModel>
  }

  export type NestedEnumSimulationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationType | EnumSimulationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationTypeFilter<$PrismaModel> | $Enums.SimulationType
  }

  export type NestedEnumSimulationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusFilter<$PrismaModel> | $Enums.SimulationStatus
  }

  export type NestedEnumSimulationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationType | EnumSimulationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationType[] | ListEnumSimulationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationTypeWithAggregatesFilter<$PrismaModel> | $Enums.SimulationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationTypeFilter<$PrismaModel>
    _max?: NestedEnumSimulationTypeFilter<$PrismaModel>
  }

  export type NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SimulationStatus | EnumSimulationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SimulationStatus[] | ListEnumSimulationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSimulationStatusWithAggregatesFilter<$PrismaModel> | $Enums.SimulationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSimulationStatusFilter<$PrismaModel>
    _max?: NestedEnumSimulationStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableFilter<$PrismaModel> | $Enums.EntityType | null
  }

  export type NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEntityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.EntityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumChainFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel>
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    not?: NestedEnumChainFilter<$PrismaModel> | $Enums.Chain
  }

  export type NestedEnumChainWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Chain | EnumChainFieldRefInput<$PrismaModel>
    in?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    notIn?: $Enums.Chain[] | ListEnumChainFieldRefInput<$PrismaModel>
    not?: NestedEnumChainWithAggregatesFilter<$PrismaModel> | $Enums.Chain
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChainFilter<$PrismaModel>
    _max?: NestedEnumChainFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KYCRecordCreateWithoutUserInput = {
    id?: string
    status?: $Enums.KYCStatus
    accreditationStatus?: $Enums.AccreditationStatus
    reason?: string | null
    documentUrls?: string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCRecordUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.KYCStatus
    accreditationStatus?: $Enums.AccreditationStatus
    reason?: string | null
    documentUrls?: string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCRecordCreateOrConnectWithoutUserInput = {
    where: KYCRecordWhereUniqueInput
    create: XOR<KYCRecordCreateWithoutUserInput, KYCRecordUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrganizationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberCreateManyUserInputEnvelope = {
    data: OrganizationMemberCreateManyUserInput | OrganizationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvestmentCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    startup?: StartupCreateNestedOneWithoutInvestmentsInput
    token?: TokenCreateNestedOneWithoutInvestmentsInput
    vesting?: VestingScheduleCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentUncheckedCreateWithoutUserInput = {
    id?: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vesting?: VestingScheduleUncheckedCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentCreateOrConnectWithoutUserInput = {
    where: InvestmentWhereUniqueInput
    create: XOR<InvestmentCreateWithoutUserInput, InvestmentUncheckedCreateWithoutUserInput>
  }

  export type InvestmentCreateManyUserInputEnvelope = {
    data: InvestmentCreateManyUserInput | InvestmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SimulationInvestmentCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutInvestmentsInput
    startup?: StartupCreateNestedOneWithoutSimulationInvestmentsInput
    token?: TokenCreateNestedOneWithoutSimulationInvestmentsInput
  }

  export type SimulationInvestmentUncheckedCreateWithoutUserInput = {
    id?: string
    simulationId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateOrConnectWithoutUserInput = {
    where: SimulationInvestmentWhereUniqueInput
    create: XOR<SimulationInvestmentCreateWithoutUserInput, SimulationInvestmentUncheckedCreateWithoutUserInput>
  }

  export type SimulationInvestmentCreateManyUserInputEnvelope = {
    data: SimulationInvestmentCreateManyUserInput | SimulationInvestmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StartupCreateWithoutFounderInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutFounderInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutFounderInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutFounderInput, StartupUncheckedCreateWithoutFounderInput>
  }

  export type StartupCreateManyFounderInputEnvelope = {
    data: StartupCreateManyFounderInput | StartupCreateManyFounderInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutCreatorInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutCreatorInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput>
  }

  export type TokenCreateManyCreatorInputEnvelope = {
    data: TokenCreateManyCreatorInput | TokenCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AdminActivityLogCreateWithoutAdminInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AdminActivityLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AdminActivityLogCreateOrConnectWithoutAdminInput = {
    where: AdminActivityLogWhereUniqueInput
    create: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminActivityLogCreateManyAdminInputEnvelope = {
    data: AdminActivityLogCreateManyAdminInput | AdminActivityLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type PaymentIntentCreateWithoutUserInput = {
    id?: string
    provider: string
    providerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    providerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentIntentCreateOrConnectWithoutUserInput = {
    where: PaymentIntentWhereUniqueInput
    create: XOR<PaymentIntentCreateWithoutUserInput, PaymentIntentUncheckedCreateWithoutUserInput>
  }

  export type PaymentIntentCreateManyUserInputEnvelope = {
    data: PaymentIntentCreateManyUserInput | PaymentIntentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
    txs?: CryptoTxCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
    txs?: CryptoTxUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateManyUserInputEnvelope = {
    data: WalletCreateManyUserInput | WalletCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startup?: StartupCreateNestedOneWithoutCommentsInput
    token?: TokenCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
    tokenId?: string | null
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SimulationCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedSimulationsInput
    investments?: SimulationInvestmentCreateNestedManyWithoutSimulationInput
    leaderboard?: SimulationLeaderboardCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    investments?: SimulationInvestmentUncheckedCreateNestedManyWithoutSimulationInput
    leaderboard?: SimulationLeaderboardUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutParticipantsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutParticipantsInput, SimulationUncheckedCreateWithoutParticipantsInput>
  }

  export type SimulationCreateWithoutOwnerInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserCreateNestedManyWithoutSimulationsInput
    investments?: SimulationInvestmentCreateNestedManyWithoutSimulationInput
    leaderboard?: SimulationLeaderboardCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserUncheckedCreateNestedManyWithoutSimulationsInput
    investments?: SimulationInvestmentUncheckedCreateNestedManyWithoutSimulationInput
    leaderboard?: SimulationLeaderboardUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutOwnerInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutOwnerInput, SimulationUncheckedCreateWithoutOwnerInput>
  }

  export type SimulationCreateManyOwnerInputEnvelope = {
    data: SimulationCreateManyOwnerInput | SimulationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type DealMatchingCreateWithoutUserInput = {
    id?: string
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    startup?: StartupCreateNestedOneWithoutDealMatchingsInput
    token?: TokenCreateNestedOneWithoutDealMatchingsInput
  }

  export type DealMatchingUncheckedCreateWithoutUserInput = {
    id?: string
    startupId?: string | null
    tokenId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealMatchingCreateOrConnectWithoutUserInput = {
    where: DealMatchingWhereUniqueInput
    create: XOR<DealMatchingCreateWithoutUserInput, DealMatchingUncheckedCreateWithoutUserInput>
  }

  export type DealMatchingCreateManyUserInputEnvelope = {
    data: DealMatchingCreateManyUserInput | DealMatchingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutUserInput = {
    id?: string
    totalScore?: number
    currentLevel?: number
    completedSimulations?: number
    successfulInvestments?: number
    averageROI?: Decimal | DecimalJsLike | number | string
    valuationSkill?: number
    dueDiligenceSkill?: number
    riskAssessmentSkill?: number
    lastActivityAt?: Date | string
  }

  export type UserProgressUncheckedCreateWithoutUserInput = {
    id?: string
    totalScore?: number
    currentLevel?: number
    completedSimulations?: number
    successfulInvestments?: number
    averageROI?: Decimal | DecimalJsLike | number | string
    valuationSkill?: number
    dueDiligenceSkill?: number
    riskAssessmentSkill?: number
    lastActivityAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressCreateManyUserInputEnvelope = {
    data: UserProgressCreateManyUserInput | UserProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserLearningModuleCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
    learningModule: LearningModuleCreateNestedOneWithoutUserLearningModulesInput
  }

  export type UserLearningModuleUncheckedCreateWithoutUserInput = {
    id?: string
    learningModuleId: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
  }

  export type UserLearningModuleCreateOrConnectWithoutUserInput = {
    where: UserLearningModuleWhereUniqueInput
    create: XOR<UserLearningModuleCreateWithoutUserInput, UserLearningModuleUncheckedCreateWithoutUserInput>
  }

  export type UserLearningModuleCreateManyUserInputEnvelope = {
    data: UserLearningModuleCreateManyUserInput | UserLearningModuleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SimulationLeaderboardCreateWithoutUserInput = {
    id?: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
    simulation: SimulationCreateNestedOneWithoutLeaderboardInput
  }

  export type SimulationLeaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    simulationId: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardCreateOrConnectWithoutUserInput = {
    where: SimulationLeaderboardWhereUniqueInput
    create: XOR<SimulationLeaderboardCreateWithoutUserInput, SimulationLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type SimulationLeaderboardCreateManyUserInputEnvelope = {
    data: SimulationLeaderboardCreateManyUserInput | SimulationLeaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringFilter<"Session"> | string
    userAgent?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type KYCRecordUpsertWithoutUserInput = {
    update: XOR<KYCRecordUpdateWithoutUserInput, KYCRecordUncheckedUpdateWithoutUserInput>
    create: XOR<KYCRecordCreateWithoutUserInput, KYCRecordUncheckedCreateWithoutUserInput>
    where?: KYCRecordWhereInput
  }

  export type KYCRecordUpdateToOneWithWhereWithoutUserInput = {
    where?: KYCRecordWhereInput
    data: XOR<KYCRecordUpdateWithoutUserInput, KYCRecordUncheckedUpdateWithoutUserInput>
  }

  export type KYCRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: NullableStringFieldUpdateOperationsInput | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrls?: NullableStringFieldUpdateOperationsInput | string | null
    verificationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMemberScalarWhereInput = {
    AND?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    OR?: OrganizationMemberScalarWhereInput[]
    NOT?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
  }

  export type InvestmentUpsertWithWhereUniqueWithoutUserInput = {
    where: InvestmentWhereUniqueInput
    update: XOR<InvestmentUpdateWithoutUserInput, InvestmentUncheckedUpdateWithoutUserInput>
    create: XOR<InvestmentCreateWithoutUserInput, InvestmentUncheckedCreateWithoutUserInput>
  }

  export type InvestmentUpdateWithWhereUniqueWithoutUserInput = {
    where: InvestmentWhereUniqueInput
    data: XOR<InvestmentUpdateWithoutUserInput, InvestmentUncheckedUpdateWithoutUserInput>
  }

  export type InvestmentUpdateManyWithWhereWithoutUserInput = {
    where: InvestmentScalarWhereInput
    data: XOR<InvestmentUpdateManyMutationInput, InvestmentUncheckedUpdateManyWithoutUserInput>
  }

  export type InvestmentScalarWhereInput = {
    AND?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
    OR?: InvestmentScalarWhereInput[]
    NOT?: InvestmentScalarWhereInput | InvestmentScalarWhereInput[]
    id?: StringFilter<"Investment"> | string
    userId?: StringFilter<"Investment"> | string
    startupId?: StringNullableFilter<"Investment"> | string | null
    tokenId?: StringNullableFilter<"Investment"> | string | null
    amount?: DecimalFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFilter<"Investment"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalNullableFilter<"Investment"> | Decimal | DecimalJsLike | number | string | null
    terms?: JsonNullableFilter<"Investment">
    status?: StringFilter<"Investment"> | string
    createdAt?: DateTimeFilter<"Investment"> | Date | string
    updatedAt?: DateTimeFilter<"Investment"> | Date | string
  }

  export type SimulationInvestmentUpsertWithWhereUniqueWithoutUserInput = {
    where: SimulationInvestmentWhereUniqueInput
    update: XOR<SimulationInvestmentUpdateWithoutUserInput, SimulationInvestmentUncheckedUpdateWithoutUserInput>
    create: XOR<SimulationInvestmentCreateWithoutUserInput, SimulationInvestmentUncheckedCreateWithoutUserInput>
  }

  export type SimulationInvestmentUpdateWithWhereUniqueWithoutUserInput = {
    where: SimulationInvestmentWhereUniqueInput
    data: XOR<SimulationInvestmentUpdateWithoutUserInput, SimulationInvestmentUncheckedUpdateWithoutUserInput>
  }

  export type SimulationInvestmentUpdateManyWithWhereWithoutUserInput = {
    where: SimulationInvestmentScalarWhereInput
    data: XOR<SimulationInvestmentUpdateManyMutationInput, SimulationInvestmentUncheckedUpdateManyWithoutUserInput>
  }

  export type SimulationInvestmentScalarWhereInput = {
    AND?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
    OR?: SimulationInvestmentScalarWhereInput[]
    NOT?: SimulationInvestmentScalarWhereInput | SimulationInvestmentScalarWhereInput[]
    id?: StringFilter<"SimulationInvestment"> | string
    simulationId?: StringFilter<"SimulationInvestment"> | string
    userId?: StringFilter<"SimulationInvestment"> | string
    startupId?: StringNullableFilter<"SimulationInvestment"> | string | null
    tokenId?: StringNullableFilter<"SimulationInvestment"> | string | null
    amount?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    roi?: DecimalFilter<"SimulationInvestment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SimulationInvestment"> | Date | string
    updatedAt?: DateTimeFilter<"SimulationInvestment"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type StartupUpsertWithWhereUniqueWithoutFounderInput = {
    where: StartupWhereUniqueInput
    update: XOR<StartupUpdateWithoutFounderInput, StartupUncheckedUpdateWithoutFounderInput>
    create: XOR<StartupCreateWithoutFounderInput, StartupUncheckedCreateWithoutFounderInput>
  }

  export type StartupUpdateWithWhereUniqueWithoutFounderInput = {
    where: StartupWhereUniqueInput
    data: XOR<StartupUpdateWithoutFounderInput, StartupUncheckedUpdateWithoutFounderInput>
  }

  export type StartupUpdateManyWithWhereWithoutFounderInput = {
    where: StartupScalarWhereInput
    data: XOR<StartupUpdateManyMutationInput, StartupUncheckedUpdateManyWithoutFounderInput>
  }

  export type StartupScalarWhereInput = {
    AND?: StartupScalarWhereInput | StartupScalarWhereInput[]
    OR?: StartupScalarWhereInput[]
    NOT?: StartupScalarWhereInput | StartupScalarWhereInput[]
    id?: StringFilter<"Startup"> | string
    name?: StringFilter<"Startup"> | string
    description?: StringFilter<"Startup"> | string
    industry?: StringFilter<"Startup"> | string
    stage?: EnumFundingStageFilter<"Startup"> | $Enums.FundingStage
    website?: StringNullableFilter<"Startup"> | string | null
    pitchDeck?: StringNullableFilter<"Startup"> | string | null
    fundingGoal?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFilter<"Startup"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFilter<"Startup"> | boolean
    isActive?: BoolFilter<"Startup"> | boolean
    aiGeneratedMetrics?: JsonNullableFilter<"Startup">
    simulationData?: JsonNullableFilter<"Startup">
    createdAt?: DateTimeFilter<"Startup"> | Date | string
    updatedAt?: DateTimeFilter<"Startup"> | Date | string
    founderId?: StringFilter<"Startup"> | string
    organizationId?: StringNullableFilter<"Startup"> | string | null
  }

  export type TokenUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutCreatorInput, TokenUncheckedUpdateWithoutCreatorInput>
    create: XOR<TokenCreateWithoutCreatorInput, TokenUncheckedCreateWithoutCreatorInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutCreatorInput, TokenUncheckedUpdateWithoutCreatorInput>
  }

  export type TokenUpdateManyWithWhereWithoutCreatorInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    name?: StringFilter<"Token"> | string
    symbol?: StringFilter<"Token"> | string
    description?: StringFilter<"Token"> | string
    totalSupply?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFilter<"Token"> | string
    whitepaperUrl?: StringNullableFilter<"Token"> | string | null
    fundingGoal?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFilter<"Token"> | boolean
    isActive?: BoolFilter<"Token"> | boolean
    contractAddress?: StringNullableFilter<"Token"> | string | null
    chain?: EnumChainNullableFilter<"Token"> | $Enums.Chain | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    creatorId?: StringFilter<"Token"> | string
    organizationId?: StringNullableFilter<"Token"> | string | null
  }

  export type AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminActivityLogWhereUniqueInput
    update: XOR<AdminActivityLogUpdateWithoutAdminInput, AdminActivityLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminActivityLogWhereUniqueInput
    data: XOR<AdminActivityLogUpdateWithoutAdminInput, AdminActivityLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminActivityLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminActivityLogScalarWhereInput
    data: XOR<AdminActivityLogUpdateManyMutationInput, AdminActivityLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminActivityLogScalarWhereInput = {
    AND?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
    OR?: AdminActivityLogScalarWhereInput[]
    NOT?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
    id?: StringFilter<"AdminActivityLog"> | string
    adminId?: StringFilter<"AdminActivityLog"> | string
    action?: StringFilter<"AdminActivityLog"> | string
    targetId?: StringNullableFilter<"AdminActivityLog"> | string | null
    targetType?: EnumEntityTypeNullableFilter<"AdminActivityLog"> | $Enums.EntityType | null
    details?: JsonNullableFilter<"AdminActivityLog">
    timestamp?: DateTimeFilter<"AdminActivityLog"> | Date | string
  }

  export type PaymentIntentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentIntentWhereUniqueInput
    update: XOR<PaymentIntentUpdateWithoutUserInput, PaymentIntentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentIntentCreateWithoutUserInput, PaymentIntentUncheckedCreateWithoutUserInput>
  }

  export type PaymentIntentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentIntentWhereUniqueInput
    data: XOR<PaymentIntentUpdateWithoutUserInput, PaymentIntentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentIntentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentIntentScalarWhereInput
    data: XOR<PaymentIntentUpdateManyMutationInput, PaymentIntentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentIntentScalarWhereInput = {
    AND?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
    OR?: PaymentIntentScalarWhereInput[]
    NOT?: PaymentIntentScalarWhereInput | PaymentIntentScalarWhereInput[]
    id?: StringFilter<"PaymentIntent"> | string
    userId?: StringFilter<"PaymentIntent"> | string
    provider?: StringFilter<"PaymentIntent"> | string
    providerId?: StringFilter<"PaymentIntent"> | string
    amount?: DecimalFilter<"PaymentIntent"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"PaymentIntent"> | string
    status?: EnumPaymentStatusFilter<"PaymentIntent"> | $Enums.PaymentStatus
    metadata?: JsonNullableFilter<"PaymentIntent">
    createdAt?: DateTimeFilter<"PaymentIntent"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentIntent"> | Date | string
  }

  export type WalletUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateManyWithWhereWithoutUserInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutUserInput>
  }

  export type WalletScalarWhereInput = {
    AND?: WalletScalarWhereInput | WalletScalarWhereInput[]
    OR?: WalletScalarWhereInput[]
    NOT?: WalletScalarWhereInput | WalletScalarWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    chain?: EnumChainFilter<"Wallet"> | $Enums.Chain
    nickname?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    userId?: StringFilter<"Comment"> | string
    entityType?: EnumEntityTypeFilter<"Comment"> | $Enums.EntityType
    entityId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isEdited?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    startupId?: StringNullableFilter<"Comment"> | string | null
    tokenId?: StringNullableFilter<"Comment"> | string | null
  }

  export type SimulationUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: SimulationWhereUniqueInput
    update: XOR<SimulationUpdateWithoutParticipantsInput, SimulationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<SimulationCreateWithoutParticipantsInput, SimulationUncheckedCreateWithoutParticipantsInput>
  }

  export type SimulationUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: SimulationWhereUniqueInput
    data: XOR<SimulationUpdateWithoutParticipantsInput, SimulationUncheckedUpdateWithoutParticipantsInput>
  }

  export type SimulationUpdateManyWithWhereWithoutParticipantsInput = {
    where: SimulationScalarWhereInput
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyWithoutParticipantsInput>
  }

  export type SimulationScalarWhereInput = {
    AND?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
    OR?: SimulationScalarWhereInput[]
    NOT?: SimulationScalarWhereInput | SimulationScalarWhereInput[]
    id?: StringFilter<"Simulation"> | string
    title?: StringFilter<"Simulation"> | string
    description?: StringFilter<"Simulation"> | string
    type?: EnumSimulationTypeFilter<"Simulation"> | $Enums.SimulationType
    status?: EnumSimulationStatusFilter<"Simulation"> | $Enums.SimulationStatus
    maxParticipants?: IntFilter<"Simulation"> | number
    startDate?: DateTimeFilter<"Simulation"> | Date | string
    endDate?: DateTimeFilter<"Simulation"> | Date | string
    initialBudget?: DecimalFilter<"Simulation"> | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFilter<"Simulation"> | number
    scenarioData?: JsonFilter<"Simulation">
    ownerId?: StringFilter<"Simulation"> | string
    createdAt?: DateTimeFilter<"Simulation"> | Date | string
    updatedAt?: DateTimeFilter<"Simulation"> | Date | string
  }

  export type SimulationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: SimulationWhereUniqueInput
    update: XOR<SimulationUpdateWithoutOwnerInput, SimulationUncheckedUpdateWithoutOwnerInput>
    create: XOR<SimulationCreateWithoutOwnerInput, SimulationUncheckedCreateWithoutOwnerInput>
  }

  export type SimulationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: SimulationWhereUniqueInput
    data: XOR<SimulationUpdateWithoutOwnerInput, SimulationUncheckedUpdateWithoutOwnerInput>
  }

  export type SimulationUpdateManyWithWhereWithoutOwnerInput = {
    where: SimulationScalarWhereInput
    data: XOR<SimulationUpdateManyMutationInput, SimulationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type DealMatchingUpsertWithWhereUniqueWithoutUserInput = {
    where: DealMatchingWhereUniqueInput
    update: XOR<DealMatchingUpdateWithoutUserInput, DealMatchingUncheckedUpdateWithoutUserInput>
    create: XOR<DealMatchingCreateWithoutUserInput, DealMatchingUncheckedCreateWithoutUserInput>
  }

  export type DealMatchingUpdateWithWhereUniqueWithoutUserInput = {
    where: DealMatchingWhereUniqueInput
    data: XOR<DealMatchingUpdateWithoutUserInput, DealMatchingUncheckedUpdateWithoutUserInput>
  }

  export type DealMatchingUpdateManyWithWhereWithoutUserInput = {
    where: DealMatchingScalarWhereInput
    data: XOR<DealMatchingUpdateManyMutationInput, DealMatchingUncheckedUpdateManyWithoutUserInput>
  }

  export type DealMatchingScalarWhereInput = {
    AND?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
    OR?: DealMatchingScalarWhereInput[]
    NOT?: DealMatchingScalarWhereInput | DealMatchingScalarWhereInput[]
    id?: StringFilter<"DealMatching"> | string
    userId?: StringFilter<"DealMatching"> | string
    startupId?: StringNullableFilter<"DealMatching"> | string | null
    tokenId?: StringNullableFilter<"DealMatching"> | string | null
    matchScore?: DecimalFilter<"DealMatching"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringFilter<"DealMatching"> | string
    isRecommended?: BoolFilter<"DealMatching"> | boolean
    userFeedback?: StringNullableFilter<"DealMatching"> | string | null
    createdAt?: DateTimeFilter<"DealMatching"> | Date | string
    updatedAt?: DateTimeFilter<"DealMatching"> | Date | string
  }

  export type UserProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    totalScore?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    completedSimulations?: IntFilter<"UserProgress"> | number
    successfulInvestments?: IntFilter<"UserProgress"> | number
    averageROI?: DecimalFilter<"UserProgress"> | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFilter<"UserProgress"> | number
    dueDiligenceSkill?: IntFilter<"UserProgress"> | number
    riskAssessmentSkill?: IntFilter<"UserProgress"> | number
    lastActivityAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type UserLearningModuleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLearningModuleWhereUniqueInput
    update: XOR<UserLearningModuleUpdateWithoutUserInput, UserLearningModuleUncheckedUpdateWithoutUserInput>
    create: XOR<UserLearningModuleCreateWithoutUserInput, UserLearningModuleUncheckedCreateWithoutUserInput>
  }

  export type UserLearningModuleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLearningModuleWhereUniqueInput
    data: XOR<UserLearningModuleUpdateWithoutUserInput, UserLearningModuleUncheckedUpdateWithoutUserInput>
  }

  export type UserLearningModuleUpdateManyWithWhereWithoutUserInput = {
    where: UserLearningModuleScalarWhereInput
    data: XOR<UserLearningModuleUpdateManyMutationInput, UserLearningModuleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLearningModuleScalarWhereInput = {
    AND?: UserLearningModuleScalarWhereInput | UserLearningModuleScalarWhereInput[]
    OR?: UserLearningModuleScalarWhereInput[]
    NOT?: UserLearningModuleScalarWhereInput | UserLearningModuleScalarWhereInput[]
    id?: StringFilter<"UserLearningModule"> | string
    userId?: StringFilter<"UserLearningModule"> | string
    learningModuleId?: StringFilter<"UserLearningModule"> | string
    completed?: BoolFilter<"UserLearningModule"> | boolean
    score?: IntNullableFilter<"UserLearningModule"> | number | null
    completedAt?: DateTimeNullableFilter<"UserLearningModule"> | Date | string | null
  }

  export type SimulationLeaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: SimulationLeaderboardWhereUniqueInput
    update: XOR<SimulationLeaderboardUpdateWithoutUserInput, SimulationLeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<SimulationLeaderboardCreateWithoutUserInput, SimulationLeaderboardUncheckedCreateWithoutUserInput>
  }

  export type SimulationLeaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: SimulationLeaderboardWhereUniqueInput
    data: XOR<SimulationLeaderboardUpdateWithoutUserInput, SimulationLeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type SimulationLeaderboardUpdateManyWithWhereWithoutUserInput = {
    where: SimulationLeaderboardScalarWhereInput
    data: XOR<SimulationLeaderboardUpdateManyMutationInput, SimulationLeaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type SimulationLeaderboardScalarWhereInput = {
    AND?: SimulationLeaderboardScalarWhereInput | SimulationLeaderboardScalarWhereInput[]
    OR?: SimulationLeaderboardScalarWhereInput[]
    NOT?: SimulationLeaderboardScalarWhereInput | SimulationLeaderboardScalarWhereInput[]
    id?: StringFilter<"SimulationLeaderboard"> | string
    simulationId?: StringFilter<"SimulationLeaderboard"> | string
    userId?: StringFilter<"SimulationLeaderboard"> | string
    rank?: IntFilter<"SimulationLeaderboard"> | number
    totalReturn?: DecimalFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFilter<"SimulationLeaderboard"> | Decimal | DecimalJsLike | number | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationMemberCreateWithoutOrganizationInput = {
    id?: string
    role?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationMemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberCreateManyOrganizationInputEnvelope = {
    data: OrganizationMemberCreateManyOrganizationInput | OrganizationMemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type StartupCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutOrganizationInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutOrganizationInput, StartupUncheckedCreateWithoutOrganizationInput>
  }

  export type StartupCreateManyOrganizationInputEnvelope = {
    data: StartupCreateManyOrganizationInput | StartupCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutOrganizationInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutOrganizationInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutOrganizationInput, TokenUncheckedCreateWithoutOrganizationInput>
  }

  export type TokenCreateManyOrganizationInputEnvelope = {
    data: TokenCreateManyOrganizationInput | TokenCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type StartupUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: StartupWhereUniqueInput
    update: XOR<StartupUpdateWithoutOrganizationInput, StartupUncheckedUpdateWithoutOrganizationInput>
    create: XOR<StartupCreateWithoutOrganizationInput, StartupUncheckedCreateWithoutOrganizationInput>
  }

  export type StartupUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: StartupWhereUniqueInput
    data: XOR<StartupUpdateWithoutOrganizationInput, StartupUncheckedUpdateWithoutOrganizationInput>
  }

  export type StartupUpdateManyWithWhereWithoutOrganizationInput = {
    where: StartupScalarWhereInput
    data: XOR<StartupUpdateManyMutationInput, StartupUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TokenUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutOrganizationInput, TokenUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TokenCreateWithoutOrganizationInput, TokenUncheckedCreateWithoutOrganizationInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutOrganizationInput, TokenUncheckedUpdateWithoutOrganizationInput>
  }

  export type TokenUpdateManyWithWhereWithoutOrganizationInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserCreateWithoutOrganizationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startups?: StartupCreateNestedManyWithoutOrganizationInput
    tokens?: TokenCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startups?: StartupUncheckedCreateNestedManyWithoutOrganizationInput
    tokens?: TokenUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutOrganizationsInput = {
    update: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type UserUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startups?: StartupUpdateManyWithoutOrganizationNestedInput
    tokens?: TokenUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startups?: StartupUncheckedUpdateManyWithoutOrganizationNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutStartupsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStartupsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStartupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStartupsInput, UserUncheckedCreateWithoutStartupsInput>
  }

  export type OrganizationCreateWithoutStartupsInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    tokens?: TokenCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutStartupsInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    tokens?: TokenUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutStartupsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutStartupsInput, OrganizationUncheckedCreateWithoutStartupsInput>
  }

  export type InvestmentCreateWithoutStartupInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestmentsInput
    token?: TokenCreateNestedOneWithoutInvestmentsInput
    vesting?: VestingScheduleCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentUncheckedCreateWithoutStartupInput = {
    id?: string
    userId: string
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vesting?: VestingScheduleUncheckedCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentCreateOrConnectWithoutStartupInput = {
    where: InvestmentWhereUniqueInput
    create: XOR<InvestmentCreateWithoutStartupInput, InvestmentUncheckedCreateWithoutStartupInput>
  }

  export type InvestmentCreateManyStartupInputEnvelope = {
    data: InvestmentCreateManyStartupInput | InvestmentCreateManyStartupInput[]
    skipDuplicates?: boolean
  }

  export type SimulationInvestmentCreateWithoutStartupInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutInvestmentsInput
    user: UserCreateNestedOneWithoutSimulationInvestmentsInput
    token?: TokenCreateNestedOneWithoutSimulationInvestmentsInput
  }

  export type SimulationInvestmentUncheckedCreateWithoutStartupInput = {
    id?: string
    simulationId: string
    userId: string
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateOrConnectWithoutStartupInput = {
    where: SimulationInvestmentWhereUniqueInput
    create: XOR<SimulationInvestmentCreateWithoutStartupInput, SimulationInvestmentUncheckedCreateWithoutStartupInput>
  }

  export type SimulationInvestmentCreateManyStartupInputEnvelope = {
    data: SimulationInvestmentCreateManyStartupInput | SimulationInvestmentCreateManyStartupInput[]
    skipDuplicates?: boolean
  }

  export type DueDiligenceReportCreateWithoutStartupInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Token?: TokenCreateNestedOneWithoutDueDiligenceReportsInput
  }

  export type DueDiligenceReportUncheckedCreateWithoutStartupInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId?: string | null
  }

  export type DueDiligenceReportCreateOrConnectWithoutStartupInput = {
    where: DueDiligenceReportWhereUniqueInput
    create: XOR<DueDiligenceReportCreateWithoutStartupInput, DueDiligenceReportUncheckedCreateWithoutStartupInput>
  }

  export type DueDiligenceReportCreateManyStartupInputEnvelope = {
    data: DueDiligenceReportCreateManyStartupInput | DueDiligenceReportCreateManyStartupInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutStartupInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    entities?: EntityDocumentCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutStartupInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    entities?: EntityDocumentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutStartupInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutStartupInput, DocumentUncheckedCreateWithoutStartupInput>
  }

  export type DocumentCreateManyStartupInputEnvelope = {
    data: DocumentCreateManyStartupInput | DocumentCreateManyStartupInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutStartupInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    token?: TokenCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutStartupInput = {
    id?: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId?: string | null
  }

  export type CommentCreateOrConnectWithoutStartupInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutStartupInput, CommentUncheckedCreateWithoutStartupInput>
  }

  export type CommentCreateManyStartupInputEnvelope = {
    data: CommentCreateManyStartupInput | CommentCreateManyStartupInput[]
    skipDuplicates?: boolean
  }

  export type DealMatchingCreateWithoutStartupInput = {
    id?: string
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealMatchingsInput
    token?: TokenCreateNestedOneWithoutDealMatchingsInput
  }

  export type DealMatchingUncheckedCreateWithoutStartupInput = {
    id?: string
    userId: string
    tokenId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealMatchingCreateOrConnectWithoutStartupInput = {
    where: DealMatchingWhereUniqueInput
    create: XOR<DealMatchingCreateWithoutStartupInput, DealMatchingUncheckedCreateWithoutStartupInput>
  }

  export type DealMatchingCreateManyStartupInputEnvelope = {
    data: DealMatchingCreateManyStartupInput | DealMatchingCreateManyStartupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStartupsInput = {
    update: XOR<UserUpdateWithoutStartupsInput, UserUncheckedUpdateWithoutStartupsInput>
    create: XOR<UserCreateWithoutStartupsInput, UserUncheckedCreateWithoutStartupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStartupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStartupsInput, UserUncheckedUpdateWithoutStartupsInput>
  }

  export type UserUpdateWithoutStartupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStartupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutStartupsInput = {
    update: XOR<OrganizationUpdateWithoutStartupsInput, OrganizationUncheckedUpdateWithoutStartupsInput>
    create: XOR<OrganizationCreateWithoutStartupsInput, OrganizationUncheckedCreateWithoutStartupsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutStartupsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutStartupsInput, OrganizationUncheckedUpdateWithoutStartupsInput>
  }

  export type OrganizationUpdateWithoutStartupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    tokens?: TokenUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutStartupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type InvestmentUpsertWithWhereUniqueWithoutStartupInput = {
    where: InvestmentWhereUniqueInput
    update: XOR<InvestmentUpdateWithoutStartupInput, InvestmentUncheckedUpdateWithoutStartupInput>
    create: XOR<InvestmentCreateWithoutStartupInput, InvestmentUncheckedCreateWithoutStartupInput>
  }

  export type InvestmentUpdateWithWhereUniqueWithoutStartupInput = {
    where: InvestmentWhereUniqueInput
    data: XOR<InvestmentUpdateWithoutStartupInput, InvestmentUncheckedUpdateWithoutStartupInput>
  }

  export type InvestmentUpdateManyWithWhereWithoutStartupInput = {
    where: InvestmentScalarWhereInput
    data: XOR<InvestmentUpdateManyMutationInput, InvestmentUncheckedUpdateManyWithoutStartupInput>
  }

  export type SimulationInvestmentUpsertWithWhereUniqueWithoutStartupInput = {
    where: SimulationInvestmentWhereUniqueInput
    update: XOR<SimulationInvestmentUpdateWithoutStartupInput, SimulationInvestmentUncheckedUpdateWithoutStartupInput>
    create: XOR<SimulationInvestmentCreateWithoutStartupInput, SimulationInvestmentUncheckedCreateWithoutStartupInput>
  }

  export type SimulationInvestmentUpdateWithWhereUniqueWithoutStartupInput = {
    where: SimulationInvestmentWhereUniqueInput
    data: XOR<SimulationInvestmentUpdateWithoutStartupInput, SimulationInvestmentUncheckedUpdateWithoutStartupInput>
  }

  export type SimulationInvestmentUpdateManyWithWhereWithoutStartupInput = {
    where: SimulationInvestmentScalarWhereInput
    data: XOR<SimulationInvestmentUpdateManyMutationInput, SimulationInvestmentUncheckedUpdateManyWithoutStartupInput>
  }

  export type DueDiligenceReportUpsertWithWhereUniqueWithoutStartupInput = {
    where: DueDiligenceReportWhereUniqueInput
    update: XOR<DueDiligenceReportUpdateWithoutStartupInput, DueDiligenceReportUncheckedUpdateWithoutStartupInput>
    create: XOR<DueDiligenceReportCreateWithoutStartupInput, DueDiligenceReportUncheckedCreateWithoutStartupInput>
  }

  export type DueDiligenceReportUpdateWithWhereUniqueWithoutStartupInput = {
    where: DueDiligenceReportWhereUniqueInput
    data: XOR<DueDiligenceReportUpdateWithoutStartupInput, DueDiligenceReportUncheckedUpdateWithoutStartupInput>
  }

  export type DueDiligenceReportUpdateManyWithWhereWithoutStartupInput = {
    where: DueDiligenceReportScalarWhereInput
    data: XOR<DueDiligenceReportUpdateManyMutationInput, DueDiligenceReportUncheckedUpdateManyWithoutStartupInput>
  }

  export type DueDiligenceReportScalarWhereInput = {
    AND?: DueDiligenceReportScalarWhereInput | DueDiligenceReportScalarWhereInput[]
    OR?: DueDiligenceReportScalarWhereInput[]
    NOT?: DueDiligenceReportScalarWhereInput | DueDiligenceReportScalarWhereInput[]
    id?: StringFilter<"DueDiligenceReport"> | string
    entityType?: EnumEntityTypeFilter<"DueDiligenceReport"> | $Enums.EntityType
    entityId?: StringFilter<"DueDiligenceReport"> | string
    summary?: StringFilter<"DueDiligenceReport"> | string
    riskScore?: IntFilter<"DueDiligenceReport"> | number
    sentiment?: StringNullableFilter<"DueDiligenceReport"> | string | null
    financialScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    teamScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    marketScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    technologyScore?: IntNullableFilter<"DueDiligenceReport"> | number | null
    aiGenerated?: BoolFilter<"DueDiligenceReport"> | boolean
    createdAt?: DateTimeFilter<"DueDiligenceReport"> | Date | string
    updatedAt?: DateTimeFilter<"DueDiligenceReport"> | Date | string
    startupId?: StringNullableFilter<"DueDiligenceReport"> | string | null
    tokenId?: StringNullableFilter<"DueDiligenceReport"> | string | null
  }

  export type DocumentUpsertWithWhereUniqueWithoutStartupInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutStartupInput, DocumentUncheckedUpdateWithoutStartupInput>
    create: XOR<DocumentCreateWithoutStartupInput, DocumentUncheckedCreateWithoutStartupInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutStartupInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutStartupInput, DocumentUncheckedUpdateWithoutStartupInput>
  }

  export type DocumentUpdateManyWithWhereWithoutStartupInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutStartupInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    url?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    isActive?: BoolFilter<"Document"> | boolean
    createdAt?: DateTimeFilter<"Document"> | Date | string
    startupId?: StringNullableFilter<"Document"> | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutStartupInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutStartupInput, CommentUncheckedUpdateWithoutStartupInput>
    create: XOR<CommentCreateWithoutStartupInput, CommentUncheckedCreateWithoutStartupInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutStartupInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutStartupInput, CommentUncheckedUpdateWithoutStartupInput>
  }

  export type CommentUpdateManyWithWhereWithoutStartupInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutStartupInput>
  }

  export type DealMatchingUpsertWithWhereUniqueWithoutStartupInput = {
    where: DealMatchingWhereUniqueInput
    update: XOR<DealMatchingUpdateWithoutStartupInput, DealMatchingUncheckedUpdateWithoutStartupInput>
    create: XOR<DealMatchingCreateWithoutStartupInput, DealMatchingUncheckedCreateWithoutStartupInput>
  }

  export type DealMatchingUpdateWithWhereUniqueWithoutStartupInput = {
    where: DealMatchingWhereUniqueInput
    data: XOR<DealMatchingUpdateWithoutStartupInput, DealMatchingUncheckedUpdateWithoutStartupInput>
  }

  export type DealMatchingUpdateManyWithWhereWithoutStartupInput = {
    where: DealMatchingScalarWhereInput
    data: XOR<DealMatchingUpdateManyMutationInput, DealMatchingUncheckedUpdateManyWithoutStartupInput>
  }

  export type UserCreateWithoutTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type OrganizationCreateWithoutTokensInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    startups?: StartupCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTokensInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    startups?: StartupUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTokensInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTokensInput, OrganizationUncheckedCreateWithoutTokensInput>
  }

  export type InvestmentCreateWithoutTokenInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestmentsInput
    startup?: StartupCreateNestedOneWithoutInvestmentsInput
    vesting?: VestingScheduleCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentUncheckedCreateWithoutTokenInput = {
    id?: string
    userId: string
    startupId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vesting?: VestingScheduleUncheckedCreateNestedManyWithoutInvestmentInput
  }

  export type InvestmentCreateOrConnectWithoutTokenInput = {
    where: InvestmentWhereUniqueInput
    create: XOR<InvestmentCreateWithoutTokenInput, InvestmentUncheckedCreateWithoutTokenInput>
  }

  export type InvestmentCreateManyTokenInputEnvelope = {
    data: InvestmentCreateManyTokenInput | InvestmentCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type SimulationInvestmentCreateWithoutTokenInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    simulation: SimulationCreateNestedOneWithoutInvestmentsInput
    user: UserCreateNestedOneWithoutSimulationInvestmentsInput
    startup?: StartupCreateNestedOneWithoutSimulationInvestmentsInput
  }

  export type SimulationInvestmentUncheckedCreateWithoutTokenInput = {
    id?: string
    simulationId: string
    userId: string
    startupId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateOrConnectWithoutTokenInput = {
    where: SimulationInvestmentWhereUniqueInput
    create: XOR<SimulationInvestmentCreateWithoutTokenInput, SimulationInvestmentUncheckedCreateWithoutTokenInput>
  }

  export type SimulationInvestmentCreateManyTokenInputEnvelope = {
    data: SimulationInvestmentCreateManyTokenInput | SimulationInvestmentCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type DueDiligenceReportCreateWithoutTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Startup?: StartupCreateNestedOneWithoutDueDiligenceReportsInput
  }

  export type DueDiligenceReportUncheckedCreateWithoutTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
  }

  export type DueDiligenceReportCreateOrConnectWithoutTokenInput = {
    where: DueDiligenceReportWhereUniqueInput
    create: XOR<DueDiligenceReportCreateWithoutTokenInput, DueDiligenceReportUncheckedCreateWithoutTokenInput>
  }

  export type DueDiligenceReportCreateManyTokenInputEnvelope = {
    data: DueDiligenceReportCreateManyTokenInput | DueDiligenceReportCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type EntityDocumentCreateWithoutTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    visibility?: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutEntitiesInput
  }

  export type EntityDocumentUncheckedCreateWithoutTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    documentId: string
    visibility?: string
    createdAt?: Date | string
  }

  export type EntityDocumentCreateOrConnectWithoutTokenInput = {
    where: EntityDocumentWhereUniqueInput
    create: XOR<EntityDocumentCreateWithoutTokenInput, EntityDocumentUncheckedCreateWithoutTokenInput>
  }

  export type EntityDocumentCreateManyTokenInputEnvelope = {
    data: EntityDocumentCreateManyTokenInput | EntityDocumentCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    startup?: StartupCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutTokenInput = {
    id?: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
  }

  export type CommentCreateOrConnectWithoutTokenInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutTokenInput, CommentUncheckedCreateWithoutTokenInput>
  }

  export type CommentCreateManyTokenInputEnvelope = {
    data: CommentCreateManyTokenInput | CommentCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type DealMatchingCreateWithoutTokenInput = {
    id?: string
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealMatchingsInput
    startup?: StartupCreateNestedOneWithoutDealMatchingsInput
  }

  export type DealMatchingUncheckedCreateWithoutTokenInput = {
    id?: string
    userId: string
    startupId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealMatchingCreateOrConnectWithoutTokenInput = {
    where: DealMatchingWhereUniqueInput
    create: XOR<DealMatchingCreateWithoutTokenInput, DealMatchingUncheckedCreateWithoutTokenInput>
  }

  export type DealMatchingCreateManyTokenInputEnvelope = {
    data: DealMatchingCreateManyTokenInput | DealMatchingCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutTokensInput = {
    update: XOR<OrganizationUpdateWithoutTokensInput, OrganizationUncheckedUpdateWithoutTokensInput>
    create: XOR<OrganizationCreateWithoutTokensInput, OrganizationUncheckedCreateWithoutTokensInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTokensInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTokensInput, OrganizationUncheckedUpdateWithoutTokensInput>
  }

  export type OrganizationUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    startups?: StartupUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    startups?: StartupUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type InvestmentUpsertWithWhereUniqueWithoutTokenInput = {
    where: InvestmentWhereUniqueInput
    update: XOR<InvestmentUpdateWithoutTokenInput, InvestmentUncheckedUpdateWithoutTokenInput>
    create: XOR<InvestmentCreateWithoutTokenInput, InvestmentUncheckedCreateWithoutTokenInput>
  }

  export type InvestmentUpdateWithWhereUniqueWithoutTokenInput = {
    where: InvestmentWhereUniqueInput
    data: XOR<InvestmentUpdateWithoutTokenInput, InvestmentUncheckedUpdateWithoutTokenInput>
  }

  export type InvestmentUpdateManyWithWhereWithoutTokenInput = {
    where: InvestmentScalarWhereInput
    data: XOR<InvestmentUpdateManyMutationInput, InvestmentUncheckedUpdateManyWithoutTokenInput>
  }

  export type SimulationInvestmentUpsertWithWhereUniqueWithoutTokenInput = {
    where: SimulationInvestmentWhereUniqueInput
    update: XOR<SimulationInvestmentUpdateWithoutTokenInput, SimulationInvestmentUncheckedUpdateWithoutTokenInput>
    create: XOR<SimulationInvestmentCreateWithoutTokenInput, SimulationInvestmentUncheckedCreateWithoutTokenInput>
  }

  export type SimulationInvestmentUpdateWithWhereUniqueWithoutTokenInput = {
    where: SimulationInvestmentWhereUniqueInput
    data: XOR<SimulationInvestmentUpdateWithoutTokenInput, SimulationInvestmentUncheckedUpdateWithoutTokenInput>
  }

  export type SimulationInvestmentUpdateManyWithWhereWithoutTokenInput = {
    where: SimulationInvestmentScalarWhereInput
    data: XOR<SimulationInvestmentUpdateManyMutationInput, SimulationInvestmentUncheckedUpdateManyWithoutTokenInput>
  }

  export type DueDiligenceReportUpsertWithWhereUniqueWithoutTokenInput = {
    where: DueDiligenceReportWhereUniqueInput
    update: XOR<DueDiligenceReportUpdateWithoutTokenInput, DueDiligenceReportUncheckedUpdateWithoutTokenInput>
    create: XOR<DueDiligenceReportCreateWithoutTokenInput, DueDiligenceReportUncheckedCreateWithoutTokenInput>
  }

  export type DueDiligenceReportUpdateWithWhereUniqueWithoutTokenInput = {
    where: DueDiligenceReportWhereUniqueInput
    data: XOR<DueDiligenceReportUpdateWithoutTokenInput, DueDiligenceReportUncheckedUpdateWithoutTokenInput>
  }

  export type DueDiligenceReportUpdateManyWithWhereWithoutTokenInput = {
    where: DueDiligenceReportScalarWhereInput
    data: XOR<DueDiligenceReportUpdateManyMutationInput, DueDiligenceReportUncheckedUpdateManyWithoutTokenInput>
  }

  export type EntityDocumentUpsertWithWhereUniqueWithoutTokenInput = {
    where: EntityDocumentWhereUniqueInput
    update: XOR<EntityDocumentUpdateWithoutTokenInput, EntityDocumentUncheckedUpdateWithoutTokenInput>
    create: XOR<EntityDocumentCreateWithoutTokenInput, EntityDocumentUncheckedCreateWithoutTokenInput>
  }

  export type EntityDocumentUpdateWithWhereUniqueWithoutTokenInput = {
    where: EntityDocumentWhereUniqueInput
    data: XOR<EntityDocumentUpdateWithoutTokenInput, EntityDocumentUncheckedUpdateWithoutTokenInput>
  }

  export type EntityDocumentUpdateManyWithWhereWithoutTokenInput = {
    where: EntityDocumentScalarWhereInput
    data: XOR<EntityDocumentUpdateManyMutationInput, EntityDocumentUncheckedUpdateManyWithoutTokenInput>
  }

  export type EntityDocumentScalarWhereInput = {
    AND?: EntityDocumentScalarWhereInput | EntityDocumentScalarWhereInput[]
    OR?: EntityDocumentScalarWhereInput[]
    NOT?: EntityDocumentScalarWhereInput | EntityDocumentScalarWhereInput[]
    id?: StringFilter<"EntityDocument"> | string
    entityType?: EnumEntityTypeFilter<"EntityDocument"> | $Enums.EntityType
    entityId?: StringFilter<"EntityDocument"> | string
    documentId?: StringFilter<"EntityDocument"> | string
    visibility?: StringFilter<"EntityDocument"> | string
    createdAt?: DateTimeFilter<"EntityDocument"> | Date | string
    tokenId?: StringNullableFilter<"EntityDocument"> | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutTokenInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutTokenInput, CommentUncheckedUpdateWithoutTokenInput>
    create: XOR<CommentCreateWithoutTokenInput, CommentUncheckedCreateWithoutTokenInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutTokenInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutTokenInput, CommentUncheckedUpdateWithoutTokenInput>
  }

  export type CommentUpdateManyWithWhereWithoutTokenInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutTokenInput>
  }

  export type DealMatchingUpsertWithWhereUniqueWithoutTokenInput = {
    where: DealMatchingWhereUniqueInput
    update: XOR<DealMatchingUpdateWithoutTokenInput, DealMatchingUncheckedUpdateWithoutTokenInput>
    create: XOR<DealMatchingCreateWithoutTokenInput, DealMatchingUncheckedCreateWithoutTokenInput>
  }

  export type DealMatchingUpdateWithWhereUniqueWithoutTokenInput = {
    where: DealMatchingWhereUniqueInput
    data: XOR<DealMatchingUpdateWithoutTokenInput, DealMatchingUncheckedUpdateWithoutTokenInput>
  }

  export type DealMatchingUpdateManyWithWhereWithoutTokenInput = {
    where: DealMatchingScalarWhereInput
    data: XOR<DealMatchingUpdateManyMutationInput, DealMatchingUncheckedUpdateManyWithoutTokenInput>
  }

  export type UserCreateWithoutOwnedSimulationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedSimulationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedSimulationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedSimulationsInput, UserUncheckedCreateWithoutOwnedSimulationsInput>
  }

  export type UserCreateWithoutSimulationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSimulationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSimulationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput>
  }

  export type SimulationInvestmentCreateWithoutSimulationInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSimulationInvestmentsInput
    startup?: StartupCreateNestedOneWithoutSimulationInvestmentsInput
    token?: TokenCreateNestedOneWithoutSimulationInvestmentsInput
  }

  export type SimulationInvestmentUncheckedCreateWithoutSimulationInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateOrConnectWithoutSimulationInput = {
    where: SimulationInvestmentWhereUniqueInput
    create: XOR<SimulationInvestmentCreateWithoutSimulationInput, SimulationInvestmentUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationInvestmentCreateManySimulationInputEnvelope = {
    data: SimulationInvestmentCreateManySimulationInput | SimulationInvestmentCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type SimulationLeaderboardCreateWithoutSimulationInput = {
    id?: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type SimulationLeaderboardUncheckedCreateWithoutSimulationInput = {
    id?: string
    userId: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardCreateOrConnectWithoutSimulationInput = {
    where: SimulationLeaderboardWhereUniqueInput
    create: XOR<SimulationLeaderboardCreateWithoutSimulationInput, SimulationLeaderboardUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationLeaderboardCreateManySimulationInputEnvelope = {
    data: SimulationLeaderboardCreateManySimulationInput | SimulationLeaderboardCreateManySimulationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedSimulationsInput = {
    update: XOR<UserUpdateWithoutOwnedSimulationsInput, UserUncheckedUpdateWithoutOwnedSimulationsInput>
    create: XOR<UserCreateWithoutOwnedSimulationsInput, UserUncheckedCreateWithoutOwnedSimulationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedSimulationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedSimulationsInput, UserUncheckedUpdateWithoutOwnedSimulationsInput>
  }

  export type UserUpdateWithoutOwnedSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSimulationsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSimulationsInput, UserUncheckedUpdateWithoutSimulationsInput>
    create: XOR<UserCreateWithoutSimulationsInput, UserUncheckedCreateWithoutSimulationsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSimulationsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSimulationsInput, UserUncheckedUpdateWithoutSimulationsInput>
  }

  export type UserUpdateManyWithWhereWithoutSimulationsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSimulationsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    founderStatus?: EnumFounderStatusNullableFilter<"User"> | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFilter<"User"> | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFilter<"User"> | $Enums.DealAccessLevel
    totalSimulationScore?: IntFilter<"User"> | number
    completedSimulations?: IntFilter<"User"> | number
    simulationLevel?: IntFilter<"User"> | number
    bio?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    investmentPreferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SimulationInvestmentUpsertWithWhereUniqueWithoutSimulationInput = {
    where: SimulationInvestmentWhereUniqueInput
    update: XOR<SimulationInvestmentUpdateWithoutSimulationInput, SimulationInvestmentUncheckedUpdateWithoutSimulationInput>
    create: XOR<SimulationInvestmentCreateWithoutSimulationInput, SimulationInvestmentUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationInvestmentUpdateWithWhereUniqueWithoutSimulationInput = {
    where: SimulationInvestmentWhereUniqueInput
    data: XOR<SimulationInvestmentUpdateWithoutSimulationInput, SimulationInvestmentUncheckedUpdateWithoutSimulationInput>
  }

  export type SimulationInvestmentUpdateManyWithWhereWithoutSimulationInput = {
    where: SimulationInvestmentScalarWhereInput
    data: XOR<SimulationInvestmentUpdateManyMutationInput, SimulationInvestmentUncheckedUpdateManyWithoutSimulationInput>
  }

  export type SimulationLeaderboardUpsertWithWhereUniqueWithoutSimulationInput = {
    where: SimulationLeaderboardWhereUniqueInput
    update: XOR<SimulationLeaderboardUpdateWithoutSimulationInput, SimulationLeaderboardUncheckedUpdateWithoutSimulationInput>
    create: XOR<SimulationLeaderboardCreateWithoutSimulationInput, SimulationLeaderboardUncheckedCreateWithoutSimulationInput>
  }

  export type SimulationLeaderboardUpdateWithWhereUniqueWithoutSimulationInput = {
    where: SimulationLeaderboardWhereUniqueInput
    data: XOR<SimulationLeaderboardUpdateWithoutSimulationInput, SimulationLeaderboardUncheckedUpdateWithoutSimulationInput>
  }

  export type SimulationLeaderboardUpdateManyWithWhereWithoutSimulationInput = {
    where: SimulationLeaderboardScalarWhereInput
    data: XOR<SimulationLeaderboardUpdateManyMutationInput, SimulationLeaderboardUncheckedUpdateManyWithoutSimulationInput>
  }

  export type SimulationCreateWithoutInvestmentsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedSimulationsInput
    participants?: UserCreateNestedManyWithoutSimulationsInput
    leaderboard?: SimulationLeaderboardCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutInvestmentsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserUncheckedCreateNestedManyWithoutSimulationsInput
    leaderboard?: SimulationLeaderboardUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutInvestmentsInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutInvestmentsInput, SimulationUncheckedCreateWithoutInvestmentsInput>
  }

  export type UserCreateWithoutSimulationInvestmentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSimulationInvestmentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSimulationInvestmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSimulationInvestmentsInput, UserUncheckedCreateWithoutSimulationInvestmentsInput>
  }

  export type StartupCreateWithoutSimulationInvestmentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutSimulationInvestmentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutSimulationInvestmentsInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutSimulationInvestmentsInput, StartupUncheckedCreateWithoutSimulationInvestmentsInput>
  }

  export type TokenCreateWithoutSimulationInvestmentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutSimulationInvestmentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutSimulationInvestmentsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutSimulationInvestmentsInput, TokenUncheckedCreateWithoutSimulationInvestmentsInput>
  }

  export type SimulationUpsertWithoutInvestmentsInput = {
    update: XOR<SimulationUpdateWithoutInvestmentsInput, SimulationUncheckedUpdateWithoutInvestmentsInput>
    create: XOR<SimulationCreateWithoutInvestmentsInput, SimulationUncheckedCreateWithoutInvestmentsInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutInvestmentsInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutInvestmentsInput, SimulationUncheckedUpdateWithoutInvestmentsInput>
  }

  export type SimulationUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedSimulationsNestedInput
    participants?: UserUpdateManyWithoutSimulationsNestedInput
    leaderboard?: SimulationLeaderboardUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUncheckedUpdateManyWithoutSimulationsNestedInput
    leaderboard?: SimulationLeaderboardUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type UserUpsertWithoutSimulationInvestmentsInput = {
    update: XOR<UserUpdateWithoutSimulationInvestmentsInput, UserUncheckedUpdateWithoutSimulationInvestmentsInput>
    create: XOR<UserCreateWithoutSimulationInvestmentsInput, UserUncheckedCreateWithoutSimulationInvestmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSimulationInvestmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSimulationInvestmentsInput, UserUncheckedUpdateWithoutSimulationInvestmentsInput>
  }

  export type UserUpdateWithoutSimulationInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSimulationInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StartupUpsertWithoutSimulationInvestmentsInput = {
    update: XOR<StartupUpdateWithoutSimulationInvestmentsInput, StartupUncheckedUpdateWithoutSimulationInvestmentsInput>
    create: XOR<StartupCreateWithoutSimulationInvestmentsInput, StartupUncheckedCreateWithoutSimulationInvestmentsInput>
    where?: StartupWhereInput
  }

  export type StartupUpdateToOneWithWhereWithoutSimulationInvestmentsInput = {
    where?: StartupWhereInput
    data: XOR<StartupUpdateWithoutSimulationInvestmentsInput, StartupUncheckedUpdateWithoutSimulationInvestmentsInput>
  }

  export type StartupUpdateWithoutSimulationInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutSimulationInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type TokenUpsertWithoutSimulationInvestmentsInput = {
    update: XOR<TokenUpdateWithoutSimulationInvestmentsInput, TokenUncheckedUpdateWithoutSimulationInvestmentsInput>
    create: XOR<TokenCreateWithoutSimulationInvestmentsInput, TokenUncheckedCreateWithoutSimulationInvestmentsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutSimulationInvestmentsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutSimulationInvestmentsInput, TokenUncheckedUpdateWithoutSimulationInvestmentsInput>
  }

  export type TokenUpdateWithoutSimulationInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutSimulationInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type SimulationCreateWithoutLeaderboardInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedSimulationsInput
    participants?: UserCreateNestedManyWithoutSimulationsInput
    investments?: SimulationInvestmentCreateNestedManyWithoutSimulationInput
  }

  export type SimulationUncheckedCreateWithoutLeaderboardInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: UserUncheckedCreateNestedManyWithoutSimulationsInput
    investments?: SimulationInvestmentUncheckedCreateNestedManyWithoutSimulationInput
  }

  export type SimulationCreateOrConnectWithoutLeaderboardInput = {
    where: SimulationWhereUniqueInput
    create: XOR<SimulationCreateWithoutLeaderboardInput, SimulationUncheckedCreateWithoutLeaderboardInput>
  }

  export type UserCreateWithoutLeaderboardEntriesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type SimulationUpsertWithoutLeaderboardInput = {
    update: XOR<SimulationUpdateWithoutLeaderboardInput, SimulationUncheckedUpdateWithoutLeaderboardInput>
    create: XOR<SimulationCreateWithoutLeaderboardInput, SimulationUncheckedCreateWithoutLeaderboardInput>
    where?: SimulationWhereInput
  }

  export type SimulationUpdateToOneWithWhereWithoutLeaderboardInput = {
    where?: SimulationWhereInput
    data: XOR<SimulationUpdateWithoutLeaderboardInput, SimulationUncheckedUpdateWithoutLeaderboardInput>
  }

  export type SimulationUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedSimulationsNestedInput
    participants?: UserUpdateManyWithoutSimulationsNestedInput
    investments?: SimulationInvestmentUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutLeaderboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUncheckedUpdateManyWithoutSimulationsNestedInput
    investments?: SimulationInvestmentUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type UserUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDealMatchingsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDealMatchingsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDealMatchingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDealMatchingsInput, UserUncheckedCreateWithoutDealMatchingsInput>
  }

  export type StartupCreateWithoutDealMatchingsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutDealMatchingsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutDealMatchingsInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutDealMatchingsInput, StartupUncheckedCreateWithoutDealMatchingsInput>
  }

  export type TokenCreateWithoutDealMatchingsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutDealMatchingsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutDealMatchingsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDealMatchingsInput, TokenUncheckedCreateWithoutDealMatchingsInput>
  }

  export type UserUpsertWithoutDealMatchingsInput = {
    update: XOR<UserUpdateWithoutDealMatchingsInput, UserUncheckedUpdateWithoutDealMatchingsInput>
    create: XOR<UserCreateWithoutDealMatchingsInput, UserUncheckedCreateWithoutDealMatchingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDealMatchingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDealMatchingsInput, UserUncheckedUpdateWithoutDealMatchingsInput>
  }

  export type UserUpdateWithoutDealMatchingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDealMatchingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StartupUpsertWithoutDealMatchingsInput = {
    update: XOR<StartupUpdateWithoutDealMatchingsInput, StartupUncheckedUpdateWithoutDealMatchingsInput>
    create: XOR<StartupCreateWithoutDealMatchingsInput, StartupUncheckedCreateWithoutDealMatchingsInput>
    where?: StartupWhereInput
  }

  export type StartupUpdateToOneWithWhereWithoutDealMatchingsInput = {
    where?: StartupWhereInput
    data: XOR<StartupUpdateWithoutDealMatchingsInput, StartupUncheckedUpdateWithoutDealMatchingsInput>
  }

  export type StartupUpdateWithoutDealMatchingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutDealMatchingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type TokenUpsertWithoutDealMatchingsInput = {
    update: XOR<TokenUpdateWithoutDealMatchingsInput, TokenUncheckedUpdateWithoutDealMatchingsInput>
    create: XOR<TokenCreateWithoutDealMatchingsInput, TokenUncheckedCreateWithoutDealMatchingsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDealMatchingsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDealMatchingsInput, TokenUncheckedUpdateWithoutDealMatchingsInput>
  }

  export type TokenUpdateWithoutDealMatchingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDealMatchingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserLearningModuleCreateWithoutLearningModuleInput = {
    id?: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutLearningModulesInput
  }

  export type UserLearningModuleUncheckedCreateWithoutLearningModuleInput = {
    id?: string
    userId: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
  }

  export type UserLearningModuleCreateOrConnectWithoutLearningModuleInput = {
    where: UserLearningModuleWhereUniqueInput
    create: XOR<UserLearningModuleCreateWithoutLearningModuleInput, UserLearningModuleUncheckedCreateWithoutLearningModuleInput>
  }

  export type UserLearningModuleCreateManyLearningModuleInputEnvelope = {
    data: UserLearningModuleCreateManyLearningModuleInput | UserLearningModuleCreateManyLearningModuleInput[]
    skipDuplicates?: boolean
  }

  export type UserLearningModuleUpsertWithWhereUniqueWithoutLearningModuleInput = {
    where: UserLearningModuleWhereUniqueInput
    update: XOR<UserLearningModuleUpdateWithoutLearningModuleInput, UserLearningModuleUncheckedUpdateWithoutLearningModuleInput>
    create: XOR<UserLearningModuleCreateWithoutLearningModuleInput, UserLearningModuleUncheckedCreateWithoutLearningModuleInput>
  }

  export type UserLearningModuleUpdateWithWhereUniqueWithoutLearningModuleInput = {
    where: UserLearningModuleWhereUniqueInput
    data: XOR<UserLearningModuleUpdateWithoutLearningModuleInput, UserLearningModuleUncheckedUpdateWithoutLearningModuleInput>
  }

  export type UserLearningModuleUpdateManyWithWhereWithoutLearningModuleInput = {
    where: UserLearningModuleScalarWhereInput
    data: XOR<UserLearningModuleUpdateManyMutationInput, UserLearningModuleUncheckedUpdateManyWithoutLearningModuleInput>
  }

  export type UserCreateWithoutLearningModulesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLearningModulesInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLearningModulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLearningModulesInput, UserUncheckedCreateWithoutLearningModulesInput>
  }

  export type LearningModuleCreateWithoutUserLearningModulesInput = {
    id?: string
    title: string
    description: string
    content: string
    category: string
    difficulty?: number
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningModuleUncheckedCreateWithoutUserLearningModulesInput = {
    id?: string
    title: string
    description: string
    content: string
    category: string
    difficulty?: number
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningModuleCreateOrConnectWithoutUserLearningModulesInput = {
    where: LearningModuleWhereUniqueInput
    create: XOR<LearningModuleCreateWithoutUserLearningModulesInput, LearningModuleUncheckedCreateWithoutUserLearningModulesInput>
  }

  export type UserUpsertWithoutLearningModulesInput = {
    update: XOR<UserUpdateWithoutLearningModulesInput, UserUncheckedUpdateWithoutLearningModulesInput>
    create: XOR<UserCreateWithoutLearningModulesInput, UserUncheckedCreateWithoutLearningModulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLearningModulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLearningModulesInput, UserUncheckedUpdateWithoutLearningModulesInput>
  }

  export type UserUpdateWithoutLearningModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLearningModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LearningModuleUpsertWithoutUserLearningModulesInput = {
    update: XOR<LearningModuleUpdateWithoutUserLearningModulesInput, LearningModuleUncheckedUpdateWithoutUserLearningModulesInput>
    create: XOR<LearningModuleCreateWithoutUserLearningModulesInput, LearningModuleUncheckedCreateWithoutUserLearningModulesInput>
    where?: LearningModuleWhereInput
  }

  export type LearningModuleUpdateToOneWithWhereWithoutUserLearningModulesInput = {
    where?: LearningModuleWhereInput
    data: XOR<LearningModuleUpdateWithoutUserLearningModulesInput, LearningModuleUncheckedUpdateWithoutUserLearningModulesInput>
  }

  export type LearningModuleUpdateWithoutUserLearningModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningModuleUncheckedUpdateWithoutUserLearningModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserProgressInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserProgressInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
  }

  export type UserUpsertWithoutUserProgressInput = {
    update: XOR<UserUpdateWithoutUserProgressInput, UserUncheckedUpdateWithoutUserProgressInput>
    create: XOR<UserCreateWithoutUserProgressInput, UserUncheckedCreateWithoutUserProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserProgressInput, UserUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestmentsInput, UserUncheckedCreateWithoutInvestmentsInput>
  }

  export type StartupCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutInvestmentsInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutInvestmentsInput, StartupUncheckedCreateWithoutInvestmentsInput>
  }

  export type TokenCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutInvestmentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutInvestmentsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutInvestmentsInput, TokenUncheckedCreateWithoutInvestmentsInput>
  }

  export type VestingScheduleCreateWithoutInvestmentInput = {
    id?: string
    cliffDate: Date | string
    unlockDate: Date | string
    percentage: Decimal | DecimalJsLike | number | string
    isUnlocked?: boolean
    createdAt?: Date | string
  }

  export type VestingScheduleUncheckedCreateWithoutInvestmentInput = {
    id?: string
    cliffDate: Date | string
    unlockDate: Date | string
    percentage: Decimal | DecimalJsLike | number | string
    isUnlocked?: boolean
    createdAt?: Date | string
  }

  export type VestingScheduleCreateOrConnectWithoutInvestmentInput = {
    where: VestingScheduleWhereUniqueInput
    create: XOR<VestingScheduleCreateWithoutInvestmentInput, VestingScheduleUncheckedCreateWithoutInvestmentInput>
  }

  export type VestingScheduleCreateManyInvestmentInputEnvelope = {
    data: VestingScheduleCreateManyInvestmentInput | VestingScheduleCreateManyInvestmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvestmentsInput = {
    update: XOR<UserUpdateWithoutInvestmentsInput, UserUncheckedUpdateWithoutInvestmentsInput>
    create: XOR<UserCreateWithoutInvestmentsInput, UserUncheckedCreateWithoutInvestmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestmentsInput, UserUncheckedUpdateWithoutInvestmentsInput>
  }

  export type UserUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StartupUpsertWithoutInvestmentsInput = {
    update: XOR<StartupUpdateWithoutInvestmentsInput, StartupUncheckedUpdateWithoutInvestmentsInput>
    create: XOR<StartupCreateWithoutInvestmentsInput, StartupUncheckedCreateWithoutInvestmentsInput>
    where?: StartupWhereInput
  }

  export type StartupUpdateToOneWithWhereWithoutInvestmentsInput = {
    where?: StartupWhereInput
    data: XOR<StartupUpdateWithoutInvestmentsInput, StartupUncheckedUpdateWithoutInvestmentsInput>
  }

  export type StartupUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type TokenUpsertWithoutInvestmentsInput = {
    update: XOR<TokenUpdateWithoutInvestmentsInput, TokenUncheckedUpdateWithoutInvestmentsInput>
    create: XOR<TokenCreateWithoutInvestmentsInput, TokenUncheckedCreateWithoutInvestmentsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutInvestmentsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutInvestmentsInput, TokenUncheckedUpdateWithoutInvestmentsInput>
  }

  export type TokenUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutInvestmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type VestingScheduleUpsertWithWhereUniqueWithoutInvestmentInput = {
    where: VestingScheduleWhereUniqueInput
    update: XOR<VestingScheduleUpdateWithoutInvestmentInput, VestingScheduleUncheckedUpdateWithoutInvestmentInput>
    create: XOR<VestingScheduleCreateWithoutInvestmentInput, VestingScheduleUncheckedCreateWithoutInvestmentInput>
  }

  export type VestingScheduleUpdateWithWhereUniqueWithoutInvestmentInput = {
    where: VestingScheduleWhereUniqueInput
    data: XOR<VestingScheduleUpdateWithoutInvestmentInput, VestingScheduleUncheckedUpdateWithoutInvestmentInput>
  }

  export type VestingScheduleUpdateManyWithWhereWithoutInvestmentInput = {
    where: VestingScheduleScalarWhereInput
    data: XOR<VestingScheduleUpdateManyMutationInput, VestingScheduleUncheckedUpdateManyWithoutInvestmentInput>
  }

  export type VestingScheduleScalarWhereInput = {
    AND?: VestingScheduleScalarWhereInput | VestingScheduleScalarWhereInput[]
    OR?: VestingScheduleScalarWhereInput[]
    NOT?: VestingScheduleScalarWhereInput | VestingScheduleScalarWhereInput[]
    id?: StringFilter<"VestingSchedule"> | string
    investmentId?: StringFilter<"VestingSchedule"> | string
    cliffDate?: DateTimeFilter<"VestingSchedule"> | Date | string
    unlockDate?: DateTimeFilter<"VestingSchedule"> | Date | string
    percentage?: DecimalFilter<"VestingSchedule"> | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFilter<"VestingSchedule"> | boolean
    createdAt?: DateTimeFilter<"VestingSchedule"> | Date | string
  }

  export type InvestmentCreateWithoutVestingInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestmentsInput
    startup?: StartupCreateNestedOneWithoutInvestmentsInput
    token?: TokenCreateNestedOneWithoutInvestmentsInput
  }

  export type InvestmentUncheckedCreateWithoutVestingInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestmentCreateOrConnectWithoutVestingInput = {
    where: InvestmentWhereUniqueInput
    create: XOR<InvestmentCreateWithoutVestingInput, InvestmentUncheckedCreateWithoutVestingInput>
  }

  export type InvestmentUpsertWithoutVestingInput = {
    update: XOR<InvestmentUpdateWithoutVestingInput, InvestmentUncheckedUpdateWithoutVestingInput>
    create: XOR<InvestmentCreateWithoutVestingInput, InvestmentUncheckedCreateWithoutVestingInput>
    where?: InvestmentWhereInput
  }

  export type InvestmentUpdateToOneWithWhereWithoutVestingInput = {
    where?: InvestmentWhereInput
    data: XOR<InvestmentUpdateWithoutVestingInput, InvestmentUncheckedUpdateWithoutVestingInput>
  }

  export type InvestmentUpdateWithoutVestingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutInvestmentsNestedInput
    token?: TokenUpdateOneWithoutInvestmentsNestedInput
  }

  export type InvestmentUncheckedUpdateWithoutVestingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutKycRecordInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycRecordInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycRecordInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycRecordInput, UserUncheckedCreateWithoutKycRecordInput>
  }

  export type UserUpsertWithoutKycRecordInput = {
    update: XOR<UserUpdateWithoutKycRecordInput, UserUncheckedUpdateWithoutKycRecordInput>
    create: XOR<UserCreateWithoutKycRecordInput, UserUncheckedCreateWithoutKycRecordInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycRecordInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycRecordInput, UserUncheckedUpdateWithoutKycRecordInput>
  }

  export type UserUpdateWithoutKycRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StartupCreateWithoutDueDiligenceReportsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutDueDiligenceReportsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutDueDiligenceReportsInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutDueDiligenceReportsInput, StartupUncheckedCreateWithoutDueDiligenceReportsInput>
  }

  export type TokenCreateWithoutDueDiligenceReportsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutDueDiligenceReportsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutDueDiligenceReportsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDueDiligenceReportsInput, TokenUncheckedCreateWithoutDueDiligenceReportsInput>
  }

  export type StartupUpsertWithoutDueDiligenceReportsInput = {
    update: XOR<StartupUpdateWithoutDueDiligenceReportsInput, StartupUncheckedUpdateWithoutDueDiligenceReportsInput>
    create: XOR<StartupCreateWithoutDueDiligenceReportsInput, StartupUncheckedCreateWithoutDueDiligenceReportsInput>
    where?: StartupWhereInput
  }

  export type StartupUpdateToOneWithWhereWithoutDueDiligenceReportsInput = {
    where?: StartupWhereInput
    data: XOR<StartupUpdateWithoutDueDiligenceReportsInput, StartupUncheckedUpdateWithoutDueDiligenceReportsInput>
  }

  export type StartupUpdateWithoutDueDiligenceReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutDueDiligenceReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type TokenUpsertWithoutDueDiligenceReportsInput = {
    update: XOR<TokenUpdateWithoutDueDiligenceReportsInput, TokenUncheckedUpdateWithoutDueDiligenceReportsInput>
    create: XOR<TokenCreateWithoutDueDiligenceReportsInput, TokenUncheckedCreateWithoutDueDiligenceReportsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDueDiligenceReportsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDueDiligenceReportsInput, TokenUncheckedUpdateWithoutDueDiligenceReportsInput>
  }

  export type TokenUpdateWithoutDueDiligenceReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDueDiligenceReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutAdminLogsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminLogsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
  }

  export type UserUpsertWithoutAdminLogsInput = {
    update: XOR<UserUpdateWithoutAdminLogsInput, UserUncheckedUpdateWithoutAdminLogsInput>
    create: XOR<UserCreateWithoutAdminLogsInput, UserUncheckedCreateWithoutAdminLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminLogsInput, UserUncheckedUpdateWithoutAdminLogsInput>
  }

  export type UserUpdateWithoutAdminLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentIntentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentIntentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentIntentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentIntentsInput, UserUncheckedCreateWithoutPaymentIntentsInput>
  }

  export type UserUpsertWithoutPaymentIntentsInput = {
    update: XOR<UserUpdateWithoutPaymentIntentsInput, UserUncheckedUpdateWithoutPaymentIntentsInput>
    create: XOR<UserCreateWithoutPaymentIntentsInput, UserUncheckedCreateWithoutPaymentIntentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentIntentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentIntentsInput, UserUncheckedUpdateWithoutPaymentIntentsInput>
  }

  export type UserUpdateWithoutPaymentIntentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentIntentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWalletsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
  }

  export type CryptoTxCreateWithoutWalletInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    blockNumber?: bigint | number | null
    gasUsed?: bigint | number | null
    timestamp?: Date | string
  }

  export type CryptoTxUncheckedCreateWithoutWalletInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    blockNumber?: bigint | number | null
    gasUsed?: bigint | number | null
    timestamp?: Date | string
  }

  export type CryptoTxCreateOrConnectWithoutWalletInput = {
    where: CryptoTxWhereUniqueInput
    create: XOR<CryptoTxCreateWithoutWalletInput, CryptoTxUncheckedCreateWithoutWalletInput>
  }

  export type CryptoTxCreateManyWalletInputEnvelope = {
    data: CryptoTxCreateManyWalletInput | CryptoTxCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWalletsInput = {
    update: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
    create: XOR<UserCreateWithoutWalletsInput, UserUncheckedCreateWithoutWalletsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletsInput, UserUncheckedUpdateWithoutWalletsInput>
  }

  export type UserUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoTxUpsertWithWhereUniqueWithoutWalletInput = {
    where: CryptoTxWhereUniqueInput
    update: XOR<CryptoTxUpdateWithoutWalletInput, CryptoTxUncheckedUpdateWithoutWalletInput>
    create: XOR<CryptoTxCreateWithoutWalletInput, CryptoTxUncheckedCreateWithoutWalletInput>
  }

  export type CryptoTxUpdateWithWhereUniqueWithoutWalletInput = {
    where: CryptoTxWhereUniqueInput
    data: XOR<CryptoTxUpdateWithoutWalletInput, CryptoTxUncheckedUpdateWithoutWalletInput>
  }

  export type CryptoTxUpdateManyWithWhereWithoutWalletInput = {
    where: CryptoTxScalarWhereInput
    data: XOR<CryptoTxUpdateManyMutationInput, CryptoTxUncheckedUpdateManyWithoutWalletInput>
  }

  export type CryptoTxScalarWhereInput = {
    AND?: CryptoTxScalarWhereInput | CryptoTxScalarWhereInput[]
    OR?: CryptoTxScalarWhereInput[]
    NOT?: CryptoTxScalarWhereInput | CryptoTxScalarWhereInput[]
    id?: StringFilter<"CryptoTx"> | string
    walletId?: StringFilter<"CryptoTx"> | string
    entityType?: EnumEntityTypeFilter<"CryptoTx"> | $Enums.EntityType
    entityId?: StringFilter<"CryptoTx"> | string
    txHash?: StringFilter<"CryptoTx"> | string
    amount?: DecimalFilter<"CryptoTx"> | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFilter<"CryptoTx"> | $Enums.PaymentStatus
    blockNumber?: BigIntNullableFilter<"CryptoTx"> | bigint | number | null
    gasUsed?: BigIntNullableFilter<"CryptoTx"> | bigint | number | null
    timestamp?: DateTimeFilter<"CryptoTx"> | Date | string
  }

  export type WalletCreateWithoutTxsInput = {
    id?: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletsInput
  }

  export type WalletUncheckedCreateWithoutTxsInput = {
    id?: string
    userId: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutTxsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTxsInput, WalletUncheckedCreateWithoutTxsInput>
  }

  export type WalletUpsertWithoutTxsInput = {
    update: XOR<WalletUpdateWithoutTxsInput, WalletUncheckedUpdateWithoutTxsInput>
    create: XOR<WalletCreateWithoutTxsInput, WalletUncheckedCreateWithoutTxsInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTxsInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTxsInput, WalletUncheckedUpdateWithoutTxsInput>
  }

  export type WalletUpdateWithoutTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletsNestedInput
  }

  export type WalletUncheckedUpdateWithoutTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityDocumentCreateWithoutDocumentInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    visibility?: string
    createdAt?: Date | string
    Token?: TokenCreateNestedOneWithoutDocumentsInput
  }

  export type EntityDocumentUncheckedCreateWithoutDocumentInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    visibility?: string
    createdAt?: Date | string
    tokenId?: string | null
  }

  export type EntityDocumentCreateOrConnectWithoutDocumentInput = {
    where: EntityDocumentWhereUniqueInput
    create: XOR<EntityDocumentCreateWithoutDocumentInput, EntityDocumentUncheckedCreateWithoutDocumentInput>
  }

  export type EntityDocumentCreateManyDocumentInputEnvelope = {
    data: EntityDocumentCreateManyDocumentInput | EntityDocumentCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type StartupCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    comments?: CommentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    comments?: CommentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutDocumentsInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutDocumentsInput, StartupUncheckedCreateWithoutDocumentsInput>
  }

  export type EntityDocumentUpsertWithWhereUniqueWithoutDocumentInput = {
    where: EntityDocumentWhereUniqueInput
    update: XOR<EntityDocumentUpdateWithoutDocumentInput, EntityDocumentUncheckedUpdateWithoutDocumentInput>
    create: XOR<EntityDocumentCreateWithoutDocumentInput, EntityDocumentUncheckedCreateWithoutDocumentInput>
  }

  export type EntityDocumentUpdateWithWhereUniqueWithoutDocumentInput = {
    where: EntityDocumentWhereUniqueInput
    data: XOR<EntityDocumentUpdateWithoutDocumentInput, EntityDocumentUncheckedUpdateWithoutDocumentInput>
  }

  export type EntityDocumentUpdateManyWithWhereWithoutDocumentInput = {
    where: EntityDocumentScalarWhereInput
    data: XOR<EntityDocumentUpdateManyMutationInput, EntityDocumentUncheckedUpdateManyWithoutDocumentInput>
  }

  export type StartupUpsertWithoutDocumentsInput = {
    update: XOR<StartupUpdateWithoutDocumentsInput, StartupUncheckedUpdateWithoutDocumentsInput>
    create: XOR<StartupCreateWithoutDocumentsInput, StartupUncheckedCreateWithoutDocumentsInput>
    where?: StartupWhereInput
  }

  export type StartupUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: StartupWhereInput
    data: XOR<StartupUpdateWithoutDocumentsInput, StartupUncheckedUpdateWithoutDocumentsInput>
  }

  export type StartupUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type DocumentCreateWithoutEntitiesInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    Startup?: StartupCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutEntitiesInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
    startupId?: string | null
  }

  export type DocumentCreateOrConnectWithoutEntitiesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEntitiesInput, DocumentUncheckedCreateWithoutEntitiesInput>
  }

  export type TokenCreateWithoutDocumentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    comments?: CommentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    comments?: CommentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutDocumentsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutDocumentsInput, TokenUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentUpsertWithoutEntitiesInput = {
    update: XOR<DocumentUpdateWithoutEntitiesInput, DocumentUncheckedUpdateWithoutEntitiesInput>
    create: XOR<DocumentCreateWithoutEntitiesInput, DocumentUncheckedCreateWithoutEntitiesInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutEntitiesInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutEntitiesInput, DocumentUncheckedUpdateWithoutEntitiesInput>
  }

  export type DocumentUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Startup?: StartupUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenUpsertWithoutDocumentsInput = {
    update: XOR<TokenUpdateWithoutDocumentsInput, TokenUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TokenCreateWithoutDocumentsInput, TokenUncheckedCreateWithoutDocumentsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutDocumentsInput, TokenUncheckedUpdateWithoutDocumentsInput>
  }

  export type TokenUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    investments?: InvestmentCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    startups?: StartupCreateNestedManyWithoutFounderInput
    tokens?: TokenCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentCreateNestedManyWithoutUserInput
    wallets?: WalletCreateNestedManyWithoutUserInput
    simulations?: SimulationCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutUserInput
    userProgress?: UserProgressCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    email: string
    emailVerified?: boolean
    role?: $Enums.UserRole
    founderStatus?: $Enums.FounderStatus | null
    accreditationStatus?: $Enums.AccreditationStatus
    dealAccessLevel?: $Enums.DealAccessLevel
    totalSimulationScore?: number
    completedSimulations?: number
    simulationLevel?: number
    bio?: string | null
    profilePicture?: string | null
    linkedinUrl?: string | null
    location?: string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    kycRecord?: KYCRecordUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    investments?: InvestmentUncheckedCreateNestedManyWithoutUserInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    startups?: StartupUncheckedCreateNestedManyWithoutFounderInput
    tokens?: TokenUncheckedCreateNestedManyWithoutCreatorInput
    adminLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
    paymentIntents?: PaymentIntentUncheckedCreateNestedManyWithoutUserInput
    wallets?: WalletUncheckedCreateNestedManyWithoutUserInput
    simulations?: SimulationUncheckedCreateNestedManyWithoutParticipantsInput
    ownedSimulations?: SimulationUncheckedCreateNestedManyWithoutOwnerInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutUserInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    learningModules?: UserLearningModuleUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: SimulationLeaderboardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type StartupCreateWithoutCommentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founder: UserCreateNestedOneWithoutStartupsInput
    organization?: OrganizationCreateNestedOneWithoutStartupsInput
    investments?: InvestmentCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutStartupInput
    documents?: DocumentCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutStartupInput
  }

  export type StartupUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutStartupInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutStartupInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutStartupInput
    documents?: DocumentUncheckedCreateNestedManyWithoutStartupInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutStartupInput
  }

  export type StartupCreateOrConnectWithoutCommentsInput = {
    where: StartupWhereUniqueInput
    create: XOR<StartupCreateWithoutCommentsInput, StartupUncheckedCreateWithoutCommentsInput>
  }

  export type TokenCreateWithoutCommentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutTokensInput
    organization?: OrganizationCreateNestedOneWithoutTokensInput
    investments?: InvestmentCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    organizationId?: string | null
    investments?: InvestmentUncheckedCreateNestedManyWithoutTokenInput
    simulationInvestments?: SimulationInvestmentUncheckedCreateNestedManyWithoutTokenInput
    dueDiligenceReports?: DueDiligenceReportUncheckedCreateNestedManyWithoutTokenInput
    documents?: EntityDocumentUncheckedCreateNestedManyWithoutTokenInput
    dealMatchings?: DealMatchingUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutCommentsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutCommentsInput, TokenUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    simulations?: SimulationUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    simulations?: SimulationUncheckedUpdateManyWithoutParticipantsNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StartupUpsertWithoutCommentsInput = {
    update: XOR<StartupUpdateWithoutCommentsInput, StartupUncheckedUpdateWithoutCommentsInput>
    create: XOR<StartupCreateWithoutCommentsInput, StartupUncheckedCreateWithoutCommentsInput>
    where?: StartupWhereInput
  }

  export type StartupUpdateToOneWithWhereWithoutCommentsInput = {
    where?: StartupWhereInput
    data: XOR<StartupUpdateWithoutCommentsInput, StartupUncheckedUpdateWithoutCommentsInput>
  }

  export type StartupUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type TokenUpsertWithoutCommentsInput = {
    update: XOR<TokenUpdateWithoutCommentsInput, TokenUncheckedUpdateWithoutCommentsInput>
    create: XOR<TokenCreateWithoutCommentsInput, TokenUncheckedCreateWithoutCommentsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutCommentsInput, TokenUncheckedUpdateWithoutCommentsInput>
  }

  export type TokenUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    idToken?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberCreateManyUserInput = {
    id?: string
    organizationId: string
    role?: string
    joinedAt?: Date | string
  }

  export type InvestmentCreateManyUserInput = {
    id?: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateManyUserInput = {
    id?: string
    simulationId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: boolean
    createdAt?: Date | string
  }

  export type StartupCreateManyFounderInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
  }

  export type TokenCreateManyCreatorInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organizationId?: string | null
  }

  export type AdminActivityLogCreateManyAdminInput = {
    id?: string
    action: string
    targetId?: string | null
    targetType?: $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type PaymentIntentCreateManyUserInput = {
    id?: string
    provider: string
    providerId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateManyUserInput = {
    id?: string
    address: string
    chain: $Enums.Chain
    nickname?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
    tokenId?: string | null
  }

  export type SimulationCreateManyOwnerInput = {
    id?: string
    title: string
    description: string
    type: $Enums.SimulationType
    status?: $Enums.SimulationStatus
    maxParticipants?: number
    startDate: Date | string
    endDate: Date | string
    initialBudget: Decimal | DecimalJsLike | number | string
    difficultyLevel?: number
    scenarioData: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealMatchingCreateManyUserInput = {
    id?: string
    startupId?: string | null
    tokenId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressCreateManyUserInput = {
    id?: string
    totalScore?: number
    currentLevel?: number
    completedSimulations?: number
    successfulInvestments?: number
    averageROI?: Decimal | DecimalJsLike | number | string
    valuationSkill?: number
    dueDiligenceSkill?: number
    riskAssessmentSkill?: number
    lastActivityAt?: Date | string
  }

  export type UserLearningModuleCreateManyUserInput = {
    id?: string
    learningModuleId: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
  }

  export type SimulationLeaderboardCreateManyUserInput = {
    id?: string
    simulationId: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startup?: StartupUpdateOneWithoutInvestmentsNestedInput
    token?: TokenUpdateOneWithoutInvestmentsNestedInput
    vesting?: VestingScheduleUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vesting?: VestingScheduleUncheckedUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutSimulationInvestmentsNestedInput
    token?: TokenUpdateOneWithoutSimulationInvestmentsNestedInput
  }

  export type SimulationInvestmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StartupUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateManyWithoutFounderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminActivityLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetType?: NullableEnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType | null
    details?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentIntentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txs?: CryptoTxUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txs?: CryptoTxUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: EnumChainFieldUpdateOperationsInput | $Enums.Chain
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startup?: StartupUpdateOneWithoutCommentsNestedInput
    token?: TokenUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SimulationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedSimulationsNestedInput
    investments?: SimulationInvestmentUpdateManyWithoutSimulationNestedInput
    leaderboard?: SimulationLeaderboardUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investments?: SimulationInvestmentUncheckedUpdateManyWithoutSimulationNestedInput
    leaderboard?: SimulationLeaderboardUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateManyWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUpdateManyWithoutSimulationsNestedInput
    investments?: SimulationInvestmentUpdateManyWithoutSimulationNestedInput
    leaderboard?: SimulationLeaderboardUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: UserUncheckedUpdateManyWithoutSimulationsNestedInput
    investments?: SimulationInvestmentUncheckedUpdateManyWithoutSimulationNestedInput
    leaderboard?: SimulationLeaderboardUncheckedUpdateManyWithoutSimulationNestedInput
  }

  export type SimulationUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumSimulationTypeFieldUpdateOperationsInput | $Enums.SimulationType
    status?: EnumSimulationStatusFieldUpdateOperationsInput | $Enums.SimulationStatus
    maxParticipants?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    difficultyLevel?: IntFieldUpdateOperationsInput | number
    scenarioData?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealMatchingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startup?: StartupUpdateOneWithoutDealMatchingsNestedInput
    token?: TokenUpdateOneWithoutDealMatchingsNestedInput
  }

  export type DealMatchingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealMatchingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalScore?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    successfulInvestments?: IntFieldUpdateOperationsInput | number
    averageROI?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuationSkill?: IntFieldUpdateOperationsInput | number
    dueDiligenceSkill?: IntFieldUpdateOperationsInput | number
    riskAssessmentSkill?: IntFieldUpdateOperationsInput | number
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLearningModuleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    learningModule?: LearningModuleUpdateOneRequiredWithoutUserLearningModulesNestedInput
  }

  export type UserLearningModuleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningModuleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLearningModuleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    learningModuleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SimulationLeaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    simulation?: SimulationUpdateOneRequiredWithoutLeaderboardNestedInput
  }

  export type SimulationLeaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrganizationMemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    role?: string
    joinedAt?: Date | string
  }

  export type StartupCreateManyOrganizationInput = {
    id?: string
    name: string
    description: string
    industry: string
    stage: $Enums.FundingStage
    website?: string | null
    pitchDeck?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    amountRaised?: Decimal | DecimalJsLike | number | string
    valuation: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    founderId: string
  }

  export type TokenCreateManyOrganizationInput = {
    id?: string
    name: string
    symbol: string
    description: string
    totalSupply: Decimal | DecimalJsLike | number | string
    tokenomics: string
    whitepaperUrl?: string | null
    fundingGoal: Decimal | DecimalJsLike | number | string
    currentPrice: Decimal | DecimalJsLike | number | string
    isApproved?: boolean
    isActive?: boolean
    contractAddress?: string | null
    chain?: $Enums.Chain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
  }

  export type OrganizationMemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StartupUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founder?: UserUpdateOneRequiredWithoutStartupsNestedInput
    investments?: InvestmentUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutStartupNestedInput
    documents?: DocumentUpdateManyWithoutStartupNestedInput
    comments?: CommentUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
    investments?: InvestmentUncheckedUpdateManyWithoutStartupNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutStartupNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutStartupNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutStartupNestedInput
    comments?: CommentUncheckedUpdateManyWithoutStartupNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutStartupNestedInput
  }

  export type StartupUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    stage?: EnumFundingStageFieldUpdateOperationsInput | $Enums.FundingStage
    website?: NullableStringFieldUpdateOperationsInput | string | null
    pitchDeck?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountRaised?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    aiGeneratedMetrics?: NullableJsonNullValueInput | InputJsonValue
    simulationData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founderId?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTokensNestedInput
    investments?: InvestmentUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUpdateManyWithoutTokenNestedInput
    comments?: CommentUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    investments?: InvestmentUncheckedUpdateManyWithoutTokenNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutTokenNestedInput
    dueDiligenceReports?: DueDiligenceReportUncheckedUpdateManyWithoutTokenNestedInput
    documents?: EntityDocumentUncheckedUpdateManyWithoutTokenNestedInput
    comments?: CommentUncheckedUpdateManyWithoutTokenNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tokenomics?: StringFieldUpdateOperationsInput | string
    whitepaperUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fundingGoal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    chain?: NullableEnumChainFieldUpdateOperationsInput | $Enums.Chain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
  }

  export type InvestmentCreateManyStartupInput = {
    id?: string
    userId: string
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateManyStartupInput = {
    id?: string
    simulationId: string
    userId: string
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceReportCreateManyStartupInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId?: string | null
  }

  export type DocumentCreateManyStartupInput = {
    id?: string
    url: string
    title: string
    type: $Enums.DocumentType
    fileSize?: number | null
    mimeType?: string | null
    uploadedBy?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type CommentCreateManyStartupInput = {
    id?: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenId?: string | null
  }

  export type DealMatchingCreateManyStartupInput = {
    id?: string
    userId: string
    tokenId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestmentUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestmentsNestedInput
    token?: TokenUpdateOneWithoutInvestmentsNestedInput
    vesting?: VestingScheduleUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vesting?: VestingScheduleUncheckedUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateManyWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutInvestmentsNestedInput
    user?: UserUpdateOneRequiredWithoutSimulationInvestmentsNestedInput
    token?: TokenUpdateOneWithoutSimulationInvestmentsNestedInput
  }

  export type SimulationInvestmentUncheckedUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceReportUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Token?: TokenUpdateOneWithoutDueDiligenceReportsNestedInput
  }

  export type DueDiligenceReportUncheckedUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DueDiligenceReportUncheckedUpdateManyWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: EntityDocumentUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: EntityDocumentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    token?: TokenUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealMatchingUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealMatchingsNestedInput
    token?: TokenUpdateOneWithoutDealMatchingsNestedInput
  }

  export type DealMatchingUncheckedUpdateWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealMatchingUncheckedUpdateManyWithoutStartupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestmentCreateManyTokenInput = {
    id?: string
    userId: string
    startupId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    valuation?: Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationInvestmentCreateManyTokenInput = {
    id?: string
    simulationId: string
    userId: string
    startupId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DueDiligenceReportCreateManyTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    summary: string
    riskScore: number
    sentiment?: string | null
    financialScore?: number | null
    teamScore?: number | null
    marketScore?: number | null
    technologyScore?: number | null
    aiGenerated?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
  }

  export type EntityDocumentCreateManyTokenInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    documentId: string
    visibility?: string
    createdAt?: Date | string
  }

  export type CommentCreateManyTokenInput = {
    id?: string
    userId: string
    entityType: $Enums.EntityType
    entityId: string
    body: string
    parentId?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    startupId?: string | null
  }

  export type DealMatchingCreateManyTokenInput = {
    id?: string
    userId: string
    startupId?: string | null
    matchScore: Decimal | DecimalJsLike | number | string
    reasoning: string
    isRecommended?: boolean
    userFeedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestmentUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutInvestmentsNestedInput
    vesting?: VestingScheduleUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vesting?: VestingScheduleUncheckedUpdateManyWithoutInvestmentNestedInput
  }

  export type InvestmentUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    valuation?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    terms?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    simulation?: SimulationUpdateOneRequiredWithoutInvestmentsNestedInput
    user?: UserUpdateOneRequiredWithoutSimulationInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutSimulationInvestmentsNestedInput
  }

  export type SimulationInvestmentUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    simulationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DueDiligenceReportUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Startup?: StartupUpdateOneWithoutDueDiligenceReportsNestedInput
  }

  export type DueDiligenceReportUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DueDiligenceReportUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    riskScore?: IntFieldUpdateOperationsInput | number
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    financialScore?: NullableIntFieldUpdateOperationsInput | number | null
    teamScore?: NullableIntFieldUpdateOperationsInput | number | null
    marketScore?: NullableIntFieldUpdateOperationsInput | number | null
    technologyScore?: NullableIntFieldUpdateOperationsInput | number | null
    aiGenerated?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDocumentUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutEntitiesNestedInput
  }

  export type EntityDocumentUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityDocumentUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    startup?: StartupUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DealMatchingUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealMatchingsNestedInput
    startup?: StartupUpdateOneWithoutDealMatchingsNestedInput
  }

  export type DealMatchingUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealMatchingUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    matchScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: StringFieldUpdateOperationsInput | string
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    userFeedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentCreateManySimulationInput = {
    id?: string
    userId: string
    startupId?: string | null
    tokenId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    ownership: Decimal | DecimalJsLike | number | string
    currentValue: Decimal | DecimalJsLike | number | string
    roi: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SimulationLeaderboardCreateManySimulationInput = {
    id?: string
    userId: string
    rank: number
    totalReturn: Decimal | DecimalJsLike | number | string
    roiPercent: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateWithoutSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    investments?: InvestmentUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    startups?: StartupUpdateManyWithoutFounderNestedInput
    tokens?: TokenUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUpdateManyWithoutUserNestedInput
    wallets?: WalletUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    ownedSimulations?: SimulationUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    kycRecord?: KYCRecordUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    investments?: InvestmentUncheckedUpdateManyWithoutUserNestedInput
    simulationInvestments?: SimulationInvestmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    startups?: StartupUncheckedUpdateManyWithoutFounderNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutCreatorNestedInput
    adminLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
    paymentIntents?: PaymentIntentUncheckedUpdateManyWithoutUserNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ownedSimulations?: SimulationUncheckedUpdateManyWithoutOwnerNestedInput
    dealMatchings?: DealMatchingUncheckedUpdateManyWithoutUserNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    learningModules?: UserLearningModuleUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: SimulationLeaderboardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSimulationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    founderStatus?: NullableEnumFounderStatusFieldUpdateOperationsInput | $Enums.FounderStatus | null
    accreditationStatus?: EnumAccreditationStatusFieldUpdateOperationsInput | $Enums.AccreditationStatus
    dealAccessLevel?: EnumDealAccessLevelFieldUpdateOperationsInput | $Enums.DealAccessLevel
    totalSimulationScore?: IntFieldUpdateOperationsInput | number
    completedSimulations?: IntFieldUpdateOperationsInput | number
    simulationLevel?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    investmentPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSimulationInvestmentsNestedInput
    startup?: StartupUpdateOneWithoutSimulationInvestmentsNestedInput
    token?: TokenUpdateOneWithoutSimulationInvestmentsNestedInput
  }

  export type SimulationInvestmentUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationInvestmentUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startupId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ownership?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roi?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SimulationLeaderboardUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type SimulationLeaderboardUncheckedUpdateWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SimulationLeaderboardUncheckedUpdateManyWithoutSimulationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rank?: IntFieldUpdateOperationsInput | number
    totalReturn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    roiPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserLearningModuleCreateManyLearningModuleInput = {
    id?: string
    userId: string
    completed?: boolean
    score?: number | null
    completedAt?: Date | string | null
  }

  export type UserLearningModuleUpdateWithoutLearningModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutLearningModulesNestedInput
  }

  export type UserLearningModuleUncheckedUpdateWithoutLearningModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserLearningModuleUncheckedUpdateManyWithoutLearningModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VestingScheduleCreateManyInvestmentInput = {
    id?: string
    cliffDate: Date | string
    unlockDate: Date | string
    percentage: Decimal | DecimalJsLike | number | string
    isUnlocked?: boolean
    createdAt?: Date | string
  }

  export type VestingScheduleUpdateWithoutInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VestingScheduleUncheckedUpdateWithoutInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VestingScheduleUncheckedUpdateManyWithoutInvestmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    cliffDate?: DateTimeFieldUpdateOperationsInput | Date | string
    unlockDate?: DateTimeFieldUpdateOperationsInput | Date | string
    percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTxCreateManyWalletInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    txHash: string
    amount: Decimal | DecimalJsLike | number | string
    status: $Enums.PaymentStatus
    blockNumber?: bigint | number | null
    gasUsed?: bigint | number | null
    timestamp?: Date | string
  }

  export type CryptoTxUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTxUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoTxUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    blockNumber?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    gasUsed?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityDocumentCreateManyDocumentInput = {
    id?: string
    entityType: $Enums.EntityType
    entityId: string
    visibility?: string
    createdAt?: Date | string
    tokenId?: string | null
  }

  export type EntityDocumentUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Token?: TokenUpdateOneWithoutDocumentsNestedInput
  }

  export type EntityDocumentUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntityDocumentUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    entityId?: StringFieldUpdateOperationsInput | string
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}